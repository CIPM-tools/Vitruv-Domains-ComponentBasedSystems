grammar edu.kit.ipd.sdq.vitruvius.dsls.response.ResponseLanguage 
	with edu.kit.ipd.sdq.vitruvius.dsls.mirbase.MirBase hidden(WS, SL_COMMENT)

generate responseLanguage "http://www.kit.edu/ipd/sdq/vitruvius/dsls/response/ResponseLanguage"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mirbase/MirBase" as mirbase

ResponseFile returns mirbase::MirBaseFile:
	{ResponseFile}
	(namespaceImports=XImportSection)?
	(metamodelImports+=MetamodelImport)*
	(responses += Response)*
;

Response:
	(documentation=ML_COMMENT)?
	'response:' (name=ValidID)?
	trigger=Trigger 
	effects=Effects;

Effects:
	{Effects}
	(targetChange=TargetChange)?
	('execute:' codeBlock=ExecutionCodeBlock)?;

TargetChange:
	ConcreteTargetModelChange | ArbitraryTargetMetamodelInstanceUpdate;

ConcreteTargetModelChange:
	ConcreteTargetModelUpdate | 
	ConcreteTargetModelCreate;
	
ConcreteTargetModelUpdate:
	// You could also put the identifying element together with the retrieved elements. 
	// The generation uses the first element as an identifying element and thus it is easier
	identifyingElement=CorrespondingModelElementRetrieveOrDelete
	('rename model file to:' renamedModelFileName=ModelPathCodeBlock)? 
	(retrieveElements+=CorrespondingModelElementRetrieveOrDelete |
		'create model element:' createElements+=CorrespondingModelElementCreate)*;

ConcreteTargetModelCreate:
	'create root element:' rootElement=CorrespondingModelElementCreate
	(useRelativeToSource?='persist at changed model relative location:'
		| useRelativeToProject?='persist at project-relative location:') modelPath=ModelPathCodeBlock
	('create model element:' createElements+=CorrespondingModelElementCreate)*;

CorrespondingModelElementCreate returns CorrespondingModelElementCreate:
	{CorrespondingModelElementCreate}
	CorrespondingModelElementSpecification;

CorrespondingModelElementRetrieveOrDelete returns CorrespondingModelElementRetrieveOrDelete:
	({CorrespondingModelElementDelete} 'delete model element:' | 
	{CorrespondingModelElementRetrieve} 'retrieve model element:') CorrespondingModelElementSpecification;

CorrespondingModelElementDelete returns CorrespondingModelElementDelete:
	{CorrespondingModelElementDelete}
	'delete model element:' CorrespondingModelElementSpecification;
	
CorrespondingModelElementRetrieve returns CorrespondingModelElementRetrieve:
	{CorrespondingModelElementRetrieve}
	'retrieve model element:' CorrespondingModelElementSpecification;
	
fragment CorrespondingModelElementSpecification:
	name=ValidID 'of type' elementType=ModelElement 'corresponding to' correspondenceSource=CorrespondingObjectCodeBlock;

ArbitraryTargetMetamodelInstanceUpdate:
	'update instances of' metamodelReference=MetamodelReference;

/*ChangeAwareCodeBlock returns :
	StringReturningChangeAwareCodeBlock | EObjectReturningChangeAwareCodeBlock | BooleanReturningChangeAwareCodeBlock;
*/
PreconditionCodeBlock returns PreconditionCodeBlock:
	{PreconditionCodeBlock}
	CodeBlock;

CorrespondingObjectCodeBlock returns CorrespondingObjectCodeBlock:
	{CorrespondingObjectCodeBlock}
	CodeBlock;

ModelPathCodeBlock returns ModelPathCodeBlock:
	{ModelPathCodeBlock}
	CodeBlock;
	
ExecutionCodeBlock returns ExecutionCodeBlock:
	{ExecutionCodeBlock}
	CodeBlock;

fragment CodeBlock:
	code=XExpression;

InvariantViolationEvent:
	'invariant' violation=[ecore::EClass|QualifiedName];

Trigger:
	'trigger:' (ModelChange | InvariantViolationEvent)
	('precondition:' precondition=PreconditionCodeBlock)?;
	
ModelChange:
	ConcreteModelElementChange | ArbitraryModelElementChange;

ConcreteModelElementChange returns ConcreteModelElementChange:
	AtomicConcreteModelElementChange;
	
AtomicConcreteModelElementChange:
	AtomicRootObjectChange | AtomicFeatureChange;

AtomicRootObjectChange:
	('insert root' {InsertRootChange} | 
	'remove root' {RemoveRootChange})
	changedElement=ModelElement;

AtomicFeatureChange:
	(AtomicMultiValuedFeatureChange | AtomicSingleValuedFeatureChange)
	changedFeature=FeatureOfElement;

AtomicMultiValuedFeatureChange returns AtomicMultiValuedFeatureChange:
	'insert in list' {MultiValuedFeatureInsertChange} |
	'remove from list' {MultiValuedFeatureRemoveChange} |
	'permute list' {MultiValuedFeaturePermuteChange};

AtomicSingleValuedFeatureChange returns AtomicSingleValuedFeatureChange:
	/* The next two will be removed with the new Change MM */
	'create value' {SingleValuedFeatureCreate} |
	'delete value' {SingleValuedFeatureDelete} |
	'replace value' {SingleValuedFeatureReplace};

ArbitraryModelElementChange:
	'change in instance of' changedModel=MetamodelReference;
	