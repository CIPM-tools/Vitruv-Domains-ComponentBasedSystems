grammar edu.kit.ipd.sdq.vitruvius.dsls.response.ResponseLanguage with edu.kit.ipd.sdq.vitruvius.dsls.mirbase.MirBase
hidden(WS, SL_COMMENT)

generate responseLanguage "http://www.kit.edu/ipd/sdq/vitruvius/dsls/response/ResponseLanguage"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mirbase/MirBase" as mirbase


ResponseFile:
	(namespaceImports=XImportSection)?
	MirBaseFile
	(responsesSegments+=ResponsesSegment)+;
	
ResponsesSegment:
	'responses from metamodel' fromMetamodel=MetamodelReference 'to metamodel' toMetamodel=MetamodelReference
	'called' name=ValidID
	(responses+=Response |
		routines+=ExplicitRoutine)*;

Response:
	(documentation=ML_COMMENT)?
	'response:' name=ValidID
	trigger=Trigger
	routine=ImplicitRoutine;

// ****** TRIGGER ******

InvariantViolationEvent:
	'invariant' violation=[ecore::EClass|QualifiedName];

Trigger:
	'trigger:' (ModelChange | InvariantViolationEvent)
	('precondition:' precondition=PreconditionCodeBlock)?;

ModelChange:
	ConcreteModelElementChange | ArbitraryModelElementChange;

ConcreteModelElementChange returns ConcreteModelElementChange:
	AtomicConcreteModelElementChange;

AtomicConcreteModelElementChange:
	AtomicRootObjectChange | AtomicFeatureChange;

AtomicRootObjectChange:
	('insert root' {InsertRootChange} |
	'remove root' {RemoveRootChange})
	changedElement=ModelElement;

AtomicFeatureChange:
	(AtomicMultiValuedFeatureChange | AtomicSingleValuedFeatureChange)
	changedFeature=FeatureOfElement;

AtomicMultiValuedFeatureChange returns AtomicMultiValuedFeatureChange:
	'insert in list' {MultiValuedFeatureInsertChange} |
	'remove from list' {MultiValuedFeatureRemoveChange} |
	'permute list' {MultiValuedFeaturePermuteChange};

AtomicSingleValuedFeatureChange returns AtomicSingleValuedFeatureChange:
/* The next two will be removed with the new Change MM */
	'create value' {SingleValuedFeatureCreate} | 'delete value' {SingleValuedFeatureDelete} | 'replace value'
	{SingleValuedFeatureReplace};

ArbitraryModelElementChange:
	{ArbitraryModelElementChange} 'any change';



// ****** EFFECTS ******


fragment Routine:
	matching=Matching
	effect=Effect;

ImplicitRoutine:
	Routine;	

Matching:
	{Matching}
	retrievedElements+=RetrieveModelElement*;

Effect:
	{Effect}
	(correspondenceCreation += CreateCorrespondence | 
		correspondenceDeletion += RemoveCorrespondence)*
	('execute:' codeBlock=ExecutionCodeBlock)?;

ExplicitRoutine:
	'routine:' name=ValidID
	input=RoutineInput
	Routine;
	
RoutineInput:
	{RoutineInput}
	('input:' modelInputElements+=NamedModelElement (',' modelInputElements+=NamedModelElement)*)?
	('plain java input:' javaInputElements+=NamedJavaElement (',' javaInputElements+=NamedJavaElement)*)?;



// ****** CORRESPONDENCE SPECIFICATION ******	

fragment Taggable:
	tag=TagCodeBlock;

RetrieveModelElement:
	(required?='retrieve required element:' | optional?='retrieve optional element:' | 'retrieve element:') 
	element=NamedModelElement 'corresponding to' correspondenceSource=CorrespondingObjectCodeBlock
	('tagged with' Taggable)? ('with' precondition=PreconditionCodeBlock)?;

DeleteCorrespondenceElementReference:
	(delete?="delete-element" | "keep-element") ExistingElementReference;

CreateCorrespondenceElementReference returns ElementReference:
	UseElementReference | NewElementReference;
	
fragment ExistingElementReference:
	CodeBlock;	

UseElementReference:
	"existing-element" ExistingElementReference;

NewElementReference:
	"create-element" element=NamedModelElement;
	
CreateCorrespondence:
	"create correspondence:" firstElement=CreateCorrespondenceElementReference "," secondElement=CreateCorrespondenceElementReference
	('tag with' Taggable)?;
	
RemoveCorrespondence:
	"remove correspondence:" firstElement=DeleteCorrespondenceElementReference "," secondElement=DeleteCorrespondenceElementReference;


// ****** CODE BLOCKS ******

TagCodeBlock returns TagCodeBlock:
	{TagCodeBlock}
	CodeBlock;

PreconditionCodeBlock returns PreconditionCodeBlock:
	{PreconditionCodeBlock}
	CodeBlock;

CorrespondingObjectCodeBlock returns CorrespondingObjectCodeBlock:
	{CorrespondingObjectCodeBlock}
	CodeBlock;

ExecutionCodeBlock returns ExecutionCodeBlock:
	{ExecutionCodeBlock}
	CodeBlock;

fragment CodeBlock:
	code=XExpression;

