grammar edu.kit.ipd.sdq.vitruvius.dsls.response.ResponseLanguage with edu.kit.ipd.sdq.vitruvius.dsls.mirbase.MirBase
hidden(WS, SL_COMMENT)

generate responseLanguage "http://www.kit.edu/ipd/sdq/vitruvius/dsls/response/ResponseLanguage"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mirbase/MirBase" as mirbase

ResponseFile:
	MirBaseFile
	(namespaceImports=XImportSection)?
	(metamodelImports+=MetamodelImport)*
	MetamodelPairResponses;
	
fragment MetamodelPairResponses:
	'responses for metamodels' affectedMetamodels+=MetamodelReference 'and' affectedMetamodels+=MetamodelReference
	(responses+=Response |
		effects+=ExplicitEffect)*;

Response:
	(documentation=ML_COMMENT)?
	'response:' name=ValidID
	trigger=Trigger
	effect=ImplicitEffect;

fragment Effect:
	(retrieveElements+=CorrespondingModelElementRetrieve |
	deleteElements+=CorrespondingModelElementDelete |
	createElements+=CorrespondingModelElementCreate)*
	('execute:' codeBlock=ExecutionCodeBlock)?;

ImplicitEffect:
	Effect;

ExplicitEffect:
	'effect:' name=ValidID
	// TODO HK replace, the distinction is not needed
	('model input:' modelInputElements+=NamedModelElement (',' modelInputElements+=NamedModelElement)*)?
	('other input:' javaInputElements+=NamedJavaElement (',' javaInputElements+=NamedJavaElement)*)?
	Effect;
	
CorrespondingModelElementCreate returns CorrespondingModelElementCreate:
	{CorrespondingModelElementCreate}
	'create element:' CorrespondingModelElementSpecification (persistence=ModelPersistence)?;

ModelPersistence returns ModelLocation:
	(useRelativeToSource?='persist as root at changed model relative location:'
	| useRelativeToProject?='persist as root at project-relative location:') modelPath=ModelPathCodeBlock;
	
ModelMove returns ModelLocation:
	(useRelativeToSource?='move containing model relative to original location:'
	| useRelativeToProject?='move containing model to project-relative location:') modelPath=ModelPathCodeBlock;

CorrespondingModelElementDelete returns CorrespondingModelElementDelete:
	{CorrespondingModelElementDelete}
	'delete element:' CorrespondingModelElementRetrieveOrDelete;

CorrespondingModelElementRetrieve returns CorrespondingModelElementRetrieve:
	{CorrespondingModelElementRetrieve}
	'retrieve element:' CorrespondingModelElementRetrieveOrDelete (persistence=ModelMove)?;

fragment CorrespondingModelElementRetrieveOrDelete:
	CorrespondingModelElementSpecificationWithPrecondition (optional?='optional')?;

fragment CorrespondingModelElementSpecificationWithPrecondition:
	CorrespondingModelElementSpecification ('with' precondition=PreconditionCodeBlock)?;

fragment CorrespondingModelElementSpecification:
	name=ValidID 'of type' elementType=ModelElement 'corresponding to' correspondenceSource=CorrespondingObjectCodeBlock;

ArbitraryTargetMetamodelInstanceUpdate:
	'update instances of' metamodelReference=MetamodelReference;

	/*ChangeAwareCodeBlock returns :
	StringReturningChangeAwareCodeBlock | EObjectReturningChangeAwareCodeBlock | BooleanReturningChangeAwareCodeBlock;
*/
PreconditionCodeBlock returns PreconditionCodeBlock:
	{PreconditionCodeBlock}
	CodeBlock;

CorrespondingObjectCodeBlock returns CorrespondingObjectCodeBlock:
	{CorrespondingObjectCodeBlock}
	CodeBlock;

ModelPathCodeBlock returns ModelPathCodeBlock:
	{ModelPathCodeBlock}
	CodeBlock;

ExecutionCodeBlock returns ExecutionCodeBlock:
	{ExecutionCodeBlock}
	CodeBlock;

fragment CodeBlock:
	code=XExpression;

InvariantViolationEvent:
	'invariant' violation=[ecore::EClass|QualifiedName];

Trigger:
	'trigger:' (ModelChange | InvariantViolationEvent)
	('precondition:' precondition=PreconditionCodeBlock)?;

ModelChange:
	ConcreteModelElementChange | ArbitraryModelElementChange;

ConcreteModelElementChange returns ConcreteModelElementChange:
	AtomicConcreteModelElementChange;

AtomicConcreteModelElementChange:
	AtomicRootObjectChange | AtomicFeatureChange;

AtomicRootObjectChange:
	('insert root' {InsertRootChange} |
	'remove root' {RemoveRootChange})
	changedElement=ModelElement;

AtomicFeatureChange:
	(AtomicMultiValuedFeatureChange | AtomicSingleValuedFeatureChange)
	changedFeature=FeatureOfElement;

AtomicMultiValuedFeatureChange returns AtomicMultiValuedFeatureChange:
	'insert in list' {MultiValuedFeatureInsertChange} |
	'remove from list' {MultiValuedFeatureRemoveChange} |
	'permute list' {MultiValuedFeaturePermuteChange};

AtomicSingleValuedFeatureChange returns AtomicSingleValuedFeatureChange:
/* The next two will be removed with the new Change MM */
	'create value' {SingleValuedFeatureCreate} | 'delete value' {SingleValuedFeatureDelete} | 'replace value'
	{SingleValuedFeatureReplace};

ArbitraryModelElementChange:
	'change in instance of' changedModel=MetamodelReference;
	