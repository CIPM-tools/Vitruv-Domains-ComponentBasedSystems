grammar edu.kit.ipd.sdq.vitruvius.dsls.response.ResponseLanguage 
	with edu.kit.ipd.sdq.vitruvius.dsls.mirbase.MirBase hidden(WS, SL_COMMENT)

generate responseLanguage "http://www.kit.edu/ipd/sdq/vitruvius/dsls/response/ResponseLanguage"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mirbase/MirBase" as mirbase

ResponseFile returns mirbase::MirBaseFile:
	{ResponseFile}
	(metamodelImports+=MetamodelImport)*
	(responses += Response)*
;

Response:
	(documentation=ML_COMMENT)?
	'response:' (name=ValidID)?
	trigger=Trigger 
	effects=Effects;

Effects:
	{Effects}
	(targetChange=TargetChange)?
	(codeBlock=ExecutionBlock)?;

TargetChange:
	ConcreteTargetModelChange | ArbitraryTargetMetamodelInstanceUpdate;

ConcreteTargetModelChange:
	(ConcreteTargetModelUpdate | ConcreteTargetModelCreate);
	
ConcreteTargetModelUpdate:
	// You could also put the identifying element together with the retrieved elements. 
	// The generation uses the first element as an identifying element and thus it is easier
	identifyingElement=CorrespondingModelElementRetrieveOrDelete
	(retrieveElements+=CorrespondingModelElementRetrieveOrDelete |
		'create model element:' createElements+=CorrespondingModelElementCreate)*;

ConcreteTargetModelCreate:
	'create model:' (useRelativeToSource?='file name relative to changed model folder:'
		| useRelativeToProject?='file name relative to project folder:') relativeToSourcePath=PathToSourceSpecificationBlock
	'create root element:' rootElement=CorrespondingModelElementCreate
	('create model element:' createElements+=CorrespondingModelElementCreate)*;

CorrespondingModelElementCreate returns CorrespondingModelElementCreate:
	{CorrespondingModelElementCreate}
	CorrespondingModelElementSpecification;

CorrespondingModelElementRetrieveOrDelete returns CorrespondingModelElementRetrieveOrDelete:
	({CorrespondingModelElementDelete} 'delete model element:' | 
	{CorrespondingModelElementRetrieve} 'retrieve model element:') CorrespondingModelElementSpecification;

CorrespondingModelElementDelete returns CorrespondingModelElementDelete:
	{CorrespondingModelElementDelete}
	'delete model element:' CorrespondingModelElementSpecification;
	
CorrespondingModelElementRetrieve returns CorrespondingModelElementRetrieve:
	{CorrespondingModelElementRetrieve}
	'retrieve model element:' CorrespondingModelElementSpecification;
	
fragment CorrespondingModelElementSpecification:
	name=ValidID 'of type' elementType=ModelElement correspondenceSource=CorrespondenceSourceDeterminationBlock;

ArbitraryTargetMetamodelInstanceUpdate:
	'update instances of' metamodelReference=MetamodelReference;

CodeBlock:
	PathToSourceSpecificationBlock | CorrespondenceSourceDeterminationBlock | PreconditionBlock | ExecutionBlock;

PathToSourceSpecificationBlock:
	{PathToSourceSpecificationBlock}
	code=XExpression;

CorrespondenceSourceDeterminationBlock:
	{CorrespondenceSourceDeterminationBlock}
	'corresponding to' code=XExpression;

PreconditionBlock:
	{PreconditionBlock}
	code=XExpression;

ExecutionBlock:
	{ExecutionBlock}
	'execute:' code=XExpression;

InvariantViolationEvent:
	'invariant' violation=[ecore::EClass|QualifiedName];

Trigger:
	'trigger:' (ModelChange | InvariantViolationEvent)
	('precondition:' precondition=PreconditionBlock)?;
	
ModelChange:
	ConcreteModelElementChange | ArbitraryModelElementChange;

ConcreteModelElementChange returns ConcreteModelElementChange:
	AtomicConcreteModelElementChange;
	
AtomicConcreteModelElementChange:
	AtomicRootObjectChange | AtomicFeatureChange;

AtomicRootObjectChange:
	('insert root' {InsertRootChange} | 
	'remove root' {RemoveRootChange})
	changedElement=ModelElement;

AtomicFeatureChange:
	(AtomicMultiValuedFeatureChange | AtomicSingleValuedFeatureChange)
	changedFeature=FeatureOfElement;

AtomicMultiValuedFeatureChange returns AtomicMultiValuedFeatureChange:
	'insert in list' {MultiValuedFeatureInsertChange} |
	'remove from list' {MultiValuedFeatureRemoveChange} |
	'permute list' {MultiValuedFeaturePermuteChange};

AtomicSingleValuedFeatureChange returns AtomicSingleValuedFeatureChange:
	/* The next two will be removed with the new Change MM */
	'create value' {SingleValuedFeatureCreate} |
	'delete value' {SingleValuedFeatureDelete} |
	'replace value' {SingleValuedFeatureReplace};

ArbitraryModelElementChange:
	'change in instance of' changedModel=MetamodelReference;
	