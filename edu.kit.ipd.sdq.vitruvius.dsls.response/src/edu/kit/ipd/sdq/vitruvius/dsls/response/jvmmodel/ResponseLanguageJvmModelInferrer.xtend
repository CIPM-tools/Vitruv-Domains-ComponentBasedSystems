/*
 * generated by Xtext 2.9.0
 */
package edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel

import com.google.inject.Inject
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Response
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor

import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Trigger
import java.util.List
import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.generator.ResponseLanguageGeneratorUtils.*;
import org.eclipse.xtext.common.types.JvmOperation
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ConcreteTargetModelRootCreate
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.MultiValuedFeatureInsertChange
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ResponseLanguageFactory
import edu.kit.ipd.sdq.vitruvius.dsls.response.generator.impl.SimpleTextXBlockExpression
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.InsertRootChange
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1
import java.util.Map
import java.util.HashMap
import org.apache.log4j.Logger
import org.eclipse.xtext.common.types.JvmField
import edu.kit.ipd.sdq.vitruvius.dsls.response.api.interfaces.IResponseRealization

/**
 * <p>Infers a JVM model for the Xtend code blocks of the response file model.</p> 
 *
 * <p>The resulting classes are not to be persisted but only to be used for content assist purposes.</p>
 * 
 * @author Heiko Klare     
 */
class ResponseLanguageJvmModelInferrer extends AbstractModelInferrer implements IJvmOperationRegistry{

	@Inject extension JvmTypesBuilderWithoutAssociations _typesBuilder
	private Map<String, JvmOperation> methodMap;
	
	def dispatch void infer(Response response, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		
		acceptor.accept(generateClass(response, response));
		for (deleteResponse : response.rootDeleteIfCreate) {
			acceptor.accept(generateClass(deleteResponse, response));
		}
	}
	
	public def JvmGenericType generateClass(Response response, EObject sourceElement) {
		this.methodMap = new HashMap<String, JvmOperation>();
		val methodGenerator = new ResponseMethodGenerator(response, this, _typeReferenceBuilder, _typesBuilder);
		methodGenerator.generateMethodGetTrigger();
		methodGenerator.generateMethodApplyChange();
		
		sourceElement.toClass(response.responseQualifiedName) [
			visibility = JvmVisibility.DEFAULT;
			superTypes += typeRef(IResponseRealization);
			members += generateLoggerInitialization(it);
			members += methodMap.values;
		];
	}
	
	private def JvmField generateLoggerInitialization(JvmGenericType clazz) {
		generateUnassociatedField("LOGGER", typeRef(Logger)) [
			visibility = JvmVisibility.PUBLIC;
			initializer = '''«Logger».getLogger(«clazz».class)'''
		]
	}
	
	private def List<Response> getRootDeleteIfCreate(Response response) {
		val deleteTrigger = response.trigger.deleteTrigger;
		val targetChange = response.effects.targetChange;
		if (targetChange instanceof ConcreteTargetModelRootCreate && deleteTrigger != null) {
			val createTargetChange = targetChange as ConcreteTargetModelRootCreate;
			if (createTargetChange.autodelete) {
				val deleteResponse = ResponseLanguageFactory.eINSTANCE.createResponse();
				deleteResponse.name = "OppositeResponseForDeleteTo" + response.name;
				deleteResponse.trigger = deleteTrigger;
				val deleteEffects = ResponseLanguageFactory.eINSTANCE.createEffects();
				val deleteTargetChange = ResponseLanguageFactory.eINSTANCE.createConcreteTargetModelRootDelete();
				val targetChangeElement = ResponseLanguageFactory.eINSTANCE.createModelElement();
				targetChangeElement.element = createTargetChange.rootModelElement.element;
				deleteTargetChange.rootModelElement = targetChangeElement;
				deleteTargetChange.correspondenceSource = ResponseLanguageFactory.eINSTANCE.createCorrespondenceSourceDeterminationBlock();
				deleteTargetChange.correspondenceSource.code = new SimpleTextXBlockExpression('''return change.getOldValue();''');
				deleteEffects.targetChange = deleteTargetChange;
				deleteResponse.effects = deleteEffects;
				return #[deleteResponse];
			}
		}
		return #[];
	}
	  
	private def dispatch Trigger getDeleteTrigger(Trigger change) {
		return null;
	}
	
	private def dispatch Trigger getDeleteTrigger(MultiValuedFeatureInsertChange change) {
		val deleteTrigger = ResponseLanguageFactory.eINSTANCE.createMultiValuedFeatureRemoveChange();
		val changedElement = ResponseLanguageFactory.eINSTANCE.createFeatureOfElement();
		changedElement.element = change.changedFeature.element;
		changedElement.feature = change.changedFeature.feature;
		deleteTrigger.changedFeature = changedElement;
		return deleteTrigger;
	}
	
	private def dispatch Trigger getDeleteTrigger(InsertRootChange change) {
		val deleteTrigger = ResponseLanguageFactory.eINSTANCE.createRemoveRootChange();
		val changedElement = ResponseLanguageFactory.eINSTANCE.createModelElement();
		changedElement.element = change.changedElement.element;
		deleteTrigger.changedElement = changedElement;
		return deleteTrigger;
	}
		
	override JvmOperation getOrGenerateMethod(EObject contextObject, String methodName, JvmTypeReference returnType, Procedure1<? super JvmOperation> initializer) {
		if (!methodMap.containsKey(methodName)) {
			val operation = contextObject.toMethod(methodName, returnType, initializer);
			methodMap.put(operation.simpleName, operation);
		}
		
		return methodMap.get(methodName);
	}
	
	override JvmOperation getOrGenerateMethod(String methodName, JvmTypeReference returnType, Procedure1<? super JvmOperation> initializer) {
		if (!methodMap.containsKey(methodName)) {
			val operation = generateUnassociatedMethod(methodName, returnType, initializer);
			methodMap.put(operation.simpleName, operation);
		}
		
		return methodMap.get(methodName);
	}
	
}
