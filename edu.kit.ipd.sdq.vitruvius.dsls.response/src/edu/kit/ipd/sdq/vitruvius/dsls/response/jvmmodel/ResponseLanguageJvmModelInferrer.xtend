/*
 * generated by Xtext 2.9.0
 */
package edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel

import com.google.inject.Inject
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Response
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ResponseFile
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.TypesBuilderExtensionProvider
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ResponseClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ExecutorClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ExplicitRoutine
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ImplicitRoutineClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ExplicitRoutineClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.RoutineFacadeClassGenerator

/**
 * <p>Infers a JVM model for the Xtend code blocks of the response file model.</p> 
 *
 * <p>The resulting classes are not to be persisted but only to be used for content assist purposes.</p>
 * 
 * @author Heiko Klare     
 */
class ResponseLanguageJvmModelInferrer extends AbstractModelInferrer  {

	@Inject extension JvmTypesBuilderWithoutAssociations _typesBuilder
	@Inject TypesBuilderExtensionProvider typesBuilderExtensionProvider;
	
	private def void updateBuilders() {
		typesBuilderExtensionProvider.setBuilders(_typesBuilder, _typeReferenceBuilder, _annotationTypesBuilder);
	}
	
	def dispatch void generate(Response response, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		
		val effectClass = new ImplicitRoutineClassGenerator(response.routine, typesBuilderExtensionProvider).generateClass();
		acceptor.accept(effectClass);
		val responseClassGenerator = new ResponseClassGenerator(response, typesBuilderExtensionProvider);
		acceptor.accept(responseClassGenerator.generateClass());
	}
	
	def dispatch void generate(ExplicitRoutine routine, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		
		acceptor.accept(new ExplicitRoutineClassGenerator(routine, typesBuilderExtensionProvider).generateClass());
	}
	
	def dispatch void infer(ResponseFile file, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		updateBuilders();
		
		for (responsesSegment : file.responsesSegments) {
			acceptor.accept(new RoutineFacadeClassGenerator(responsesSegment, typesBuilderExtensionProvider).generateClass());
			for (effect : responsesSegment.routines) {
				generate(effect, acceptor, isPreIndexingPhase);
			}
			for (response : responsesSegment.responses) {
				generate(response, acceptor, isPreIndexingPhase);
			}
			acceptor.accept(new ExecutorClassGenerator(responsesSegment, typesBuilderExtensionProvider).generateClass());			
		}

	}

}
