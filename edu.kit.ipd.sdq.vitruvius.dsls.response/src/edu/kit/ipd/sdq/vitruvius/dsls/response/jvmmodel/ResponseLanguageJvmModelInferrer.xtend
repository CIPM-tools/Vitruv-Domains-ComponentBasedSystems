/*
 * generated by Xtext 2.9.0
 */
package edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel

import com.google.inject.Inject
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Response
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ExplicitEffect
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ResponseFile
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.TypesBuilderExtensionProvider
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ImplicitEffectClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ResponseClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.MockClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.ExplicitEffectClassGenerator
import edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel.classgenerators.EffectsFacadeClassGenerator

/**
 * <p>Infers a JVM model for the Xtend code blocks of the response file model.</p> 
 *
 * <p>The resulting classes are not to be persisted but only to be used for content assist purposes.</p>
 * 
 * @author Heiko Klare     
 */
class ResponseLanguageJvmModelInferrer extends AbstractModelInferrer  {

	@Inject extension JvmTypesBuilderWithoutAssociations _typesBuilder
	@Inject TypesBuilderExtensionProvider typesBuilderExtensionProvider;
	
	private def void updateBuilders() {
		typesBuilderExtensionProvider.setBuilders(_typesBuilder, _typeReferenceBuilder, _annotationTypesBuilder);
	}
	
	// TODO HK The hasEffectsFacade thing is ugly.. change it
	def dispatch void infer(Response response, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase, boolean hasEffectsFacade) {
		if (isPreIndexingPhase) {
			return;
		}
		
		val effectClass = new ImplicitEffectClassGenerator(response.effect, typesBuilderExtensionProvider, hasEffectsFacade).generateClass();
		acceptor.accept(effectClass);
		val responseClassGenerator = new ResponseClassGenerator(response, typesBuilderExtensionProvider);
		val mockType = new MockClassGenerator(response.trigger, typesBuilderExtensionProvider).generateClass();
		if (mockType != null) {
			acceptor.accept(mockType);
		}
		acceptor.accept(responseClassGenerator.generateClass());
	}
	
	def dispatch void infer(ExplicitEffect effect, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase, boolean hasEffectsFacade) {
		if (isPreIndexingPhase) {
			return;
		}
		
		acceptor.accept(new ExplicitEffectClassGenerator(effect, typesBuilderExtensionProvider, hasEffectsFacade).generateClass());
	}
	
	def dispatch void infer(ResponseFile file, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		updateBuilders();
		
		val effectsFacade = new EffectsFacadeClassGenerator(file.effects, typesBuilderExtensionProvider).generateClass();
		
		acceptor.accept(effectsFacade);
		
		for (response : file.responses) {
			infer(response, acceptor, isPreIndexingPhase, effectsFacade != null);
		}
		
		for (effect : file.effects) {
			infer(effect, acceptor, isPreIndexingPhase, effectsFacade != null);
		}
	}

}
