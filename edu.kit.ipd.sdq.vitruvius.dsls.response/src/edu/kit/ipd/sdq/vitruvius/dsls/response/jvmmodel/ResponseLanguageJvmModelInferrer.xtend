/*
 * generated by Xtext 2.9.0
 */
package edu.kit.ipd.sdq.vitruvius.dsls.response.jvmmodel

import com.google.inject.Inject
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Response
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ExplicitEffect
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ResponseFile
import org.eclipse.xtext.common.types.JvmVisibility
import edu.kit.ipd.sdq.vitruvius.dsls.response.api.environment.AbstractResponseRealization
import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.generator.ResponseLanguageGeneratorUtils.*;
import edu.kit.ipd.sdq.vitruvius.dsls.response.api.environment.AbstractEffectRealization

/**
 * <p>Infers a JVM model for the Xtend code blocks of the response file model.</p> 
 *
 * <p>The resulting classes are not to be persisted but only to be used for content assist purposes.</p>
 * 
 * @author Heiko Klare     
 */
class ResponseLanguageJvmModelInferrer extends AbstractModelInferrer  {

	@Inject extension JvmTypesBuilderWithoutAssociations _typesBuilder
	
	def dispatch void infer(Response response, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		
		val effectClass = new ImplicitEffectClassGenerator(response.effect, _typesBuilder, _typeReferenceBuilder).generateClass()
		acceptor.accept(effectClass);
		val responseClassGenerator = new ResponseClassGenerator(response, effectClass, _typesBuilder, _typeReferenceBuilder)
		val mockType = responseClassGenerator.generateMockType();
		if (mockType != null) {
			acceptor.accept(mockType);
		}
		acceptor.accept(responseClassGenerator.generateClass());
	}
	
	def dispatch void infer(ExplicitEffect effect, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		
		acceptor.accept(new ExplicitEffectClassGenerator(effect, _typesBuilder, _typeReferenceBuilder).generateClass());
	}
	
	def dispatch void infer(ResponseFile file, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) {
			return;
		}
		
		val extension parameterGenerator = new ResponseLanguageParameterGenerator(_typeReferenceBuilder, _typesBuilder);
		val responseWithEffectsClass = file.toClass("responses.AbstractEffectWithEffects") [
			visibility = JvmVisibility.PUBLIC;
			superTypes += typeRef(AbstractEffectRealization);
			abstract = true;
			members += toConstructor() [
				val userInteractingParameter = generateUserInteractingParameter(); 
				val blackboardParameter = generateBlackboardParameter();
				val transformationResultParameter = generateTransformationResultParameter();
				parameters += userInteractingParameter;
				parameters += blackboardParameter;
				parameters += transformationResultParameter;
				body = '''super(«userInteractingParameter.name», «blackboardParameter.name», «transformationResultParameter.name»);'''
			]
			members += file.effects.map[effect | toMethod("call" + effect.name, typeRef(Void.TYPE)) [
				visibility = JvmVisibility.PROTECTED;
				parameters += generateMethodInputParameters(effect.modelInputElements, effect.javaInputElements);
				body = '''
					new «effect.qualifiedName»(this.userInteracting, this.blackboard, this.transformationResult).execute(«
						FOR parameter : parameters SEPARATOR ", "»«parameter.name»«ENDFOR»);'''			
			]]
		]
		acceptor.accept(responseWithEffectsClass);
		
		for (response : file.responses) {
			infer(response, acceptor, isPreIndexingPhase);
		}
		
		for (effect : file.effects) {
			infer(effect, acceptor, isPreIndexingPhase);
		}
	}

}
