/*
 * generated by Xtext 2.9.0
 */
package edu.kit.ipd.sdq.vitruvius.dsls.response.validation

import org.eclipse.xtext.validation.Check
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ResponseLanguagePackage
import java.util.HashMap
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Response
import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.helper.ResponseLanguageHelper.*;
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ResponsesSegment
import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.helper.ResponseClassNamesGenerator.*;
import edu.kit.ipd.sdq.vitruvius.dsls.mirbase.mirBase.ModelElement
import edu.kit.ipd.sdq.vitruvius.dsls.mirbase.mirBase.MirBasePackage
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.Routine
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ImplicitRoutine
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.ExplicitRoutine
import edu.kit.ipd.sdq.vitruvius.dsls.response.responseLanguage.RoutineInput

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ResponseLanguageValidator extends AbstractResponseLanguageValidator {

	@Check
	def checkResponseFile(ResponsesSegment responseSegment) {
		val alreadyCheckedResponses = new HashMap<String, Response>();
		for (response : responseSegment.responses) {
			val responseName = response.responseClassNameGenerator.simpleName;
			if (alreadyCheckedResponses.containsKey(responseName)) {
				val errorMessage = "Duplicate response name: " + responseName;
				error(errorMessage, response, ResponseLanguagePackage.Literals.RESPONSE__NAME);
				error(
					errorMessage,
					alreadyCheckedResponses.get(responseName),
					ResponseLanguagePackage.Literals.RESPONSE__NAME
				);
			}
			alreadyCheckedResponses.put(responseName, response);
		}
		val alreadyCheckedEffects = new HashMap<String, Routine>();
		for (implicitRoutine : responseSegment.responses.map[routine]) {
			alreadyCheckedEffects.put(implicitRoutine.routineClassNameGenerator.simpleName, implicitRoutine);
		}
		for (routine : responseSegment.routines) {
			val routineName = routine.routineClassNameGenerator.simpleName
			if (alreadyCheckedEffects.containsKey(routineName)) {
				val errorMessage = "Duplicate effect name: " + routineName;
				error(errorMessage, routine, ResponseLanguagePackage.Literals.EXPLICIT_ROUTINE__NAME);
				val duplicateNameEffect = alreadyCheckedEffects.get(routineName);
				if (duplicateNameEffect instanceof ImplicitRoutine) {
					error(errorMessage, duplicateNameEffect.containingResponse,
						ResponseLanguagePackage.Literals.RESPONSE__NAME);
				} else if (duplicateNameEffect instanceof ExplicitRoutine) {
					error(errorMessage, duplicateNameEffect, ResponseLanguagePackage.Literals.EXPLICIT_ROUTINE__NAME);
				}
			}
			alreadyCheckedEffects.put(routineName, routine);
		}
	}

	@Check
	def checkCorrespondingElementSpecification(ModelElement element) {
		if (!element.name.nullOrEmpty && element.name.startsWith("_")) {
			error("Element names must not start with an underscore.",
				MirBasePackage.Literals.MODEL_ELEMENT__NAME);
		}
	}

//	@Check
//	def checkEffects(Effect effect) {
//		if (effect.impact.codeBlock == null && !effect.impact..filter(CorrespondingModelElementCreate).nullOrEmpty) {
//			warning("Created elements must be initialized and inserted into the target model in the execute block.",
//				ResponseLanguagePackage.Literals.EFFECT__CODE_BLOCK);
//		}
//	}
	
	@Check
	def checkEffectInput(RoutineInput effectInput) {
		if (!effectInput.javaInputElements.empty) {
			warning("Using plain Java elements is discouraged. Try to use model elements and make list inputs to single valued input of other effect that is called for each element.",
				ResponseLanguagePackage.Literals.ROUTINE_INPUT__JAVA_INPUT_ELEMENTS);
		}
	}

}
