/*
 [The "BSD licence"]
 Copyright (c) 2007-2008 Terence Parr
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * This grammar is based on
 * - http://www.eclipse.org/forums/index.php/t/251746/
 * - XBase
 * It is intentionally weaker than the original grammars. You have to check
 * the java syntax with other tools than this grammar.
 */

grammar tools.vitruvius.domains.jml.language.JML with org.eclipse.xtext.xbase.Xtype

import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jML "http://www.kit.edu/ipd/sdq/vitruvius/domains/jml/language/JML"

CompilationUnit:
	{CompilationUnit}
	packagedeclaration=PackageDeclaration? importdeclaration+=ImportDeclaration* typedeclaration+=ClassifierDeclarationWithModifier*;

PackageDeclaration:
	'package' qualifiedname=QualifiedName ';';

ImportDeclaration:
	'import' static?='static'? qualifiedname=QualifiedName (=> '.' wildcard?='*')? ';';

ClassifierDeclarationWithModifier:
	 modifiers+=Modifier* classOrInterfaceDeclaration=ClassOrInterfaceDeclaration
;

ClassOrInterfaceDeclaration:
	ClassDeclaration | InterfaceDeclaration
;

Modifier:
	Annotation | RegularModifier
;

RegularModifier:
	modifier=ModifierValue
;
	
enum ModifierValue:
	PUBLIC = 'public' |
	PROTECTED = 'protected' |
	PRIVATE = 'private' |
	STATIC = 'static' |
	ABSTRACT = 'abstract' |
	FINAL = 'final' |
	NATIVE = 'native' |
	SYNCHRONIZED = 'synchronized' | 
	TRANSIENT = 'transient' |
	VOLATILE = 'volatile' |
	STRICTFP = 'strictfp'
;

enum VisibilityModifierValue:
	PUBLIC = 'public' |
	PROTECTED = 'protected' |
	PRIVATE = 'private' |
	STATIC = 'static'
;

ClassDeclaration:
	NormalClassDeclaration | EnumDeclaration;

NormalClassDeclaration:
	'class' identifier=ID typeparameters=TypeParameters?
	('extends' superType=Type)?
	('implements' implementedTypes+=Type (',' implementedTypes+=Type)*)?
	'{' bodyDeclarations+=ClassBodyDeclaration* '}';

TypeParameters:
	'<' typeparameter+=TypeParameter (',' typeparameter+=TypeParameter)* '>';

TypeParameter:
	{TypeParameter}
	identifier=ID ('extends' typebound=TypeBound)?;

TypeBound:
	type+=Type ('&' type+=Type)*;

EnumDeclaration:
	'enum' identifier=ID ('implements' implementedTypes+=Type (',' implementedTypes+=Type)*)?
	'{' enumconstants=EnumConstants? ','? bodyDeclarations=EnumBodyDeclarations? '}';

EnumConstants:
	enumconstant+=EnumConstant (',' enumconstant+=EnumConstant)*;

EnumConstant:
	{EnumConstant} (annotations=Annotations? identifier=ID arguments=Arguments? ('{' classbodydeclaration+=ClassBodyDeclaration* '}')?);

EnumBodyDeclarations:
	{EnumBodyDeclarations} ';' (classbodydeclaration+=ClassBodyDeclaration)*;

Arguments:
	{Arguments} '(' expressions+=Expression (',' expressions+=Expression) ')';

InterfaceDeclaration:
	NormalInterfaceDeclaration | AnnotationTypeDeclaration;

NormalInterfaceDeclaration:
	'interface' identifier=ID typeparameters=TypeParameters? ('extends' implementedTypes+=Type (',' implementedTypes+=Type)*)?
	'{' bodyDeclarations+=ClassBodyDeclaration* '}';

ClassBodyDeclaration:
	{ClassBodyDeclaration} ';' | StaticBlock | JMLSpecifiedElement;

StaticBlock:
	static?='static'? block=Block
;

JMLSpecifiedElement:
	JMLMultilineSpec | JMLSinglelineSpec
;

JMLMultilineSpec: // requires look ahead because of the modifiers
	JMLMultilineSpecCommentStart
	(
		(jmlTypeSpecifications+=JMLTypeExpressionWithModifier+ JMLMultilineSpecCommentEnd) |
		(
			jmlSpecifications+=JMLMethodSpecificationWithModifier*
			((modelElement=JMLSpecificationOnlyElementWithModifier JMLMultilineSpecCommentEnd) | (JMLMultilineSpecCommentEnd element=MemberDeclWithModifierRegular))
		)
	)
;

JMLSinglelineSpec:
	element=MemberDeclWithModifierRegular |
	(
		'//@' (
			jmlTypeSpecifications+=JMLTypeExpressionWithModifier |
			(jmlSpecifications+=JMLMethodSpecificationWithModifier ('//@' jmlSpecifications+=JMLMethodSpecificationWithModifier)* element=MemberDeclWithModifierRegular)
		)
	)
;

JMLExpressionHaving:
	JMLMethodExpression | JMLTypeExpression
;

VisiblityModifier:
	modifier=VisibilityModifierValue
;

JMLMethodSpecificationWithModifier:
	JMLMethodSpecificationWithModifierRegular | JMLMethodSpecificationWithModifierExtended
;

JMLMethodSpecificationWithModifierRegular:
	modifier+=VisiblityModifier* spec=JMLMethodSpecification
;

JMLMethodSpecificationWithModifierExtended:
	'also' modifier+=VisiblityModifier* spec=JMLMethodSpecification
;

JMLMethodSpecification:
	JMLMethodExpression | JMLMethodBehavior
;

JMLMethodBehavior:
	JMLExceptionalBehaviorBlock | JMLNormalBehaviorBlock | JMLBehaviorBlock
;

JMLExceptionalBehaviorBlock:
	'exceptional_behavior' specifications+=JMLMethodExpression+
;

JMLNormalBehaviorBlock:
	'normal_behavior' specifications+=JMLMethodExpression+
;

JMLBehaviorBlock:
	'behavior' specifications+=JMLMethodExpression+
;


JMLMethodExpression:
	(JMLEnsuresExpression | JMLRequiresExpression) ';'
;

JMLEnsuresExpression:
	'ensures' expr=Expression
;

JMLRequiresExpression:
	'requires' expr=Expression
;



JMLSpecificationOnlyElementWithModifier:
	modifier+=VisiblityModifier* element=JMLSpecificationOnlyElement
;

JMLSpecificationOnlyElement:
	JMLGhostElement | JMLModelElement
;

JMLModelElement:
	'model' instance?='instance'? element=MemberDeclWithModifierSpec
;

JMLGhostElement:
	'ghost' instance?='instance'? element=MemberDeclWithModifierSpec
;



JMLTypeExpressionWithModifier:
	modifier+=VisiblityModifier* spec=JMLTypeExpression
;

JMLTypeExpression:
	(JMLInvariantExpression | JMLConstraintExpression | JMLAxiomExpression) ';'
;

JMLInvariantExpression:
	'invariant' expr=Expression
;

JMLConstraintExpression:
	'constraint' expr=Expression
;

JMLAxiomExpression:
	'axiom' expr=Expression
;



//JMLMemberModifierContainer:
//	// the jml comments are required for regular elements, but forbidden for model elements...
//	'/*@'? modifiers+=JMLMemberModifier (',' + modifiers+=JMLMemberModifier)* '*/'?
//;

JMLMemberModifier:
	modifier=JMLSpecMemberModifier
;

enum JMLSpecMemberModifier:
	PURE = 'pure' |
	HELPER = 'helper' |
	PUBLIC = 'spec_public' |
	PROTECTED = 'spec_protected'
;

MemberDeclWithModifier:
	MemberDeclWithModifierRegular | MemberDeclWithModifierSpec
;

MemberDeclWithModifierRegular:
	modifiers+=Modifier* (JMLMultilineSpecCommentStart jmlModifiers+=JMLMemberModifier+ JMLMultilineSpecCommentEnd)? /*jmlModifiers=JMLMemberModifierContainer?*/ memberdecl=MemberDecl
;

MemberDeclWithModifierSpec:
	modifiers+=Modifier* jmlModifiers+=JMLMemberModifier* memberdecl=MemberDecl
;

MemberDecl:
	GenericMethodOrConstructorDecl | MemberDeclaration /*| VoidMethod */ | Constructor | InterfaceDeclaration | ClassDeclaration;

Constructor:
	identifier=ID '(' (parameters+=FormalParameterDecl (',' parameters+=FormalParameterDecl)*)? ')' ('throws' exceptions+=DeclaredException (',' exceptions+=DeclaredException)*)? (constructorbody=ConstructorBody | ';')
;

MemberDeclaration:
	// this enables void fields but I don't care :D
	(type=Type | 'void') (method=MethodDeclaration | field=FieldDeclaration);

GenericMethodOrConstructorDeclOld:
	TypeParameters (type=Type | 'void') identifier=ID '(' (parameters+=FormalParameterDecl (',' parameters+=FormalParameterDecl)*)? ')' /*brackets+=Brackets**/ ('throws' exceptions+=DeclaredException (',' exceptions+=DeclaredException)*)? (methodbody=MethodBody | ';') | constructor=Constructor;

GenericMethodOrConstructorDecl:
	typeParameters=TypeParameters ((type=Type method=MethodDeclaration | 'void' method=MethodDeclaration) | constructor=Constructor);

MethodDeclaration:
	identifier=ID '(' (parameters+=FormalParameterDecl (',' parameters+=FormalParameterDecl)*)? ')' /*brackets+=Brackets**/ ('throws' exceptions+=DeclaredException (',' exceptions+=DeclaredException)*)? (methodbody=MethodBody | ';');

FieldDeclaration:
	variabledeclarator+=VariableDeclarator (',' variabledeclarator+=VariableDeclarator)* ';';

DeclaredException:
	name=QualifiedName
;

VariableDeclarator:
	{VariableDeclarator} identifier=ID brackets+=Brackets* ('=' expression=Expression)?;

Type:
	ClassOrInterfaceTypeWithBrackets | PrimitiveTypeWithBrackets;

ClassOrInterfaceTypeWithBrackets:
	type+=ClassifierType ('.' type+=ClassifierType)* (brackets+=Brackets)*
;

PrimitiveTypeWithBrackets:
	primitivetype=PrimitiveType (brackets+=Brackets)*
;

Brackets:
	{Brackets} '[' ']'
;

ClassOrInterfaceType:
	{ClassOrInterfaceType} type+=ClassifierType ('.' type+=ClassifierType)*;
	
ClassifierType:
	identifier=ID typearguments=TypeArguments?
;

enum PrimitiveType:
	BOOLEAN = 'boolean' |
	CHAR = 'char' |
	BYTE = 'byte' |
	SHORT = 'short' |
	INT = 'int' |
	LONG = 'long' |
	FLOAT = 'float' |
	DOUBLE = 'double'
;

TypeArguments:
	'<' typeargument+=TypeArgument (',' typeargument+=TypeArgument)* '>';

TypeArgument:
	{TypeArgument} (type=Type | wildcard?='?' ((extends?='extends' | super?='super') type=Type)?);

FormalParameterDecl:
	// this is just to ease the access to parameters, invalid java syntax can be produced...
	// correct handling is given in FormalParameterDecls
	modifiers+=Modifier* type=Type varargs?='...'? identifier=ID /*brackets+=Brackets**/
;

MethodBody:
	Block;

ConstructorBody:
	{ConstructorBody} '{' /*=> explicitconstructorinvocation=ExplicitConstructorInvocation? => */
	blockstatement+=BlockStatement* '}';

	//ExplicitConstructorInvocation:   
//	(NonWildcardTypeArguments? ('this' | 'super') arguments=Arguments ';'
//    | primary=Primary '.' NonWildcardTypeArguments=NonWildcardTypeArguments? 'super' arguments=Arguments ';')
//;




Modifiable:
	ClassifierDeclarationWithModifier | MemberDeclWithModifier | AnnotationTypeElementDeclaration | FormalParameterDecl
;

Typed:
	AnnotationMethodOrConstantRest | MemberDeclaration | FormalParameterDecl
;



// ================================================================
// Annotations
// ================================================================

Annotations:
	annotation+=Annotation+;

Annotation:
	{Annotation} '@' annotationname=AnnotationName (=> '(' (elementvaluepairs=ElementValuePairs |
	elementvalue=ElementValue)? ')')?;

AnnotationName:
	ID (=> '.' ID)*;

ElementValuePairs:
	elementvaluepair+=ElementValuePair (=> ',' elementvaluepair+=ElementValuePair)*;

ElementValuePair:
	identifier=ID '=' elementvalue=ElementValue;

ElementValue:
	/*ConditionalExpression |*/ Annotation | ElementValueArrayInitializer;

ElementValueArrayInitializer:
	{ElementValueArrayInitializer} '{' (elementvalue+=ElementValue (=> ',' elementvalue+=ElementValue)*)? (=> ',')? '}';

AnnotationTypeDeclaration:
	'@' 'interface' identifier=ID '{' (=> annotationtypeelementdeclaration+=AnnotationTypeElementDeclaration)* '}';

AnnotationTypeElementDeclaration:
	modifiers+=Modifier* annotationtypeelementrest=AnnotationTypeElementRest;

AnnotationTypeElementRest:
	AnnotationMethodOrConstantRest ';' | NormalClassDeclaration ';'? |
	NormalInterfaceDeclaration ';'? | EnumDeclaration ';'? | AnnotationTypeDeclaration ';'?;

AnnotationMethodOrConstantRest:
	type=Type (method=AnnotationMethodRest | constant=AnnotationConstantRest);

AnnotationMethodRest:
	{AnnotationMethodRest} (identifier=ID '(' ')' (=> defaultvalue=DefaultValue)?);

AnnotationConstantRest:
	variabledeclarator+=VariableDeclarator (',' variabledeclarator+=VariableDeclarator)*;

DefaultValue:
	'default' elementvalue=ElementValue;



// ================================================================
// Blocks
// ================================================================
Block:
	{Block} '{' blockstatement+=BlockStatement* '}';

BlockStatement:
	ClassifierDeclarationWithModifier | Expression ';';



// ================================================================
// Dummy elements
//
// These rules only have an influence on the generated meta-model
// ================================================================

IdentifierHaving:
	MethodDeclaration | VariableDeclarator | EnumDeclaration
;


// ================================================================
// Expressions
//
// The following expressions are heavily based on the XBase grammar
// ================================================================

Expression returns Expression :
	Assignment;

Assignment returns Expression :
	// quick and dirty support variable declarations in old java style
	// makes grammar ambiguous
	{Assignment} (typeForVariableDeclaration=ValidID ('['']')*)? feature=FeatureCallID OpSingleAssign value=Assignment |	
	OrExpression (
		=>({BinaryOperation.leftOperand=current} feature=OpMultiAssign) rightOperand=Assignment
	)?;

OpSingleAssign:
	'='
;

OpMultiAssign:
	'+=' | '-=' | '*=' | '/=' | '%=' | 
	'<' '<' '=' | 
	'>' '>'? '>=';

OrExpression returns Expression:
	AndExpression (=>({BinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	EqualityExpression (=>({BinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
	'&&';

EqualityExpression returns Expression:
	RelationalExpression (=>({BinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=RelationalExpression)*;

OpEquality:
	'==' | '!=' | '===' | '!==';

RelationalExpression returns Expression:
	OtherOperatorExpression
	(=>({InstanceOfExpression.expression=current} 'instanceof') type=Type |
	 =>({BinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=OtherOperatorExpression)*;

OpCompare:
	'>=' | '<' '=' | '>' | '<' ;

OtherOperatorExpression returns Expression:
	AdditiveExpression (=>({BinaryOperation.leftOperand=current} feature=OpOther)
	rightOperand=AdditiveExpression)*;

OpOther:
	  '->' 
	| '..<'
	| '>' '..'
	| '..'
	| '=>' 
	| '>' (=>('>' '>') | '>') 
	| '<' (=>('<' '<') | '<' | '=>')
	| '<>'
	| '?:';

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({BinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=MultiplicativeExpression)*;

OpAdd:
	'+' | '-';

MultiplicativeExpression returns Expression:
	UnaryOperation (=>({BinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=UnaryOperation)*;

OpMulti:
	'*' | '**' | '/' | '%';

UnaryOperation returns Expression:
	{UnaryOperation} feature=OpUnary operand=UnaryOperation
	| PostfixOperation;

OpUnary:
	"!" | "-" | "+";
	
PostfixOperation returns Expression:
	MemberFeatureCall =>({PostfixOperation.operand=current} feature=OpPostfix)?
;

OpPostfix:
	"++" | "--"
;

MemberFeatureCall returns Expression:
	PrimaryExpression
	(=>({Assignment.assignable=current} ('.') feature=FeatureCallID OpSingleAssign) value=Assignment
	|=>({MemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|explicitStatic?="::")) 
		('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
		feature=IdOrSuper (
			=>explicitOperationCall?='(' 
				(
				    memberCallArguments+=ShortClosure
				  |	memberCallArguments+=Expression (',' memberCallArguments+=Expression)*
				)? 
			')')?
			memberCallArguments+=Closure?
		)*;

PrimaryExpression returns Expression:
	ConstructorCall |
	BlockExpression |
	SwitchExpression |
	SynchronizedExpression |
	FeatureCall |
	Literal |
	IfExpression |
	ForLoopExpression |
	BasicForLoopExpression |
	WhileExpression |
	DoWhileExpression |
	ThrowExpression |
	ReturnExpression |
	TryCatchFinallyExpression |
	ParenthesisExpression |
	JMLOldExpression |
	JMLFreshExpression |
	JMLResultExpression;
	
ParenthesisExpression:
	'(' (expr=ParenthesizedExpression | expr=JMLForAllExpression)	
;
	
JMLOldExpression returns Expression:
	{JMLOldExpression} '\\old' expr=ParenthesisExpression
;

JMLFreshExpression returns Expression:
	{JMLFreshExpression} '\\fresh' expr=ParenthesisExpression
;

JMLResultExpression returns Expression:
	{JMLResultExpression} '\\result'
;

JMLForAllExpression returns Expression:
	{JMLForAllExpression} '\\forall'
	(initExpressions+=VarDecl (',' initExpressions+=VarDecl)*)? ';' 
	expression=Expression? ';'
	(updateExpressions+=Expression (',' updateExpressions+=Expression)*)?
	 ')'
;

VarDecl returns Expression:
	(=>(type=Type name=ValidID) | name=ValidID) ('=' right=Expression)?
;

Literal returns Expression:
	CollectionLiteral |
	Closure |
	BooleanLiteral |
	NumberLiteral |
	NullLiteral |
	StringLiteral |
	CharLiteral
	//TypeLiteral
;

CollectionLiteral:
	SetLiteral | ListLiteral
;

SetLiteral:
	{SetLiteral} '#' '{' (elements+=Expression (',' elements+=Expression )*)? '}'
;

ListLiteral:
	{ListLiteral} '#' '[' (elements+=Expression (',' elements+=Expression )*)? ']'
;

Closure returns Expression:
	=>({Closure} 
	'[') 
		=>((declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|')? 
		expression=ExpressionInClosure 
	']';
	
ExpressionInClosure returns Expression: 
	{BlockExpression}
	(expressions+=ExpressionOrVarDeclaration ';'?)*
;

ShortClosure returns Expression:
	=>({Closure} (declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|') expression=Expression;

ParenthesizedExpression returns Expression:
	/*'(' this one is located in ParenthesisExpression */ Expression ')' ;//castedExpr+=Expression?;

IfExpression returns Expression:
	{IfExpression}
	'if' '(' if=Expression ')'
	then=Expression
	(=>'else' else=Expression)?;

SwitchExpression returns Expression:
	{SwitchExpression}
	'switch' (=>('(' declaredParam=JvmFormalParameter ':') switch=Expression ')'
		| =>(declaredParam=JvmFormalParameter ':')? switch=Expression) '{'
	(cases+=CasePart)*
	('default' ':' default=Expression )?
	'}';

CasePart:
	{CasePart}
	typeGuard=JvmTypeReference? ('case' case=Expression)? 
		(':' then=Expression | ',') ;

ForLoopExpression returns Expression:
	=>({ForLoopExpression}
	'for' '(' declaredParam=JvmFormalParameter ':') forExpression=Expression ')'
		eachExpression=Expression;

BasicForLoopExpression returns Expression:
	{BasicForLoopExpression}
	'for' '('(initExpressions+=ExpressionOrVarDeclaration (',' initExpressions+=ExpressionOrVarDeclaration)*)? ';' 
		expression=Expression? ';' 
		(updateExpressions+=Expression (',' updateExpressions+=Expression)*)? ')'
		eachExpression=Expression;

WhileExpression returns Expression:
	{WhileExpression}
	'while' '(' predicate=Expression ')'
		body=Expression;
	
DoWhileExpression returns Expression:
	{DoWhileExpression}
   'do'
       body=Expression
   'while' '(' predicate=Expression ')';

BlockExpression returns Expression: 
	// weakened grammar to make this expression usable as ArrayInitializer too
	{BlockExpression}
	'{'
		(expressions+=ExpressionOrVarDeclaration (',' expressions+=ExpressionOrVarDeclaration) ';'?)*
	'}';

ExpressionOrVarDeclaration returns Expression:
	/*VariableDeclaration |*/ Expression;

//VariableDeclaration returns Expression:
//	{VariableDeclaration}
//	/*(writeable?='var'|'val')*/ (=>(type=JvmTypeReference name=ValidID) | name=ValidID) ('=' right=Expression)?;

JvmFormalParameter returns ValidID:
	(parameterType=ValidID)? name=ValidID;
	
FullJvmFormalParameter returns ValidID:
	parameterType=ValidID name=ValidID;

FeatureCall returns Expression:
	{FeatureCall}
	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
	feature=IdOrSuper 
	(=>explicitOperationCall?='(' 
		(
		    featureCallArguments+=ShortClosure
		  |	featureCallArguments+=Expression (',' featureCallArguments+=Expression)*
		)? 
	')')?
	featureCallArguments+=Closure?;
	
FeatureCallID:
	ValidID /*| 'extends' | 'static' | 'import' | 'extension' */
;

IdOrSuper :
	FeatureCallID | 'super' | 'class'
;
	
ConstructorCall returns Expression:
	{ConstructorCall}
	'new' constructor=QualifiedName 
	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	(=>explicitConstructorCall?='(' 
		(
		    arguments+=ShortClosure
		  |	arguments+=Expression (',' arguments+=Expression)*
		)? 
	')')?
	arguments+=Closure?;

BooleanLiteral returns Expression :
	{BooleanLiteral} ('false' | isTrue?='true');

NullLiteral returns Expression :
	{NullLiteral} 'null';

NumberLiteral returns Expression :
	{NumberLiteral} value=Number;

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

CharLiteral returns Expression:
	{CharLiteral} value=CHAR
;

//TypeLiteral returns Expression :
//	{TypeLiteral} 'typeof' '(' (type=JvmTypeReference|typeRef=QualifiedName) (arrayDimensions+=ArrayBrackets)* ')'
//;

ThrowExpression returns Expression :
	{ThrowExpression} 'throw' expression=Expression;
	
ReturnExpression returns Expression :
	{ReturnExpression} 'return' (->expression=Expression)?;
	
TryCatchFinallyExpression returns Expression:
	{TryCatchFinallyExpression}
	'try' 
		expression=Expression
	(
		catchClauses+=CatchClause+
		(=>'finally' finallyExpression=Expression)?
	|	'finally' finallyExpression=Expression
	);
	
SynchronizedExpression returns Expression:
	=>({SynchronizedExpression}
	'synchronized' '(') param=Expression ')' expression=Expression;

CatchClause :
	=>'catch' '(' declaredParam=FullJvmFormalParameter ')' expression=Expression;


QualifiedName:
  ValidID (=>'.' ValidID)*;

Number hidden():
	HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;

/**
 * Dummy rule, for "better" downwards compatibility, since GrammarAccess generates non-static inner classes, 
 * which makes downstream grammars break on classloading, when a rule is removed.
 */
StaticQualifier:
	(ValidID '::')+
;

JMLMultilineSpecCommentStart:
	'/*@'
;

JMLMultilineSpecCommentEnd:
	'*/' | '@*/'
;

terminal HEX:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F'|'_')+ 
	('#' (('b'|'B')('i'|'I') | ('l'|'L')))?;
	
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9'|'_')*; 

terminal DECIMAL:
	INT 
	(('e'|'E') ('+'|'-')? INT)? 
	(('b'|'B')('i'|'I'|'d'|'D') | ('l'|'L'|'d'|'D'|'f'|'F'))?;
	
terminal ML_COMMENT:
	'/*' !'@' -> '*/';
	
terminal SL_COMMENT:
	'//' !'@' !('\n'|'\r')* ('\r'? '\n')?;
	
terminal STRING: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"';
			
terminal CHAR:
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") ) "'"
;