/*
 * generated by Xtext
 */
package tools.vitruvius.domains.jml.language.serializer;

import com.google.inject.Inject;
import tools.vitruvius.domains.jml.language.jML.Annotation;
import tools.vitruvius.domains.jml.language.jML.AnnotationConstantRest;
import tools.vitruvius.domains.jml.language.jML.AnnotationMethodOrConstantRest;
import tools.vitruvius.domains.jml.language.jML.AnnotationMethodRest;
import tools.vitruvius.domains.jml.language.jML.AnnotationTypeDeclaration;
import tools.vitruvius.domains.jml.language.jML.AnnotationTypeElementDeclaration;
import tools.vitruvius.domains.jml.language.jML.Annotations;
import tools.vitruvius.domains.jml.language.jML.Arguments;
import tools.vitruvius.domains.jml.language.jML.Assignment;
import tools.vitruvius.domains.jml.language.jML.BasicForLoopExpression;
import tools.vitruvius.domains.jml.language.jML.BinaryOperation;
import tools.vitruvius.domains.jml.language.jML.Block;
import tools.vitruvius.domains.jml.language.jML.BlockExpression;
import tools.vitruvius.domains.jml.language.jML.BooleanLiteral;
import tools.vitruvius.domains.jml.language.jML.Brackets;
import tools.vitruvius.domains.jml.language.jML.CasePart;
import tools.vitruvius.domains.jml.language.jML.CatchClause;
import tools.vitruvius.domains.jml.language.jML.CharLiteral;
import tools.vitruvius.domains.jml.language.jML.ClassBodyDeclaration;
import tools.vitruvius.domains.jml.language.jML.ClassOrInterfaceType;
import tools.vitruvius.domains.jml.language.jML.ClassOrInterfaceTypeWithBrackets;
import tools.vitruvius.domains.jml.language.jML.ClassifierDeclarationWithModifier;
import tools.vitruvius.domains.jml.language.jML.ClassifierType;
import tools.vitruvius.domains.jml.language.jML.Closure;
import tools.vitruvius.domains.jml.language.jML.CompilationUnit;
import tools.vitruvius.domains.jml.language.jML.Constructor;
import tools.vitruvius.domains.jml.language.jML.ConstructorBody;
import tools.vitruvius.domains.jml.language.jML.ConstructorCall;
import tools.vitruvius.domains.jml.language.jML.DeclaredException;
import tools.vitruvius.domains.jml.language.jML.DefaultValue;
import tools.vitruvius.domains.jml.language.jML.DoWhileExpression;
import tools.vitruvius.domains.jml.language.jML.ElementValueArrayInitializer;
import tools.vitruvius.domains.jml.language.jML.ElementValuePair;
import tools.vitruvius.domains.jml.language.jML.ElementValuePairs;
import tools.vitruvius.domains.jml.language.jML.EnumBodyDeclarations;
import tools.vitruvius.domains.jml.language.jML.EnumConstant;
import tools.vitruvius.domains.jml.language.jML.EnumConstants;
import tools.vitruvius.domains.jml.language.jML.EnumDeclaration;
import tools.vitruvius.domains.jml.language.jML.Expression;
import tools.vitruvius.domains.jml.language.jML.FeatureCall;
import tools.vitruvius.domains.jml.language.jML.FieldDeclaration;
import tools.vitruvius.domains.jml.language.jML.ForLoopExpression;
import tools.vitruvius.domains.jml.language.jML.FormalParameterDecl;
import tools.vitruvius.domains.jml.language.jML.GenericMethodOrConstructorDecl;
import tools.vitruvius.domains.jml.language.jML.GenericMethodOrConstructorDeclOld;
import tools.vitruvius.domains.jml.language.jML.IfExpression;
import tools.vitruvius.domains.jml.language.jML.ImportDeclaration;
import tools.vitruvius.domains.jml.language.jML.InstanceOfExpression;
import tools.vitruvius.domains.jml.language.jML.JMLAxiomExpression;
import tools.vitruvius.domains.jml.language.jML.JMLBehaviorBlock;
import tools.vitruvius.domains.jml.language.jML.JMLConstraintExpression;
import tools.vitruvius.domains.jml.language.jML.JMLEnsuresExpression;
import tools.vitruvius.domains.jml.language.jML.JMLExceptionalBehaviorBlock;
import tools.vitruvius.domains.jml.language.jML.JMLForAllExpression;
import tools.vitruvius.domains.jml.language.jML.JMLFreshExpression;
import tools.vitruvius.domains.jml.language.jML.JMLGhostElement;
import tools.vitruvius.domains.jml.language.jML.JMLInvariantExpression;
import tools.vitruvius.domains.jml.language.jML.JMLMemberModifier;
import tools.vitruvius.domains.jml.language.jML.JMLMethodSpecificationWithModifierExtended;
import tools.vitruvius.domains.jml.language.jML.JMLMethodSpecificationWithModifierRegular;
import tools.vitruvius.domains.jml.language.jML.JMLModelElement;
import tools.vitruvius.domains.jml.language.jML.JMLMultilineSpec;
import tools.vitruvius.domains.jml.language.jML.JMLNormalBehaviorBlock;
import tools.vitruvius.domains.jml.language.jML.JMLOldExpression;
import tools.vitruvius.domains.jml.language.jML.JMLPackage;
import tools.vitruvius.domains.jml.language.jML.JMLRequiresExpression;
import tools.vitruvius.domains.jml.language.jML.JMLResultExpression;
import tools.vitruvius.domains.jml.language.jML.JMLSinglelineSpec;
import tools.vitruvius.domains.jml.language.jML.JMLSpecificationOnlyElementWithModifier;
import tools.vitruvius.domains.jml.language.jML.JMLTypeExpressionWithModifier;
import tools.vitruvius.domains.jml.language.jML.ListLiteral;
import tools.vitruvius.domains.jml.language.jML.MemberDeclWithModifierRegular;
import tools.vitruvius.domains.jml.language.jML.MemberDeclWithModifierSpec;
import tools.vitruvius.domains.jml.language.jML.MemberDeclaration;
import tools.vitruvius.domains.jml.language.jML.MemberFeatureCall;
import tools.vitruvius.domains.jml.language.jML.MethodDeclaration;
import tools.vitruvius.domains.jml.language.jML.NormalClassDeclaration;
import tools.vitruvius.domains.jml.language.jML.NormalInterfaceDeclaration;
import tools.vitruvius.domains.jml.language.jML.NullLiteral;
import tools.vitruvius.domains.jml.language.jML.NumberLiteral;
import tools.vitruvius.domains.jml.language.jML.PackageDeclaration;
import tools.vitruvius.domains.jml.language.jML.ParenthesisExpression;
import tools.vitruvius.domains.jml.language.jML.PostfixOperation;
import tools.vitruvius.domains.jml.language.jML.PrimitiveTypeWithBrackets;
import tools.vitruvius.domains.jml.language.jML.RegularModifier;
import tools.vitruvius.domains.jml.language.jML.ReturnExpression;
import tools.vitruvius.domains.jml.language.jML.SetLiteral;
import tools.vitruvius.domains.jml.language.jML.StaticBlock;
import tools.vitruvius.domains.jml.language.jML.StringLiteral;
import tools.vitruvius.domains.jml.language.jML.SwitchExpression;
import tools.vitruvius.domains.jml.language.jML.SynchronizedExpression;
import tools.vitruvius.domains.jml.language.jML.ThrowExpression;
import tools.vitruvius.domains.jml.language.jML.TryCatchFinallyExpression;
import tools.vitruvius.domains.jml.language.jML.TypeArgument;
import tools.vitruvius.domains.jml.language.jML.TypeArguments;
import tools.vitruvius.domains.jml.language.jML.TypeBound;
import tools.vitruvius.domains.jml.language.jML.TypeParameter;
import tools.vitruvius.domains.jml.language.jML.TypeParameters;
import tools.vitruvius.domains.jml.language.jML.UnaryOperation;
import tools.vitruvius.domains.jml.language.jML.ValidID;
import tools.vitruvius.domains.jml.language.jML.VariableDeclarator;
import tools.vitruvius.domains.jml.language.jML.VisiblityModifier;
import tools.vitruvius.domains.jml.language.jML.WhileExpression;
import tools.vitruvius.domains.jml.language.services.JMLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.serializer.XtypeSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class JMLSemanticSequencer extends XtypeSemanticSequencer {

	@Inject
	private JMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JMLPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case JMLPackage.ANNOTATION_CONSTANT_REST:
				sequence_AnnotationConstantRest(context, (AnnotationConstantRest) semanticObject); 
				return; 
			case JMLPackage.ANNOTATION_METHOD_OR_CONSTANT_REST:
				sequence_AnnotationMethodOrConstantRest(context, (AnnotationMethodOrConstantRest) semanticObject); 
				return; 
			case JMLPackage.ANNOTATION_METHOD_REST:
				sequence_AnnotationMethodRest(context, (AnnotationMethodRest) semanticObject); 
				return; 
			case JMLPackage.ANNOTATION_TYPE_DECLARATION:
				sequence_AnnotationTypeDeclaration(context, (AnnotationTypeDeclaration) semanticObject); 
				return; 
			case JMLPackage.ANNOTATION_TYPE_ELEMENT_DECLARATION:
				sequence_AnnotationTypeElementDeclaration(context, (AnnotationTypeElementDeclaration) semanticObject); 
				return; 
			case JMLPackage.ANNOTATIONS:
				sequence_Annotations(context, (Annotations) semanticObject); 
				return; 
			case JMLPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case JMLPackage.ASSIGNMENT:
				if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getExpressionOrVarDeclarationRule()) {
					sequence_Assignment_MemberFeatureCall(context, (Assignment) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getAssignmentAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOtherOperatorExpressionRule()
						|| action == grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getUnaryOperationRule()
						|| rule == grammarAccess.getPostfixOperationRule()
						|| action == grammarAccess.getPostfixOperationAccess().getPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getMemberFeatureCallRule()
						|| action == grammarAccess.getMemberFeatureCallAccess().getAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getMemberFeatureCallAccess().getMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()) {
					sequence_MemberFeatureCall(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case JMLPackage.BASIC_FOR_LOOP_EXPRESSION:
				sequence_BasicForLoopExpression(context, (BasicForLoopExpression) semanticObject); 
				return; 
			case JMLPackage.BINARY_OPERATION:
				if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getExpressionOrVarDeclarationRule()) {
					sequence_AdditiveExpression_AndExpression_Assignment_EqualityExpression_MultiplicativeExpression_OrExpression_OtherOperatorExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getAssignmentAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_OtherOperatorExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OtherOperatorExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()) {
					sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_OtherOperatorExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherOperatorExpressionRule()
						|| action == grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression_OtherOperatorExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression_OtherOperatorExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()) {
					sequence_MultiplicativeExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else break;
			case JMLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case JMLPackage.BLOCK_EXPRESSION:
				if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOtherOperatorExpressionRule()
						|| action == grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getUnaryOperationRule()
						|| rule == grammarAccess.getPostfixOperationRule()
						|| action == grammarAccess.getPostfixOperationAccess().getPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getMemberFeatureCallRule()
						|| action == grammarAccess.getMemberFeatureCallAccess().getAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getMemberFeatureCallAccess().getMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getBlockExpressionRule()
						|| rule == grammarAccess.getExpressionOrVarDeclarationRule()) {
					sequence_BlockExpression(context, (BlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionInClosureRule()) {
					sequence_ExpressionInClosure(context, (BlockExpression) semanticObject); 
					return; 
				}
				else break;
			case JMLPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case JMLPackage.BRACKETS:
				sequence_Brackets(context, (Brackets) semanticObject); 
				return; 
			case JMLPackage.CASE_PART:
				sequence_CasePart(context, (CasePart) semanticObject); 
				return; 
			case JMLPackage.CATCH_CLAUSE:
				sequence_CatchClause(context, (CatchClause) semanticObject); 
				return; 
			case JMLPackage.CHAR_LITERAL:
				sequence_CharLiteral(context, (CharLiteral) semanticObject); 
				return; 
			case JMLPackage.CLASS_BODY_DECLARATION:
				sequence_ClassBodyDeclaration(context, (ClassBodyDeclaration) semanticObject); 
				return; 
			case JMLPackage.CLASS_OR_INTERFACE_TYPE:
				sequence_ClassOrInterfaceType(context, (ClassOrInterfaceType) semanticObject); 
				return; 
			case JMLPackage.CLASS_OR_INTERFACE_TYPE_WITH_BRACKETS:
				sequence_ClassOrInterfaceTypeWithBrackets(context, (ClassOrInterfaceTypeWithBrackets) semanticObject); 
				return; 
			case JMLPackage.CLASSIFIER_DECLARATION_WITH_MODIFIER:
				sequence_ClassifierDeclarationWithModifier(context, (ClassifierDeclarationWithModifier) semanticObject); 
				return; 
			case JMLPackage.CLASSIFIER_TYPE:
				sequence_ClassifierType(context, (ClassifierType) semanticObject); 
				return; 
			case JMLPackage.CLOSURE:
				if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getOtherOperatorExpressionRule()
						|| action == grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getUnaryOperationRule()
						|| rule == grammarAccess.getPostfixOperationRule()
						|| action == grammarAccess.getPostfixOperationAccess().getPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getMemberFeatureCallRule()
						|| action == grammarAccess.getMemberFeatureCallAccess().getAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getMemberFeatureCallAccess().getMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getClosureRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getExpressionOrVarDeclarationRule()) {
					sequence_Closure(context, (Closure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShortClosureRule()) {
					sequence_ShortClosure(context, (Closure) semanticObject); 
					return; 
				}
				else break;
			case JMLPackage.COMPILATION_UNIT:
				sequence_CompilationUnit(context, (CompilationUnit) semanticObject); 
				return; 
			case JMLPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case JMLPackage.CONSTRUCTOR_BODY:
				sequence_ConstructorBody(context, (ConstructorBody) semanticObject); 
				return; 
			case JMLPackage.CONSTRUCTOR_CALL:
				sequence_ConstructorCall(context, (ConstructorCall) semanticObject); 
				return; 
			case JMLPackage.DECLARED_EXCEPTION:
				sequence_DeclaredException(context, (DeclaredException) semanticObject); 
				return; 
			case JMLPackage.DEFAULT_VALUE:
				sequence_DefaultValue(context, (DefaultValue) semanticObject); 
				return; 
			case JMLPackage.DO_WHILE_EXPRESSION:
				sequence_DoWhileExpression(context, (DoWhileExpression) semanticObject); 
				return; 
			case JMLPackage.ELEMENT_VALUE_ARRAY_INITIALIZER:
				sequence_ElementValueArrayInitializer(context, (ElementValueArrayInitializer) semanticObject); 
				return; 
			case JMLPackage.ELEMENT_VALUE_PAIR:
				sequence_ElementValuePair(context, (ElementValuePair) semanticObject); 
				return; 
			case JMLPackage.ELEMENT_VALUE_PAIRS:
				sequence_ElementValuePairs(context, (ElementValuePairs) semanticObject); 
				return; 
			case JMLPackage.ENUM_BODY_DECLARATIONS:
				sequence_EnumBodyDeclarations(context, (EnumBodyDeclarations) semanticObject); 
				return; 
			case JMLPackage.ENUM_CONSTANT:
				sequence_EnumConstant(context, (EnumConstant) semanticObject); 
				return; 
			case JMLPackage.ENUM_CONSTANTS:
				sequence_EnumConstants(context, (EnumConstants) semanticObject); 
				return; 
			case JMLPackage.ENUM_DECLARATION:
				sequence_EnumDeclaration(context, (EnumDeclaration) semanticObject); 
				return; 
			case JMLPackage.EXPRESSION:
				sequence_VarDecl(context, (Expression) semanticObject); 
				return; 
			case JMLPackage.FEATURE_CALL:
				sequence_FeatureCall(context, (FeatureCall) semanticObject); 
				return; 
			case JMLPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case JMLPackage.FOR_LOOP_EXPRESSION:
				sequence_ForLoopExpression(context, (ForLoopExpression) semanticObject); 
				return; 
			case JMLPackage.FORMAL_PARAMETER_DECL:
				sequence_FormalParameterDecl(context, (FormalParameterDecl) semanticObject); 
				return; 
			case JMLPackage.GENERIC_METHOD_OR_CONSTRUCTOR_DECL:
				sequence_GenericMethodOrConstructorDecl(context, (GenericMethodOrConstructorDecl) semanticObject); 
				return; 
			case JMLPackage.GENERIC_METHOD_OR_CONSTRUCTOR_DECL_OLD:
				sequence_GenericMethodOrConstructorDeclOld(context, (GenericMethodOrConstructorDeclOld) semanticObject); 
				return; 
			case JMLPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case JMLPackage.IMPORT_DECLARATION:
				sequence_ImportDeclaration(context, (ImportDeclaration) semanticObject); 
				return; 
			case JMLPackage.INSTANCE_OF_EXPRESSION:
				sequence_RelationalExpression(context, (InstanceOfExpression) semanticObject); 
				return; 
			case JMLPackage.JML_AXIOM_EXPRESSION:
				sequence_JMLAxiomExpression(context, (JMLAxiomExpression) semanticObject); 
				return; 
			case JMLPackage.JML_BEHAVIOR_BLOCK:
				sequence_JMLBehaviorBlock(context, (JMLBehaviorBlock) semanticObject); 
				return; 
			case JMLPackage.JML_CONSTRAINT_EXPRESSION:
				sequence_JMLConstraintExpression(context, (JMLConstraintExpression) semanticObject); 
				return; 
			case JMLPackage.JML_ENSURES_EXPRESSION:
				sequence_JMLEnsuresExpression(context, (JMLEnsuresExpression) semanticObject); 
				return; 
			case JMLPackage.JML_EXCEPTIONAL_BEHAVIOR_BLOCK:
				sequence_JMLExceptionalBehaviorBlock(context, (JMLExceptionalBehaviorBlock) semanticObject); 
				return; 
			case JMLPackage.JML_FOR_ALL_EXPRESSION:
				sequence_JMLForAllExpression(context, (JMLForAllExpression) semanticObject); 
				return; 
			case JMLPackage.JML_FRESH_EXPRESSION:
				sequence_JMLFreshExpression(context, (JMLFreshExpression) semanticObject); 
				return; 
			case JMLPackage.JML_GHOST_ELEMENT:
				sequence_JMLGhostElement(context, (JMLGhostElement) semanticObject); 
				return; 
			case JMLPackage.JML_INVARIANT_EXPRESSION:
				sequence_JMLInvariantExpression(context, (JMLInvariantExpression) semanticObject); 
				return; 
			case JMLPackage.JML_MEMBER_MODIFIER:
				sequence_JMLMemberModifier(context, (JMLMemberModifier) semanticObject); 
				return; 
			case JMLPackage.JML_METHOD_SPECIFICATION_WITH_MODIFIER_EXTENDED:
				sequence_JMLMethodSpecificationWithModifierExtended(context, (JMLMethodSpecificationWithModifierExtended) semanticObject); 
				return; 
			case JMLPackage.JML_METHOD_SPECIFICATION_WITH_MODIFIER_REGULAR:
				sequence_JMLMethodSpecificationWithModifierRegular(context, (JMLMethodSpecificationWithModifierRegular) semanticObject); 
				return; 
			case JMLPackage.JML_MODEL_ELEMENT:
				sequence_JMLModelElement(context, (JMLModelElement) semanticObject); 
				return; 
			case JMLPackage.JML_MULTILINE_SPEC:
				sequence_JMLMultilineSpec(context, (JMLMultilineSpec) semanticObject); 
				return; 
			case JMLPackage.JML_NORMAL_BEHAVIOR_BLOCK:
				sequence_JMLNormalBehaviorBlock(context, (JMLNormalBehaviorBlock) semanticObject); 
				return; 
			case JMLPackage.JML_OLD_EXPRESSION:
				sequence_JMLOldExpression(context, (JMLOldExpression) semanticObject); 
				return; 
			case JMLPackage.JML_REQUIRES_EXPRESSION:
				sequence_JMLRequiresExpression(context, (JMLRequiresExpression) semanticObject); 
				return; 
			case JMLPackage.JML_RESULT_EXPRESSION:
				sequence_JMLResultExpression(context, (JMLResultExpression) semanticObject); 
				return; 
			case JMLPackage.JML_SINGLELINE_SPEC:
				sequence_JMLSinglelineSpec(context, (JMLSinglelineSpec) semanticObject); 
				return; 
			case JMLPackage.JML_SPECIFICATION_ONLY_ELEMENT_WITH_MODIFIER:
				sequence_JMLSpecificationOnlyElementWithModifier(context, (JMLSpecificationOnlyElementWithModifier) semanticObject); 
				return; 
			case JMLPackage.JML_TYPE_EXPRESSION_WITH_MODIFIER:
				sequence_JMLTypeExpressionWithModifier(context, (JMLTypeExpressionWithModifier) semanticObject); 
				return; 
			case JMLPackage.LIST_LITERAL:
				sequence_ListLiteral(context, (ListLiteral) semanticObject); 
				return; 
			case JMLPackage.MEMBER_DECL_WITH_MODIFIER_REGULAR:
				sequence_MemberDeclWithModifierRegular(context, (MemberDeclWithModifierRegular) semanticObject); 
				return; 
			case JMLPackage.MEMBER_DECL_WITH_MODIFIER_SPEC:
				sequence_MemberDeclWithModifierSpec(context, (MemberDeclWithModifierSpec) semanticObject); 
				return; 
			case JMLPackage.MEMBER_DECLARATION:
				sequence_MemberDeclaration(context, (MemberDeclaration) semanticObject); 
				return; 
			case JMLPackage.MEMBER_FEATURE_CALL:
				sequence_MemberFeatureCall(context, (MemberFeatureCall) semanticObject); 
				return; 
			case JMLPackage.METHOD_DECLARATION:
				sequence_MethodDeclaration(context, (MethodDeclaration) semanticObject); 
				return; 
			case JMLPackage.NORMAL_CLASS_DECLARATION:
				sequence_NormalClassDeclaration(context, (NormalClassDeclaration) semanticObject); 
				return; 
			case JMLPackage.NORMAL_INTERFACE_DECLARATION:
				sequence_NormalInterfaceDeclaration(context, (NormalInterfaceDeclaration) semanticObject); 
				return; 
			case JMLPackage.NULL_LITERAL:
				sequence_NullLiteral(context, (NullLiteral) semanticObject); 
				return; 
			case JMLPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case JMLPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case JMLPackage.PARENTHESIS_EXPRESSION:
				sequence_ParenthesisExpression(context, (ParenthesisExpression) semanticObject); 
				return; 
			case JMLPackage.POSTFIX_OPERATION:
				sequence_PostfixOperation(context, (PostfixOperation) semanticObject); 
				return; 
			case JMLPackage.PRIMITIVE_TYPE_WITH_BRACKETS:
				sequence_PrimitiveTypeWithBrackets(context, (PrimitiveTypeWithBrackets) semanticObject); 
				return; 
			case JMLPackage.REGULAR_MODIFIER:
				sequence_RegularModifier(context, (RegularModifier) semanticObject); 
				return; 
			case JMLPackage.RETURN_EXPRESSION:
				sequence_ReturnExpression(context, (ReturnExpression) semanticObject); 
				return; 
			case JMLPackage.SET_LITERAL:
				sequence_SetLiteral(context, (SetLiteral) semanticObject); 
				return; 
			case JMLPackage.STATIC_BLOCK:
				sequence_StaticBlock(context, (StaticBlock) semanticObject); 
				return; 
			case JMLPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case JMLPackage.SWITCH_EXPRESSION:
				sequence_SwitchExpression(context, (SwitchExpression) semanticObject); 
				return; 
			case JMLPackage.SYNCHRONIZED_EXPRESSION:
				sequence_SynchronizedExpression(context, (SynchronizedExpression) semanticObject); 
				return; 
			case JMLPackage.THROW_EXPRESSION:
				sequence_ThrowExpression(context, (ThrowExpression) semanticObject); 
				return; 
			case JMLPackage.TRY_CATCH_FINALLY_EXPRESSION:
				sequence_TryCatchFinallyExpression(context, (TryCatchFinallyExpression) semanticObject); 
				return; 
			case JMLPackage.TYPE_ARGUMENT:
				sequence_TypeArgument(context, (TypeArgument) semanticObject); 
				return; 
			case JMLPackage.TYPE_ARGUMENTS:
				sequence_TypeArguments(context, (TypeArguments) semanticObject); 
				return; 
			case JMLPackage.TYPE_BOUND:
				sequence_TypeBound(context, (TypeBound) semanticObject); 
				return; 
			case JMLPackage.TYPE_PARAMETER:
				sequence_TypeParameter(context, (TypeParameter) semanticObject); 
				return; 
			case JMLPackage.TYPE_PARAMETERS:
				if (rule == grammarAccess.getGenericMethodOrConstructorDeclOldRule()) {
					sequence_GenericMethodOrConstructorDeclOld_TypeParameters(context, (TypeParameters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeParametersRule()) {
					sequence_TypeParameters(context, (TypeParameters) semanticObject); 
					return; 
				}
				else break;
			case JMLPackage.UNARY_OPERATION:
				sequence_UnaryOperation(context, (UnaryOperation) semanticObject); 
				return; 
			case JMLPackage.VALID_ID:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (ValidID) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (ValidID) semanticObject); 
					return; 
				}
				else break;
			case JMLPackage.VARIABLE_DECLARATOR:
				sequence_VariableDeclarator(context, (VariableDeclarator) semanticObject); 
				return; 
			case JMLPackage.VISIBLITY_MODIFIER:
				sequence_VisiblityModifier(context, (VisiblityModifier) semanticObject); 
				return; 
			case JMLPackage.WHILE_EXPRESSION:
				sequence_WhileExpression(context, (WhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BlockStatement returns BinaryOperation
	 *     Expression returns BinaryOperation
	 *     Assignment returns BinaryOperation
	 *     ParenthesizedExpression returns BinaryOperation
	 *     ExpressionOrVarDeclaration returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=Assignment_BinaryOperation_1_1_0_0_0 feature=OpMultiAssign rightOperand=Assignment) | 
	 *         (leftOperand=OrExpression_BinaryOperation_1_0_0_0 feature=OpOr rightOperand=AndExpression) | 
	 *         (leftOperand=AndExpression_BinaryOperation_1_0_0_0 feature=OpAnd rightOperand=EqualityExpression) | 
	 *         (leftOperand=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality rightOperand=RelationalExpression) | 
	 *         (leftOperand=RelationalExpression_BinaryOperation_1_1_0_0_0 feature=OpCompare rightOperand=OtherOperatorExpression) | 
	 *         (leftOperand=OtherOperatorExpression_BinaryOperation_1_0_0_0 feature=OpOther rightOperand=AdditiveExpression) | 
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_Assignment_EqualityExpression_MultiplicativeExpression_OrExpression_OtherOperatorExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns BinaryOperation
	 *     OrExpression returns BinaryOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=OrExpression_BinaryOperation_1_0_0_0 feature=OpOr rightOperand=AndExpression) | 
	 *         (leftOperand=AndExpression_BinaryOperation_1_0_0_0 feature=OpAnd rightOperand=EqualityExpression) | 
	 *         (leftOperand=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality rightOperand=RelationalExpression) | 
	 *         (leftOperand=RelationalExpression_BinaryOperation_1_1_0_0_0 feature=OpCompare rightOperand=OtherOperatorExpression) | 
	 *         (leftOperand=OtherOperatorExpression_BinaryOperation_1_0_0_0 feature=OpOther rightOperand=AdditiveExpression) | 
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_OtherOperatorExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns BinaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=AndExpression_BinaryOperation_1_0_0_0 feature=OpAnd rightOperand=EqualityExpression) | 
	 *         (leftOperand=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality rightOperand=RelationalExpression) | 
	 *         (leftOperand=RelationalExpression_BinaryOperation_1_1_0_0_0 feature=OpCompare rightOperand=OtherOperatorExpression) | 
	 *         (leftOperand=OtherOperatorExpression_BinaryOperation_1_0_0_0 feature=OpOther rightOperand=AdditiveExpression) | 
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OtherOperatorExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression returns BinaryOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality rightOperand=RelationalExpression) | 
	 *         (leftOperand=RelationalExpression_BinaryOperation_1_1_0_0_0 feature=OpCompare rightOperand=OtherOperatorExpression) | 
	 *         (leftOperand=OtherOperatorExpression_BinaryOperation_1_0_0_0 feature=OpOther rightOperand=AdditiveExpression) | 
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_OtherOperatorExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns BinaryOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OtherOperatorExpression returns BinaryOperation
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=OtherOperatorExpression_BinaryOperation_1_0_0_0 feature=OpOther rightOperand=AdditiveExpression) | 
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_OtherOperatorExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns BinaryOperation
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns BinaryOperation
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=RelationalExpression_BinaryOperation_1_1_0_0_0 feature=OpCompare rightOperand=OtherOperatorExpression) | 
	 *         (leftOperand=OtherOperatorExpression_BinaryOperation_1_0_0_0 feature=OpOther rightOperand=AdditiveExpression) | 
	 *         (leftOperand=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd rightOperand=MultiplicativeExpression) | 
	 *         (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_OtherOperatorExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationConstantRest returns AnnotationConstantRest
	 *
	 * Constraint:
	 *     (variabledeclarator+=VariableDeclarator variabledeclarator+=VariableDeclarator*)
	 */
	protected void sequence_AnnotationConstantRest(ISerializationContext context, AnnotationConstantRest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Typed returns AnnotationMethodOrConstantRest
	 *     AnnotationTypeElementRest returns AnnotationMethodOrConstantRest
	 *     AnnotationMethodOrConstantRest returns AnnotationMethodOrConstantRest
	 *
	 * Constraint:
	 *     (type=Type (method=AnnotationMethodRest | constant=AnnotationConstantRest))
	 */
	protected void sequence_AnnotationMethodOrConstantRest(ISerializationContext context, AnnotationMethodOrConstantRest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationMethodRest returns AnnotationMethodRest
	 *
	 * Constraint:
	 *     (identifier=ID defaultvalue=DefaultValue?)
	 */
	protected void sequence_AnnotationMethodRest(ISerializationContext context, AnnotationMethodRest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrInterfaceDeclaration returns AnnotationTypeDeclaration
	 *     InterfaceDeclaration returns AnnotationTypeDeclaration
	 *     MemberDecl returns AnnotationTypeDeclaration
	 *     AnnotationTypeDeclaration returns AnnotationTypeDeclaration
	 *     AnnotationTypeElementRest returns AnnotationTypeDeclaration
	 *
	 * Constraint:
	 *     (identifier=ID annotationtypeelementdeclaration+=AnnotationTypeElementDeclaration*)
	 */
	protected void sequence_AnnotationTypeDeclaration(ISerializationContext context, AnnotationTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifiable returns AnnotationTypeElementDeclaration
	 *     AnnotationTypeElementDeclaration returns AnnotationTypeElementDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=Modifier* annotationtypeelementrest=AnnotationTypeElementRest)
	 */
	protected void sequence_AnnotationTypeElementDeclaration(ISerializationContext context, AnnotationTypeElementDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifier returns Annotation
	 *     Annotation returns Annotation
	 *     ElementValue returns Annotation
	 *
	 * Constraint:
	 *     (annotationname=AnnotationName (elementvaluepairs=ElementValuePairs | elementvalue=ElementValue)?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotations returns Annotations
	 *
	 * Constraint:
	 *     annotation+=Annotation+
	 */
	protected void sequence_Annotations(ISerializationContext context, Annotations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression)
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns Assignment
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *     ParenthesizedExpression returns Assignment
	 *     ExpressionOrVarDeclaration returns Assignment
	 *
	 * Constraint:
	 *     (
	 *         (typeForVariableDeclaration=ValidID? feature=FeatureCallID value=Assignment) | 
	 *         (assignable=MemberFeatureCall_Assignment_1_0_0_0_0 feature=FeatureCallID value=Assignment)
	 *     )
	 */
	protected void sequence_Assignment_MemberFeatureCall(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns BasicForLoopExpression
	 *     Expression returns BasicForLoopExpression
	 *     Assignment returns BasicForLoopExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns BasicForLoopExpression
	 *     OrExpression returns BasicForLoopExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BasicForLoopExpression
	 *     AndExpression returns BasicForLoopExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BasicForLoopExpression
	 *     EqualityExpression returns BasicForLoopExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BasicForLoopExpression
	 *     RelationalExpression returns BasicForLoopExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns BasicForLoopExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns BasicForLoopExpression
	 *     OtherOperatorExpression returns BasicForLoopExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns BasicForLoopExpression
	 *     AdditiveExpression returns BasicForLoopExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BasicForLoopExpression
	 *     MultiplicativeExpression returns BasicForLoopExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BasicForLoopExpression
	 *     UnaryOperation returns BasicForLoopExpression
	 *     PostfixOperation returns BasicForLoopExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns BasicForLoopExpression
	 *     MemberFeatureCall returns BasicForLoopExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns BasicForLoopExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns BasicForLoopExpression
	 *     PrimaryExpression returns BasicForLoopExpression
	 *     ParenthesizedExpression returns BasicForLoopExpression
	 *     BasicForLoopExpression returns BasicForLoopExpression
	 *     ExpressionOrVarDeclaration returns BasicForLoopExpression
	 *
	 * Constraint:
	 *     (
	 *         (initExpressions+=ExpressionOrVarDeclaration initExpressions+=ExpressionOrVarDeclaration*)? 
	 *         expression=Expression? 
	 *         (updateExpressions+=Expression updateExpressions+=Expression*)? 
	 *         eachExpression=Expression
	 *     )
	 */
	protected void sequence_BasicForLoopExpression(ISerializationContext context, BasicForLoopExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns BlockExpression
	 *     Expression returns BlockExpression
	 *     Assignment returns BlockExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns BlockExpression
	 *     OrExpression returns BlockExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BlockExpression
	 *     AndExpression returns BlockExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BlockExpression
	 *     EqualityExpression returns BlockExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BlockExpression
	 *     RelationalExpression returns BlockExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns BlockExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns BlockExpression
	 *     OtherOperatorExpression returns BlockExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns BlockExpression
	 *     AdditiveExpression returns BlockExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BlockExpression
	 *     MultiplicativeExpression returns BlockExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BlockExpression
	 *     UnaryOperation returns BlockExpression
	 *     PostfixOperation returns BlockExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns BlockExpression
	 *     MemberFeatureCall returns BlockExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns BlockExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns BlockExpression
	 *     PrimaryExpression returns BlockExpression
	 *     ParenthesizedExpression returns BlockExpression
	 *     BlockExpression returns BlockExpression
	 *     ExpressionOrVarDeclaration returns BlockExpression
	 *
	 * Constraint:
	 *     (expressions+=ExpressionOrVarDeclaration expressions+=ExpressionOrVarDeclaration)*
	 */
	protected void sequence_BlockExpression(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodBody returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     blockstatement+=BlockStatement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     Assignment returns BooleanLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     EqualityExpression returns BooleanLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     RelationalExpression returns BooleanLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns BooleanLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns BooleanLiteral
	 *     OtherOperatorExpression returns BooleanLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     AdditiveExpression returns BooleanLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     UnaryOperation returns BooleanLiteral
	 *     PostfixOperation returns BooleanLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns BooleanLiteral
	 *     MemberFeatureCall returns BooleanLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns BooleanLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     ParenthesizedExpression returns BooleanLiteral
	 *     ExpressionOrVarDeclaration returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     isTrue?='true'?
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Brackets returns Brackets
	 *
	 * Constraint:
	 *     {Brackets}
	 */
	protected void sequence_Brackets(ISerializationContext context, Brackets semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CasePart returns CasePart
	 *
	 * Constraint:
	 *     (typeGuard=JvmTypeReference? case=Expression? then=Expression?)
	 */
	protected void sequence_CasePart(ISerializationContext context, CasePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CatchClause returns CatchClause
	 *
	 * Constraint:
	 *     (declaredParam=FullJvmFormalParameter expression=Expression)
	 */
	protected void sequence_CatchClause(ISerializationContext context, CatchClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.CATCH_CLAUSE__DECLARED_PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.CATCH_CLAUSE__DECLARED_PARAM));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.CATCH_CLAUSE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.CATCH_CLAUSE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCatchClauseAccess().getDeclaredParamFullJvmFormalParameterParserRuleCall_2_0(), semanticObject.getDeclaredParam());
		feeder.accept(grammarAccess.getCatchClauseAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns CharLiteral
	 *     Expression returns CharLiteral
	 *     Assignment returns CharLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns CharLiteral
	 *     OrExpression returns CharLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns CharLiteral
	 *     AndExpression returns CharLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns CharLiteral
	 *     EqualityExpression returns CharLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns CharLiteral
	 *     RelationalExpression returns CharLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns CharLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns CharLiteral
	 *     OtherOperatorExpression returns CharLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns CharLiteral
	 *     AdditiveExpression returns CharLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns CharLiteral
	 *     MultiplicativeExpression returns CharLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns CharLiteral
	 *     UnaryOperation returns CharLiteral
	 *     PostfixOperation returns CharLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns CharLiteral
	 *     MemberFeatureCall returns CharLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns CharLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns CharLiteral
	 *     PrimaryExpression returns CharLiteral
	 *     Literal returns CharLiteral
	 *     ParenthesizedExpression returns CharLiteral
	 *     ExpressionOrVarDeclaration returns CharLiteral
	 *     CharLiteral returns CharLiteral
	 *
	 * Constraint:
	 *     value=CHAR
	 */
	protected void sequence_CharLiteral(ISerializationContext context, CharLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.CHAR_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.CHAR_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharLiteralAccess().getValueCHARTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns ClassBodyDeclaration
	 *
	 * Constraint:
	 *     {ClassBodyDeclaration}
	 */
	protected void sequence_ClassBodyDeclaration(ISerializationContext context, ClassBodyDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ClassOrInterfaceTypeWithBrackets
	 *     ClassOrInterfaceTypeWithBrackets returns ClassOrInterfaceTypeWithBrackets
	 *
	 * Constraint:
	 *     (type+=ClassifierType type+=ClassifierType* brackets+=Brackets*)
	 */
	protected void sequence_ClassOrInterfaceTypeWithBrackets(ISerializationContext context, ClassOrInterfaceTypeWithBrackets semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrInterfaceType returns ClassOrInterfaceType
	 *
	 * Constraint:
	 *     (type+=ClassifierType type+=ClassifierType*)
	 */
	protected void sequence_ClassOrInterfaceType(ISerializationContext context, ClassOrInterfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierDeclarationWithModifier returns ClassifierDeclarationWithModifier
	 *     Modifiable returns ClassifierDeclarationWithModifier
	 *     BlockStatement returns ClassifierDeclarationWithModifier
	 *
	 * Constraint:
	 *     (modifiers+=Modifier* classOrInterfaceDeclaration=ClassOrInterfaceDeclaration)
	 */
	protected void sequence_ClassifierDeclarationWithModifier(ISerializationContext context, ClassifierDeclarationWithModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierType returns ClassifierType
	 *
	 * Constraint:
	 *     (identifier=ID typearguments=TypeArguments?)
	 */
	protected void sequence_ClassifierType(ISerializationContext context, ClassifierType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns Closure
	 *     Expression returns Closure
	 *     Assignment returns Closure
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns Closure
	 *     OrExpression returns Closure
	 *     OrExpression.BinaryOperation_1_0_0_0 returns Closure
	 *     AndExpression returns Closure
	 *     AndExpression.BinaryOperation_1_0_0_0 returns Closure
	 *     EqualityExpression returns Closure
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns Closure
	 *     RelationalExpression returns Closure
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns Closure
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns Closure
	 *     OtherOperatorExpression returns Closure
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns Closure
	 *     AdditiveExpression returns Closure
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns Closure
	 *     MultiplicativeExpression returns Closure
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns Closure
	 *     UnaryOperation returns Closure
	 *     PostfixOperation returns Closure
	 *     PostfixOperation.PostfixOperation_1_0_0 returns Closure
	 *     MemberFeatureCall returns Closure
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns Closure
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns Closure
	 *     PrimaryExpression returns Closure
	 *     Literal returns Closure
	 *     Closure returns Closure
	 *     ParenthesizedExpression returns Closure
	 *     ExpressionOrVarDeclaration returns Closure
	 *
	 * Constraint:
	 *     (
	 *         ((declaredFormalParameters+=JvmFormalParameter declaredFormalParameters+=JvmFormalParameter*)? explicitSyntax?='|')? 
	 *         expression=ExpressionInClosure
	 *     )
	 */
	protected void sequence_Closure(ISerializationContext context, Closure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompilationUnit returns CompilationUnit
	 *
	 * Constraint:
	 *     (packagedeclaration=PackageDeclaration? importdeclaration+=ImportDeclaration* typedeclaration+=ClassifierDeclarationWithModifier*)
	 */
	protected void sequence_CompilationUnit(ISerializationContext context, CompilationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorBody returns ConstructorBody
	 *
	 * Constraint:
	 *     blockstatement+=BlockStatement*
	 */
	protected void sequence_ConstructorBody(ISerializationContext context, ConstructorBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ConstructorCall
	 *     Expression returns ConstructorCall
	 *     Assignment returns ConstructorCall
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns ConstructorCall
	 *     OrExpression returns ConstructorCall
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ConstructorCall
	 *     AndExpression returns ConstructorCall
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ConstructorCall
	 *     EqualityExpression returns ConstructorCall
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ConstructorCall
	 *     RelationalExpression returns ConstructorCall
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ConstructorCall
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns ConstructorCall
	 *     OtherOperatorExpression returns ConstructorCall
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns ConstructorCall
	 *     AdditiveExpression returns ConstructorCall
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ConstructorCall
	 *     MultiplicativeExpression returns ConstructorCall
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ConstructorCall
	 *     UnaryOperation returns ConstructorCall
	 *     PostfixOperation returns ConstructorCall
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ConstructorCall
	 *     MemberFeatureCall returns ConstructorCall
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns ConstructorCall
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns ConstructorCall
	 *     PrimaryExpression returns ConstructorCall
	 *     ParenthesizedExpression returns ConstructorCall
	 *     ExpressionOrVarDeclaration returns ConstructorCall
	 *     ConstructorCall returns ConstructorCall
	 *
	 * Constraint:
	 *     (
	 *         constructor=QualifiedName 
	 *         (typeArguments+=JvmArgumentTypeReference typeArguments+=JvmArgumentTypeReference*)? 
	 *         (explicitConstructorCall?='(' (arguments+=ShortClosure | (arguments+=Expression arguments+=Expression*))?)? 
	 *         arguments+=Closure?
	 *     )
	 */
	protected void sequence_ConstructorCall(ISerializationContext context, ConstructorCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberDecl returns Constructor
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (
	 *         identifier=ID 
	 *         (parameters+=FormalParameterDecl parameters+=FormalParameterDecl*)? 
	 *         (exceptions+=DeclaredException exceptions+=DeclaredException*)? 
	 *         constructorbody=ConstructorBody?
	 *     )
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredException returns DeclaredException
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_DeclaredException(ISerializationContext context, DeclaredException semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.DECLARED_EXCEPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.DECLARED_EXCEPTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredExceptionAccess().getNameQualifiedNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefaultValue returns DefaultValue
	 *
	 * Constraint:
	 *     elementvalue=ElementValue
	 */
	protected void sequence_DefaultValue(ISerializationContext context, DefaultValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.DEFAULT_VALUE__ELEMENTVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.DEFAULT_VALUE__ELEMENTVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultValueAccess().getElementvalueElementValueParserRuleCall_1_0(), semanticObject.getElementvalue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns DoWhileExpression
	 *     Expression returns DoWhileExpression
	 *     Assignment returns DoWhileExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns DoWhileExpression
	 *     OrExpression returns DoWhileExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns DoWhileExpression
	 *     AndExpression returns DoWhileExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns DoWhileExpression
	 *     EqualityExpression returns DoWhileExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns DoWhileExpression
	 *     RelationalExpression returns DoWhileExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns DoWhileExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns DoWhileExpression
	 *     OtherOperatorExpression returns DoWhileExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns DoWhileExpression
	 *     AdditiveExpression returns DoWhileExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns DoWhileExpression
	 *     MultiplicativeExpression returns DoWhileExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns DoWhileExpression
	 *     UnaryOperation returns DoWhileExpression
	 *     PostfixOperation returns DoWhileExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns DoWhileExpression
	 *     MemberFeatureCall returns DoWhileExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns DoWhileExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns DoWhileExpression
	 *     PrimaryExpression returns DoWhileExpression
	 *     ParenthesizedExpression returns DoWhileExpression
	 *     DoWhileExpression returns DoWhileExpression
	 *     ExpressionOrVarDeclaration returns DoWhileExpression
	 *
	 * Constraint:
	 *     (body=Expression predicate=Expression)
	 */
	protected void sequence_DoWhileExpression(ISerializationContext context, DoWhileExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.DO_WHILE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.DO_WHILE_EXPRESSION__BODY));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.DO_WHILE_EXPRESSION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.DO_WHILE_EXPRESSION__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoWhileExpressionAccess().getBodyExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getDoWhileExpressionAccess().getPredicateExpressionParserRuleCall_5_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementValue returns ElementValueArrayInitializer
	 *     ElementValueArrayInitializer returns ElementValueArrayInitializer
	 *
	 * Constraint:
	 *     (elementvalue+=ElementValue elementvalue+=ElementValue*)?
	 */
	protected void sequence_ElementValueArrayInitializer(ISerializationContext context, ElementValueArrayInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementValuePair returns ElementValuePair
	 *
	 * Constraint:
	 *     (identifier=ID elementvalue=ElementValue)
	 */
	protected void sequence_ElementValuePair(ISerializationContext context, ElementValuePair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.ELEMENT_VALUE_PAIR__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.ELEMENT_VALUE_PAIR__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.ELEMENT_VALUE_PAIR__ELEMENTVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.ELEMENT_VALUE_PAIR__ELEMENTVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementValuePairAccess().getIdentifierIDTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getElementValuePairAccess().getElementvalueElementValueParserRuleCall_2_0(), semanticObject.getElementvalue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementValuePairs returns ElementValuePairs
	 *
	 * Constraint:
	 *     (elementvaluepair+=ElementValuePair elementvaluepair+=ElementValuePair*)
	 */
	protected void sequence_ElementValuePairs(ISerializationContext context, ElementValuePairs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumBodyDeclarations returns EnumBodyDeclarations
	 *
	 * Constraint:
	 *     classbodydeclaration+=ClassBodyDeclaration*
	 */
	protected void sequence_EnumBodyDeclarations(ISerializationContext context, EnumBodyDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumConstant returns EnumConstant
	 *
	 * Constraint:
	 *     (annotations=Annotations? identifier=ID arguments=Arguments? classbodydeclaration+=ClassBodyDeclaration*)
	 */
	protected void sequence_EnumConstant(ISerializationContext context, EnumConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumConstants returns EnumConstants
	 *
	 * Constraint:
	 *     (enumconstant+=EnumConstant enumconstant+=EnumConstant*)
	 */
	protected void sequence_EnumConstants(ISerializationContext context, EnumConstants semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrInterfaceDeclaration returns EnumDeclaration
	 *     ClassDeclaration returns EnumDeclaration
	 *     EnumDeclaration returns EnumDeclaration
	 *     MemberDecl returns EnumDeclaration
	 *     AnnotationTypeElementRest returns EnumDeclaration
	 *     IdentifierHaving returns EnumDeclaration
	 *
	 * Constraint:
	 *     (identifier=ID (implementedTypes+=Type implementedTypes+=Type*)? enumconstants=EnumConstants? bodyDeclarations=EnumBodyDeclarations?)
	 */
	protected void sequence_EnumDeclaration(ISerializationContext context, EnumDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionInClosure returns BlockExpression
	 *
	 * Constraint:
	 *     expressions+=ExpressionOrVarDeclaration*
	 */
	protected void sequence_ExpressionInClosure(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns FeatureCall
	 *     Expression returns FeatureCall
	 *     Assignment returns FeatureCall
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns FeatureCall
	 *     OrExpression returns FeatureCall
	 *     OrExpression.BinaryOperation_1_0_0_0 returns FeatureCall
	 *     AndExpression returns FeatureCall
	 *     AndExpression.BinaryOperation_1_0_0_0 returns FeatureCall
	 *     EqualityExpression returns FeatureCall
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns FeatureCall
	 *     RelationalExpression returns FeatureCall
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns FeatureCall
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns FeatureCall
	 *     OtherOperatorExpression returns FeatureCall
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns FeatureCall
	 *     AdditiveExpression returns FeatureCall
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns FeatureCall
	 *     MultiplicativeExpression returns FeatureCall
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns FeatureCall
	 *     UnaryOperation returns FeatureCall
	 *     PostfixOperation returns FeatureCall
	 *     PostfixOperation.PostfixOperation_1_0_0 returns FeatureCall
	 *     MemberFeatureCall returns FeatureCall
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns FeatureCall
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns FeatureCall
	 *     PrimaryExpression returns FeatureCall
	 *     ParenthesizedExpression returns FeatureCall
	 *     ExpressionOrVarDeclaration returns FeatureCall
	 *     FeatureCall returns FeatureCall
	 *
	 * Constraint:
	 *     (
	 *         (typeArguments+=JvmArgumentTypeReference typeArguments+=JvmArgumentTypeReference*)? 
	 *         feature=IdOrSuper 
	 *         (explicitOperationCall?='(' (featureCallArguments+=ShortClosure | (featureCallArguments+=Expression featureCallArguments+=Expression*))?)? 
	 *         featureCallArguments+=Closure?
	 *     )
	 */
	protected void sequence_FeatureCall(ISerializationContext context, FeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldDeclaration returns FieldDeclaration
	 *
	 * Constraint:
	 *     (variabledeclarator+=VariableDeclarator variabledeclarator+=VariableDeclarator*)
	 */
	protected void sequence_FieldDeclaration(ISerializationContext context, FieldDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ForLoopExpression
	 *     Expression returns ForLoopExpression
	 *     Assignment returns ForLoopExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns ForLoopExpression
	 *     OrExpression returns ForLoopExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ForLoopExpression
	 *     AndExpression returns ForLoopExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ForLoopExpression
	 *     EqualityExpression returns ForLoopExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ForLoopExpression
	 *     RelationalExpression returns ForLoopExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ForLoopExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns ForLoopExpression
	 *     OtherOperatorExpression returns ForLoopExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns ForLoopExpression
	 *     AdditiveExpression returns ForLoopExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ForLoopExpression
	 *     MultiplicativeExpression returns ForLoopExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ForLoopExpression
	 *     UnaryOperation returns ForLoopExpression
	 *     PostfixOperation returns ForLoopExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ForLoopExpression
	 *     MemberFeatureCall returns ForLoopExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns ForLoopExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns ForLoopExpression
	 *     PrimaryExpression returns ForLoopExpression
	 *     ParenthesizedExpression returns ForLoopExpression
	 *     ForLoopExpression returns ForLoopExpression
	 *     ExpressionOrVarDeclaration returns ForLoopExpression
	 *
	 * Constraint:
	 *     (declaredParam=JvmFormalParameter forExpression=Expression eachExpression=Expression)
	 */
	protected void sequence_ForLoopExpression(ISerializationContext context, ForLoopExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.FOR_LOOP_EXPRESSION__DECLARED_PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.FOR_LOOP_EXPRESSION__DECLARED_PARAM));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.FOR_LOOP_EXPRESSION__FOR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.FOR_LOOP_EXPRESSION__FOR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.FOR_LOOP_EXPRESSION__EACH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.FOR_LOOP_EXPRESSION__EACH_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForLoopExpressionAccess().getDeclaredParamJvmFormalParameterParserRuleCall_0_0_3_0(), semanticObject.getDeclaredParam());
		feeder.accept(grammarAccess.getForLoopExpressionAccess().getForExpressionExpressionParserRuleCall_1_0(), semanticObject.getForExpression());
		feeder.accept(grammarAccess.getForLoopExpressionAccess().getEachExpressionExpressionParserRuleCall_3_0(), semanticObject.getEachExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FormalParameterDecl returns FormalParameterDecl
	 *     Modifiable returns FormalParameterDecl
	 *     Typed returns FormalParameterDecl
	 *
	 * Constraint:
	 *     (modifiers+=Modifier* type=Type varargs?='...'? identifier=ID)
	 */
	protected void sequence_FormalParameterDecl(ISerializationContext context, FormalParameterDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FullJvmFormalParameter returns ValidID
	 *
	 * Constraint:
	 *     (parameterType=ValidID name=ValidID)
	 */
	protected void sequence_FullJvmFormalParameter(ISerializationContext context, ValidID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.VALID_ID__PARAMETER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.VALID_ID__PARAMETER_TYPE));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.VALID_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.VALID_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFullJvmFormalParameterAccess().getParameterTypeValidIDParserRuleCall_0_0(), semanticObject.getParameterType());
		feeder.accept(grammarAccess.getFullJvmFormalParameterAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericMethodOrConstructorDeclOld returns GenericMethodOrConstructorDeclOld
	 *
	 * Constraint:
	 *     constructor=Constructor
	 */
	protected void sequence_GenericMethodOrConstructorDeclOld(ISerializationContext context, GenericMethodOrConstructorDeclOld semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.GENERIC_METHOD_OR_CONSTRUCTOR_DECL_OLD__CONSTRUCTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.GENERIC_METHOD_OR_CONSTRUCTOR_DECL_OLD__CONSTRUCTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGenericMethodOrConstructorDeclOldAccess().getConstructorConstructorParserRuleCall_1_0(), semanticObject.getConstructor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericMethodOrConstructorDeclOld returns TypeParameters
	 *
	 * Constraint:
	 *     (
	 *         typeparameter+=TypeParameter 
	 *         typeparameter+=TypeParameter* 
	 *         type=Type? 
	 *         identifier=ID 
	 *         (parameters+=FormalParameterDecl parameters+=FormalParameterDecl*)? 
	 *         (exceptions+=DeclaredException exceptions+=DeclaredException*)? 
	 *         methodbody=MethodBody?
	 *     )
	 */
	protected void sequence_GenericMethodOrConstructorDeclOld_TypeParameters(ISerializationContext context, TypeParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberDecl returns GenericMethodOrConstructorDecl
	 *     GenericMethodOrConstructorDecl returns GenericMethodOrConstructorDecl
	 *
	 * Constraint:
	 *     (typeParameters=TypeParameters ((type=Type method=MethodDeclaration) | method=MethodDeclaration | constructor=Constructor))
	 */
	protected void sequence_GenericMethodOrConstructorDecl(ISerializationContext context, GenericMethodOrConstructorDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns IfExpression
	 *     Expression returns IfExpression
	 *     Assignment returns IfExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns IfExpression
	 *     OrExpression returns IfExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns IfExpression
	 *     AndExpression returns IfExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns IfExpression
	 *     EqualityExpression returns IfExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns IfExpression
	 *     RelationalExpression returns IfExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns IfExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns IfExpression
	 *     OtherOperatorExpression returns IfExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns IfExpression
	 *     AdditiveExpression returns IfExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns IfExpression
	 *     MultiplicativeExpression returns IfExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns IfExpression
	 *     UnaryOperation returns IfExpression
	 *     PostfixOperation returns IfExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns IfExpression
	 *     MemberFeatureCall returns IfExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns IfExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns IfExpression
	 *     PrimaryExpression returns IfExpression
	 *     ParenthesizedExpression returns IfExpression
	 *     IfExpression returns IfExpression
	 *     ExpressionOrVarDeclaration returns IfExpression
	 *
	 * Constraint:
	 *     (if=Expression then=Expression else=Expression?)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDeclaration returns ImportDeclaration
	 *
	 * Constraint:
	 *     (static?='static'? qualifiedname=QualifiedName wildcard?='*'?)
	 */
	protected void sequence_ImportDeclaration(ISerializationContext context, ImportDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLExpressionHaving returns JMLAxiomExpression
	 *     JMLTypeExpression returns JMLAxiomExpression
	 *     JMLAxiomExpression returns JMLAxiomExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_JMLAxiomExpression(ISerializationContext context, JMLAxiomExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLAxiomExpressionAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLMethodSpecification returns JMLBehaviorBlock
	 *     JMLMethodBehavior returns JMLBehaviorBlock
	 *     JMLBehaviorBlock returns JMLBehaviorBlock
	 *
	 * Constraint:
	 *     specifications+=JMLMethodExpression+
	 */
	protected void sequence_JMLBehaviorBlock(ISerializationContext context, JMLBehaviorBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLExpressionHaving returns JMLConstraintExpression
	 *     JMLTypeExpression returns JMLConstraintExpression
	 *     JMLConstraintExpression returns JMLConstraintExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_JMLConstraintExpression(ISerializationContext context, JMLConstraintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLConstraintExpressionAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLExpressionHaving returns JMLEnsuresExpression
	 *     JMLMethodSpecification returns JMLEnsuresExpression
	 *     JMLMethodExpression returns JMLEnsuresExpression
	 *     JMLEnsuresExpression returns JMLEnsuresExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_JMLEnsuresExpression(ISerializationContext context, JMLEnsuresExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLEnsuresExpressionAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLMethodSpecification returns JMLExceptionalBehaviorBlock
	 *     JMLMethodBehavior returns JMLExceptionalBehaviorBlock
	 *     JMLExceptionalBehaviorBlock returns JMLExceptionalBehaviorBlock
	 *
	 * Constraint:
	 *     specifications+=JMLMethodExpression+
	 */
	protected void sequence_JMLExceptionalBehaviorBlock(ISerializationContext context, JMLExceptionalBehaviorBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLForAllExpression returns JMLForAllExpression
	 *
	 * Constraint:
	 *     ((initExpressions+=VarDecl initExpressions+=VarDecl*)? expression=Expression? (updateExpressions+=Expression updateExpressions+=Expression*)?)
	 */
	protected void sequence_JMLForAllExpression(ISerializationContext context, JMLForAllExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns JMLFreshExpression
	 *     Expression returns JMLFreshExpression
	 *     Assignment returns JMLFreshExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns JMLFreshExpression
	 *     OrExpression returns JMLFreshExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns JMLFreshExpression
	 *     AndExpression returns JMLFreshExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns JMLFreshExpression
	 *     EqualityExpression returns JMLFreshExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns JMLFreshExpression
	 *     RelationalExpression returns JMLFreshExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns JMLFreshExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns JMLFreshExpression
	 *     OtherOperatorExpression returns JMLFreshExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns JMLFreshExpression
	 *     AdditiveExpression returns JMLFreshExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns JMLFreshExpression
	 *     MultiplicativeExpression returns JMLFreshExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns JMLFreshExpression
	 *     UnaryOperation returns JMLFreshExpression
	 *     PostfixOperation returns JMLFreshExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns JMLFreshExpression
	 *     MemberFeatureCall returns JMLFreshExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns JMLFreshExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns JMLFreshExpression
	 *     PrimaryExpression returns JMLFreshExpression
	 *     JMLFreshExpression returns JMLFreshExpression
	 *     ParenthesizedExpression returns JMLFreshExpression
	 *     ExpressionOrVarDeclaration returns JMLFreshExpression
	 *
	 * Constraint:
	 *     expr=ParenthesisExpression
	 */
	protected void sequence_JMLFreshExpression(ISerializationContext context, JMLFreshExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_FRESH_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_FRESH_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLFreshExpressionAccess().getExprParenthesisExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLSpecificationOnlyElement returns JMLGhostElement
	 *     JMLGhostElement returns JMLGhostElement
	 *
	 * Constraint:
	 *     (instance?='instance'? element=MemberDeclWithModifierSpec)
	 */
	protected void sequence_JMLGhostElement(ISerializationContext context, JMLGhostElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLExpressionHaving returns JMLInvariantExpression
	 *     JMLTypeExpression returns JMLInvariantExpression
	 *     JMLInvariantExpression returns JMLInvariantExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_JMLInvariantExpression(ISerializationContext context, JMLInvariantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLInvariantExpressionAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLMemberModifier returns JMLMemberModifier
	 *
	 * Constraint:
	 *     modifier=JMLSpecMemberModifier
	 */
	protected void sequence_JMLMemberModifier(ISerializationContext context, JMLMemberModifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_MEMBER_MODIFIER__MODIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_MEMBER_MODIFIER__MODIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLMemberModifierAccess().getModifierJMLSpecMemberModifierEnumRuleCall_0(), semanticObject.getModifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLMethodSpecificationWithModifier returns JMLMethodSpecificationWithModifierExtended
	 *     JMLMethodSpecificationWithModifierExtended returns JMLMethodSpecificationWithModifierExtended
	 *
	 * Constraint:
	 *     (modifier+=VisiblityModifier* spec=JMLMethodSpecification)
	 */
	protected void sequence_JMLMethodSpecificationWithModifierExtended(ISerializationContext context, JMLMethodSpecificationWithModifierExtended semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLMethodSpecificationWithModifier returns JMLMethodSpecificationWithModifierRegular
	 *     JMLMethodSpecificationWithModifierRegular returns JMLMethodSpecificationWithModifierRegular
	 *
	 * Constraint:
	 *     (modifier+=VisiblityModifier* spec=JMLMethodSpecification)
	 */
	protected void sequence_JMLMethodSpecificationWithModifierRegular(ISerializationContext context, JMLMethodSpecificationWithModifierRegular semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLSpecificationOnlyElement returns JMLModelElement
	 *     JMLModelElement returns JMLModelElement
	 *
	 * Constraint:
	 *     (instance?='instance'? element=MemberDeclWithModifierSpec)
	 */
	protected void sequence_JMLModelElement(ISerializationContext context, JMLModelElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns JMLMultilineSpec
	 *     JMLSpecifiedElement returns JMLMultilineSpec
	 *     JMLMultilineSpec returns JMLMultilineSpec
	 *
	 * Constraint:
	 *     (
	 *         jmlTypeSpecifications+=JMLTypeExpressionWithModifier+ | 
	 *         (
	 *             jmlSpecifications+=JMLMethodSpecificationWithModifier* 
	 *             (modelElement=JMLSpecificationOnlyElementWithModifier | element=MemberDeclWithModifierRegular)
	 *         )
	 *     )
	 */
	protected void sequence_JMLMultilineSpec(ISerializationContext context, JMLMultilineSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLMethodSpecification returns JMLNormalBehaviorBlock
	 *     JMLMethodBehavior returns JMLNormalBehaviorBlock
	 *     JMLNormalBehaviorBlock returns JMLNormalBehaviorBlock
	 *
	 * Constraint:
	 *     specifications+=JMLMethodExpression+
	 */
	protected void sequence_JMLNormalBehaviorBlock(ISerializationContext context, JMLNormalBehaviorBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns JMLOldExpression
	 *     Expression returns JMLOldExpression
	 *     Assignment returns JMLOldExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns JMLOldExpression
	 *     OrExpression returns JMLOldExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns JMLOldExpression
	 *     AndExpression returns JMLOldExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns JMLOldExpression
	 *     EqualityExpression returns JMLOldExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns JMLOldExpression
	 *     RelationalExpression returns JMLOldExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns JMLOldExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns JMLOldExpression
	 *     OtherOperatorExpression returns JMLOldExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns JMLOldExpression
	 *     AdditiveExpression returns JMLOldExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns JMLOldExpression
	 *     MultiplicativeExpression returns JMLOldExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns JMLOldExpression
	 *     UnaryOperation returns JMLOldExpression
	 *     PostfixOperation returns JMLOldExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns JMLOldExpression
	 *     MemberFeatureCall returns JMLOldExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns JMLOldExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns JMLOldExpression
	 *     PrimaryExpression returns JMLOldExpression
	 *     JMLOldExpression returns JMLOldExpression
	 *     ParenthesizedExpression returns JMLOldExpression
	 *     ExpressionOrVarDeclaration returns JMLOldExpression
	 *
	 * Constraint:
	 *     expr=ParenthesisExpression
	 */
	protected void sequence_JMLOldExpression(ISerializationContext context, JMLOldExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_OLD_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_OLD_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLOldExpressionAccess().getExprParenthesisExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JMLExpressionHaving returns JMLRequiresExpression
	 *     JMLMethodSpecification returns JMLRequiresExpression
	 *     JMLMethodExpression returns JMLRequiresExpression
	 *     JMLRequiresExpression returns JMLRequiresExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_JMLRequiresExpression(ISerializationContext context, JMLRequiresExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.JML_EXPRESSION_HAVING__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJMLRequiresExpressionAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns JMLResultExpression
	 *     Expression returns JMLResultExpression
	 *     Assignment returns JMLResultExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns JMLResultExpression
	 *     OrExpression returns JMLResultExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns JMLResultExpression
	 *     AndExpression returns JMLResultExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns JMLResultExpression
	 *     EqualityExpression returns JMLResultExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns JMLResultExpression
	 *     RelationalExpression returns JMLResultExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns JMLResultExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns JMLResultExpression
	 *     OtherOperatorExpression returns JMLResultExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns JMLResultExpression
	 *     AdditiveExpression returns JMLResultExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns JMLResultExpression
	 *     MultiplicativeExpression returns JMLResultExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns JMLResultExpression
	 *     UnaryOperation returns JMLResultExpression
	 *     PostfixOperation returns JMLResultExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns JMLResultExpression
	 *     MemberFeatureCall returns JMLResultExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns JMLResultExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns JMLResultExpression
	 *     PrimaryExpression returns JMLResultExpression
	 *     JMLResultExpression returns JMLResultExpression
	 *     ParenthesizedExpression returns JMLResultExpression
	 *     ExpressionOrVarDeclaration returns JMLResultExpression
	 *
	 * Constraint:
	 *     {JMLResultExpression}
	 */
	protected void sequence_JMLResultExpression(ISerializationContext context, JMLResultExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns JMLSinglelineSpec
	 *     JMLSpecifiedElement returns JMLSinglelineSpec
	 *     JMLSinglelineSpec returns JMLSinglelineSpec
	 *
	 * Constraint:
	 *     (
	 *         element=MemberDeclWithModifierRegular | 
	 *         jmlTypeSpecifications+=JMLTypeExpressionWithModifier | 
	 *         (
	 *             jmlSpecifications+=JMLMethodSpecificationWithModifier 
	 *             jmlSpecifications+=JMLMethodSpecificationWithModifier* 
	 *             element=MemberDeclWithModifierRegular
	 *         )
	 *     )
	 */
	protected void sequence_JMLSinglelineSpec(ISerializationContext context, JMLSinglelineSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLSpecificationOnlyElementWithModifier returns JMLSpecificationOnlyElementWithModifier
	 *
	 * Constraint:
	 *     (modifier+=VisiblityModifier* element=JMLSpecificationOnlyElement)
	 */
	protected void sequence_JMLSpecificationOnlyElementWithModifier(ISerializationContext context, JMLSpecificationOnlyElementWithModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JMLTypeExpressionWithModifier returns JMLTypeExpressionWithModifier
	 *
	 * Constraint:
	 *     (modifier+=VisiblityModifier* spec=JMLTypeExpression)
	 */
	protected void sequence_JMLTypeExpressionWithModifier(ISerializationContext context, JMLTypeExpressionWithModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JvmFormalParameter returns ValidID
	 *
	 * Constraint:
	 *     (parameterType=ValidID? name=ValidID)
	 */
	protected void sequence_JvmFormalParameter(ISerializationContext context, ValidID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ListLiteral
	 *     Expression returns ListLiteral
	 *     Assignment returns ListLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns ListLiteral
	 *     OrExpression returns ListLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ListLiteral
	 *     AndExpression returns ListLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ListLiteral
	 *     EqualityExpression returns ListLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ListLiteral
	 *     RelationalExpression returns ListLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ListLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns ListLiteral
	 *     OtherOperatorExpression returns ListLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns ListLiteral
	 *     AdditiveExpression returns ListLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ListLiteral
	 *     MultiplicativeExpression returns ListLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ListLiteral
	 *     UnaryOperation returns ListLiteral
	 *     PostfixOperation returns ListLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ListLiteral
	 *     MemberFeatureCall returns ListLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns ListLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns ListLiteral
	 *     PrimaryExpression returns ListLiteral
	 *     Literal returns ListLiteral
	 *     CollectionLiteral returns ListLiteral
	 *     ListLiteral returns ListLiteral
	 *     ParenthesizedExpression returns ListLiteral
	 *     ExpressionOrVarDeclaration returns ListLiteral
	 *
	 * Constraint:
	 *     (elements+=Expression elements+=Expression*)?
	 */
	protected void sequence_ListLiteral(ISerializationContext context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberDeclWithModifier returns MemberDeclWithModifierRegular
	 *     MemberDeclWithModifierRegular returns MemberDeclWithModifierRegular
	 *     Modifiable returns MemberDeclWithModifierRegular
	 *
	 * Constraint:
	 *     (modifiers+=Modifier* jmlModifiers+=JMLMemberModifier* memberdecl=MemberDecl)
	 */
	protected void sequence_MemberDeclWithModifierRegular(ISerializationContext context, MemberDeclWithModifierRegular semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberDeclWithModifier returns MemberDeclWithModifierSpec
	 *     MemberDeclWithModifierSpec returns MemberDeclWithModifierSpec
	 *     Modifiable returns MemberDeclWithModifierSpec
	 *
	 * Constraint:
	 *     (modifiers+=Modifier* jmlModifiers+=JMLMemberModifier* memberdecl=MemberDecl)
	 */
	protected void sequence_MemberDeclWithModifierSpec(ISerializationContext context, MemberDeclWithModifierSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberDecl returns MemberDeclaration
	 *     MemberDeclaration returns MemberDeclaration
	 *     Typed returns MemberDeclaration
	 *
	 * Constraint:
	 *     (type=Type? (method=MethodDeclaration | field=FieldDeclaration))
	 */
	protected void sequence_MemberDeclaration(ISerializationContext context, MemberDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns Assignment
	 *     OrExpression returns Assignment
	 *     OrExpression.BinaryOperation_1_0_0_0 returns Assignment
	 *     AndExpression returns Assignment
	 *     AndExpression.BinaryOperation_1_0_0_0 returns Assignment
	 *     EqualityExpression returns Assignment
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns Assignment
	 *     RelationalExpression returns Assignment
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns Assignment
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns Assignment
	 *     OtherOperatorExpression returns Assignment
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns Assignment
	 *     AdditiveExpression returns Assignment
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns Assignment
	 *     MultiplicativeExpression returns Assignment
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns Assignment
	 *     UnaryOperation returns Assignment
	 *     PostfixOperation returns Assignment
	 *     PostfixOperation.PostfixOperation_1_0_0 returns Assignment
	 *     MemberFeatureCall returns Assignment
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns Assignment
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns Assignment
	 *
	 * Constraint:
	 *     (assignable=MemberFeatureCall_Assignment_1_0_0_0_0 feature=FeatureCallID value=Assignment)
	 */
	protected void sequence_MemberFeatureCall(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.ASSIGNMENT__ASSIGNABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.ASSIGNMENT__ASSIGNABLE));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.ASSIGNMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.ASSIGNMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMemberFeatureCallAccess().getAssignmentAssignableAction_1_0_0_0_0(), semanticObject.getAssignable());
		feeder.accept(grammarAccess.getMemberFeatureCallAccess().getFeatureFeatureCallIDParserRuleCall_1_0_0_0_2_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getMemberFeatureCallAccess().getValueAssignmentParserRuleCall_1_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns MemberFeatureCall
	 *     Expression returns MemberFeatureCall
	 *     Assignment returns MemberFeatureCall
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns MemberFeatureCall
	 *     OrExpression returns MemberFeatureCall
	 *     OrExpression.BinaryOperation_1_0_0_0 returns MemberFeatureCall
	 *     AndExpression returns MemberFeatureCall
	 *     AndExpression.BinaryOperation_1_0_0_0 returns MemberFeatureCall
	 *     EqualityExpression returns MemberFeatureCall
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns MemberFeatureCall
	 *     RelationalExpression returns MemberFeatureCall
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns MemberFeatureCall
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns MemberFeatureCall
	 *     OtherOperatorExpression returns MemberFeatureCall
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns MemberFeatureCall
	 *     AdditiveExpression returns MemberFeatureCall
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns MemberFeatureCall
	 *     MultiplicativeExpression returns MemberFeatureCall
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns MemberFeatureCall
	 *     UnaryOperation returns MemberFeatureCall
	 *     PostfixOperation returns MemberFeatureCall
	 *     PostfixOperation.PostfixOperation_1_0_0 returns MemberFeatureCall
	 *     MemberFeatureCall returns MemberFeatureCall
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns MemberFeatureCall
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns MemberFeatureCall
	 *     ParenthesizedExpression returns MemberFeatureCall
	 *     ExpressionOrVarDeclaration returns MemberFeatureCall
	 *
	 * Constraint:
	 *     (
	 *         memberCallTarget=MemberFeatureCall_MemberFeatureCall_1_1_0_0_0 
	 *         (nullSafe?='?.' | explicitStatic?='::')? 
	 *         (typeArguments+=JvmArgumentTypeReference typeArguments+=JvmArgumentTypeReference*)? 
	 *         feature=IdOrSuper 
	 *         (explicitOperationCall?='(' (memberCallArguments+=ShortClosure | (memberCallArguments+=Expression memberCallArguments+=Expression*))?)? 
	 *         memberCallArguments+=Closure?
	 *     )
	 */
	protected void sequence_MemberFeatureCall(ISerializationContext context, MemberFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDeclaration returns MethodDeclaration
	 *     IdentifierHaving returns MethodDeclaration
	 *
	 * Constraint:
	 *     (
	 *         identifier=ID 
	 *         (parameters+=FormalParameterDecl parameters+=FormalParameterDecl*)? 
	 *         (exceptions+=DeclaredException exceptions+=DeclaredException*)? 
	 *         methodbody=MethodBody?
	 *     )
	 */
	protected void sequence_MethodDeclaration(ISerializationContext context, MethodDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns BinaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (leftOperand=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti rightOperand=UnaryOperation)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, BinaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.BINARY_OPERATION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.BINARY_OPERATION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.BINARY_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.BINARY_OPERATION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.BINARY_OPERATION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.BINARY_OPERATION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftOperandAction_1_0_0_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getFeatureOpMultiParserRuleCall_1_0_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightOperandUnaryOperationParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrInterfaceDeclaration returns NormalClassDeclaration
	 *     ClassDeclaration returns NormalClassDeclaration
	 *     NormalClassDeclaration returns NormalClassDeclaration
	 *     MemberDecl returns NormalClassDeclaration
	 *     AnnotationTypeElementRest returns NormalClassDeclaration
	 *
	 * Constraint:
	 *     (
	 *         identifier=ID 
	 *         typeparameters=TypeParameters? 
	 *         superType=Type? 
	 *         (implementedTypes+=Type implementedTypes+=Type*)? 
	 *         bodyDeclarations+=ClassBodyDeclaration*
	 *     )
	 */
	protected void sequence_NormalClassDeclaration(ISerializationContext context, NormalClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassOrInterfaceDeclaration returns NormalInterfaceDeclaration
	 *     InterfaceDeclaration returns NormalInterfaceDeclaration
	 *     NormalInterfaceDeclaration returns NormalInterfaceDeclaration
	 *     MemberDecl returns NormalInterfaceDeclaration
	 *     AnnotationTypeElementRest returns NormalInterfaceDeclaration
	 *
	 * Constraint:
	 *     (identifier=ID typeparameters=TypeParameters? (implementedTypes+=Type implementedTypes+=Type*)? bodyDeclarations+=ClassBodyDeclaration*)
	 */
	protected void sequence_NormalInterfaceDeclaration(ISerializationContext context, NormalInterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns NullLiteral
	 *     Expression returns NullLiteral
	 *     Assignment returns NullLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns NullLiteral
	 *     OrExpression returns NullLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns NullLiteral
	 *     AndExpression returns NullLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns NullLiteral
	 *     EqualityExpression returns NullLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns NullLiteral
	 *     RelationalExpression returns NullLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns NullLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns NullLiteral
	 *     OtherOperatorExpression returns NullLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns NullLiteral
	 *     AdditiveExpression returns NullLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns NullLiteral
	 *     MultiplicativeExpression returns NullLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns NullLiteral
	 *     UnaryOperation returns NullLiteral
	 *     PostfixOperation returns NullLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns NullLiteral
	 *     MemberFeatureCall returns NullLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns NullLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns NullLiteral
	 *     PrimaryExpression returns NullLiteral
	 *     Literal returns NullLiteral
	 *     ParenthesizedExpression returns NullLiteral
	 *     ExpressionOrVarDeclaration returns NullLiteral
	 *     NullLiteral returns NullLiteral
	 *
	 * Constraint:
	 *     {NullLiteral}
	 */
	protected void sequence_NullLiteral(ISerializationContext context, NullLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns NumberLiteral
	 *     Expression returns NumberLiteral
	 *     Assignment returns NumberLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns NumberLiteral
	 *     OrExpression returns NumberLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     EqualityExpression returns NumberLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     RelationalExpression returns NumberLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns NumberLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns NumberLiteral
	 *     OtherOperatorExpression returns NumberLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     AdditiveExpression returns NumberLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     MultiplicativeExpression returns NumberLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     UnaryOperation returns NumberLiteral
	 *     PostfixOperation returns NumberLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns NumberLiteral
	 *     MemberFeatureCall returns NumberLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns NumberLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns NumberLiteral
	 *     PrimaryExpression returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     ParenthesizedExpression returns NumberLiteral
	 *     ExpressionOrVarDeclaration returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueNumberParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     qualifiedname=QualifiedName
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.PACKAGE_DECLARATION__QUALIFIEDNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.PACKAGE_DECLARATION__QUALIFIEDNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageDeclarationAccess().getQualifiednameQualifiedNameParserRuleCall_1_0(), semanticObject.getQualifiedname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ParenthesisExpression
	 *     Expression returns ParenthesisExpression
	 *     Assignment returns ParenthesisExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns ParenthesisExpression
	 *     OrExpression returns ParenthesisExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ParenthesisExpression
	 *     AndExpression returns ParenthesisExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ParenthesisExpression
	 *     EqualityExpression returns ParenthesisExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ParenthesisExpression
	 *     RelationalExpression returns ParenthesisExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ParenthesisExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns ParenthesisExpression
	 *     OtherOperatorExpression returns ParenthesisExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns ParenthesisExpression
	 *     AdditiveExpression returns ParenthesisExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ParenthesisExpression
	 *     MultiplicativeExpression returns ParenthesisExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ParenthesisExpression
	 *     UnaryOperation returns ParenthesisExpression
	 *     PostfixOperation returns ParenthesisExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ParenthesisExpression
	 *     MemberFeatureCall returns ParenthesisExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns ParenthesisExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns ParenthesisExpression
	 *     PrimaryExpression returns ParenthesisExpression
	 *     ParenthesisExpression returns ParenthesisExpression
	 *     ParenthesizedExpression returns ParenthesisExpression
	 *     ExpressionOrVarDeclaration returns ParenthesisExpression
	 *
	 * Constraint:
	 *     (expr=ParenthesizedExpression | expr=JMLForAllExpression)
	 */
	protected void sequence_ParenthesisExpression(ISerializationContext context, ParenthesisExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns PostfixOperation
	 *     Expression returns PostfixOperation
	 *     Assignment returns PostfixOperation
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns PostfixOperation
	 *     OrExpression returns PostfixOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     AndExpression returns PostfixOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     EqualityExpression returns PostfixOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     RelationalExpression returns PostfixOperation
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns PostfixOperation
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns PostfixOperation
	 *     OtherOperatorExpression returns PostfixOperation
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     AdditiveExpression returns PostfixOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     MultiplicativeExpression returns PostfixOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     UnaryOperation returns PostfixOperation
	 *     PostfixOperation returns PostfixOperation
	 *     ParenthesizedExpression returns PostfixOperation
	 *     ExpressionOrVarDeclaration returns PostfixOperation
	 *
	 * Constraint:
	 *     (operand=PostfixOperation_PostfixOperation_1_0_0 feature=OpPostfix)
	 */
	protected void sequence_PostfixOperation(ISerializationContext context, PostfixOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.POSTFIX_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.POSTFIX_OPERATION__OPERAND));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.POSTFIX_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.POSTFIX_OPERATION__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixOperationAccess().getPostfixOperationOperandAction_1_0_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getPostfixOperationAccess().getFeatureOpPostfixParserRuleCall_1_0_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns PrimitiveTypeWithBrackets
	 *     PrimitiveTypeWithBrackets returns PrimitiveTypeWithBrackets
	 *
	 * Constraint:
	 *     (primitivetype=PrimitiveType brackets+=Brackets*)
	 */
	protected void sequence_PrimitiveTypeWithBrackets(ISerializationContext context, PrimitiveTypeWithBrackets semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifier returns RegularModifier
	 *     RegularModifier returns RegularModifier
	 *
	 * Constraint:
	 *     modifier=ModifierValue
	 */
	protected void sequence_RegularModifier(ISerializationContext context, RegularModifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.REGULAR_MODIFIER__MODIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.REGULAR_MODIFIER__MODIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularModifierAccess().getModifierModifierValueEnumRuleCall_0(), semanticObject.getModifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns InstanceOfExpression
	 *     Expression returns InstanceOfExpression
	 *     Assignment returns InstanceOfExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns InstanceOfExpression
	 *     OrExpression returns InstanceOfExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns InstanceOfExpression
	 *     AndExpression returns InstanceOfExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns InstanceOfExpression
	 *     EqualityExpression returns InstanceOfExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns InstanceOfExpression
	 *     RelationalExpression returns InstanceOfExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns InstanceOfExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns InstanceOfExpression
	 *     ParenthesizedExpression returns InstanceOfExpression
	 *     ExpressionOrVarDeclaration returns InstanceOfExpression
	 *
	 * Constraint:
	 *     (expression=RelationalExpression_InstanceOfExpression_1_0_0_0_0 type=Type)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, InstanceOfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.INSTANCE_OF_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.INSTANCE_OF_EXPRESSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getTypeTypeParserRuleCall_1_0_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ReturnExpression
	 *     Expression returns ReturnExpression
	 *     Assignment returns ReturnExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns ReturnExpression
	 *     OrExpression returns ReturnExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ReturnExpression
	 *     AndExpression returns ReturnExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ReturnExpression
	 *     EqualityExpression returns ReturnExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ReturnExpression
	 *     RelationalExpression returns ReturnExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ReturnExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns ReturnExpression
	 *     OtherOperatorExpression returns ReturnExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns ReturnExpression
	 *     AdditiveExpression returns ReturnExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ReturnExpression
	 *     MultiplicativeExpression returns ReturnExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ReturnExpression
	 *     UnaryOperation returns ReturnExpression
	 *     PostfixOperation returns ReturnExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ReturnExpression
	 *     MemberFeatureCall returns ReturnExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns ReturnExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns ReturnExpression
	 *     PrimaryExpression returns ReturnExpression
	 *     ParenthesizedExpression returns ReturnExpression
	 *     ExpressionOrVarDeclaration returns ReturnExpression
	 *     ReturnExpression returns ReturnExpression
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnExpression(ISerializationContext context, ReturnExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns SetLiteral
	 *     Expression returns SetLiteral
	 *     Assignment returns SetLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns SetLiteral
	 *     OrExpression returns SetLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns SetLiteral
	 *     AndExpression returns SetLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns SetLiteral
	 *     EqualityExpression returns SetLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns SetLiteral
	 *     RelationalExpression returns SetLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns SetLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns SetLiteral
	 *     OtherOperatorExpression returns SetLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns SetLiteral
	 *     AdditiveExpression returns SetLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns SetLiteral
	 *     MultiplicativeExpression returns SetLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns SetLiteral
	 *     UnaryOperation returns SetLiteral
	 *     PostfixOperation returns SetLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns SetLiteral
	 *     MemberFeatureCall returns SetLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns SetLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns SetLiteral
	 *     PrimaryExpression returns SetLiteral
	 *     Literal returns SetLiteral
	 *     CollectionLiteral returns SetLiteral
	 *     SetLiteral returns SetLiteral
	 *     ParenthesizedExpression returns SetLiteral
	 *     ExpressionOrVarDeclaration returns SetLiteral
	 *
	 * Constraint:
	 *     (elements+=Expression elements+=Expression*)?
	 */
	protected void sequence_SetLiteral(ISerializationContext context, SetLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShortClosure returns Closure
	 *
	 * Constraint:
	 *     ((declaredFormalParameters+=JvmFormalParameter declaredFormalParameters+=JvmFormalParameter*)? explicitSyntax?='|' expression=Expression)
	 */
	protected void sequence_ShortClosure(ISerializationContext context, Closure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns StaticBlock
	 *     StaticBlock returns StaticBlock
	 *
	 * Constraint:
	 *     (static?='static'? block=Block)
	 */
	protected void sequence_StaticBlock(ISerializationContext context, StaticBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Assignment returns StringLiteral
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     EqualityExpression returns StringLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     RelationalExpression returns StringLiteral
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns StringLiteral
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns StringLiteral
	 *     OtherOperatorExpression returns StringLiteral
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     UnaryOperation returns StringLiteral
	 *     PostfixOperation returns StringLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns StringLiteral
	 *     MemberFeatureCall returns StringLiteral
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns StringLiteral
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     Literal returns StringLiteral
	 *     ParenthesizedExpression returns StringLiteral
	 *     ExpressionOrVarDeclaration returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns SwitchExpression
	 *     Expression returns SwitchExpression
	 *     Assignment returns SwitchExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns SwitchExpression
	 *     OrExpression returns SwitchExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns SwitchExpression
	 *     AndExpression returns SwitchExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns SwitchExpression
	 *     EqualityExpression returns SwitchExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns SwitchExpression
	 *     RelationalExpression returns SwitchExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns SwitchExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns SwitchExpression
	 *     OtherOperatorExpression returns SwitchExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns SwitchExpression
	 *     AdditiveExpression returns SwitchExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns SwitchExpression
	 *     MultiplicativeExpression returns SwitchExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns SwitchExpression
	 *     UnaryOperation returns SwitchExpression
	 *     PostfixOperation returns SwitchExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns SwitchExpression
	 *     MemberFeatureCall returns SwitchExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns SwitchExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns SwitchExpression
	 *     PrimaryExpression returns SwitchExpression
	 *     ParenthesizedExpression returns SwitchExpression
	 *     SwitchExpression returns SwitchExpression
	 *     ExpressionOrVarDeclaration returns SwitchExpression
	 *
	 * Constraint:
	 *     (
	 *         ((declaredParam=JvmFormalParameter switch=Expression) | (declaredParam=JvmFormalParameter? switch=Expression)) 
	 *         cases+=CasePart* 
	 *         default=Expression?
	 *     )
	 */
	protected void sequence_SwitchExpression(ISerializationContext context, SwitchExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns SynchronizedExpression
	 *     Expression returns SynchronizedExpression
	 *     Assignment returns SynchronizedExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns SynchronizedExpression
	 *     OrExpression returns SynchronizedExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns SynchronizedExpression
	 *     AndExpression returns SynchronizedExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns SynchronizedExpression
	 *     EqualityExpression returns SynchronizedExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns SynchronizedExpression
	 *     RelationalExpression returns SynchronizedExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns SynchronizedExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns SynchronizedExpression
	 *     OtherOperatorExpression returns SynchronizedExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns SynchronizedExpression
	 *     AdditiveExpression returns SynchronizedExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns SynchronizedExpression
	 *     MultiplicativeExpression returns SynchronizedExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns SynchronizedExpression
	 *     UnaryOperation returns SynchronizedExpression
	 *     PostfixOperation returns SynchronizedExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns SynchronizedExpression
	 *     MemberFeatureCall returns SynchronizedExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns SynchronizedExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns SynchronizedExpression
	 *     PrimaryExpression returns SynchronizedExpression
	 *     ParenthesizedExpression returns SynchronizedExpression
	 *     ExpressionOrVarDeclaration returns SynchronizedExpression
	 *     SynchronizedExpression returns SynchronizedExpression
	 *
	 * Constraint:
	 *     (param=Expression expression=Expression)
	 */
	protected void sequence_SynchronizedExpression(ISerializationContext context, SynchronizedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.SYNCHRONIZED_EXPRESSION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.SYNCHRONIZED_EXPRESSION__PARAM));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.SYNCHRONIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.SYNCHRONIZED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSynchronizedExpressionAccess().getParamExpressionParserRuleCall_1_0(), semanticObject.getParam());
		feeder.accept(grammarAccess.getSynchronizedExpressionAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ThrowExpression
	 *     Expression returns ThrowExpression
	 *     Assignment returns ThrowExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns ThrowExpression
	 *     OrExpression returns ThrowExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ThrowExpression
	 *     AndExpression returns ThrowExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ThrowExpression
	 *     EqualityExpression returns ThrowExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ThrowExpression
	 *     RelationalExpression returns ThrowExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ThrowExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns ThrowExpression
	 *     OtherOperatorExpression returns ThrowExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns ThrowExpression
	 *     AdditiveExpression returns ThrowExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ThrowExpression
	 *     MultiplicativeExpression returns ThrowExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ThrowExpression
	 *     UnaryOperation returns ThrowExpression
	 *     PostfixOperation returns ThrowExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ThrowExpression
	 *     MemberFeatureCall returns ThrowExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns ThrowExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns ThrowExpression
	 *     PrimaryExpression returns ThrowExpression
	 *     ParenthesizedExpression returns ThrowExpression
	 *     ExpressionOrVarDeclaration returns ThrowExpression
	 *     ThrowExpression returns ThrowExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ThrowExpression(ISerializationContext context, ThrowExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.THROW_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.THROW_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThrowExpressionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns TryCatchFinallyExpression
	 *     Expression returns TryCatchFinallyExpression
	 *     Assignment returns TryCatchFinallyExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns TryCatchFinallyExpression
	 *     OrExpression returns TryCatchFinallyExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns TryCatchFinallyExpression
	 *     AndExpression returns TryCatchFinallyExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns TryCatchFinallyExpression
	 *     EqualityExpression returns TryCatchFinallyExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns TryCatchFinallyExpression
	 *     RelationalExpression returns TryCatchFinallyExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns TryCatchFinallyExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns TryCatchFinallyExpression
	 *     OtherOperatorExpression returns TryCatchFinallyExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns TryCatchFinallyExpression
	 *     AdditiveExpression returns TryCatchFinallyExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns TryCatchFinallyExpression
	 *     MultiplicativeExpression returns TryCatchFinallyExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns TryCatchFinallyExpression
	 *     UnaryOperation returns TryCatchFinallyExpression
	 *     PostfixOperation returns TryCatchFinallyExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns TryCatchFinallyExpression
	 *     MemberFeatureCall returns TryCatchFinallyExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns TryCatchFinallyExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns TryCatchFinallyExpression
	 *     PrimaryExpression returns TryCatchFinallyExpression
	 *     ParenthesizedExpression returns TryCatchFinallyExpression
	 *     ExpressionOrVarDeclaration returns TryCatchFinallyExpression
	 *     TryCatchFinallyExpression returns TryCatchFinallyExpression
	 *
	 * Constraint:
	 *     (expression=Expression ((catchClauses+=CatchClause+ finallyExpression=Expression?) | finallyExpression=Expression))
	 */
	protected void sequence_TryCatchFinallyExpression(ISerializationContext context, TryCatchFinallyExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeArgument returns TypeArgument
	 *
	 * Constraint:
	 *     (type=Type | (wildcard?='?' ((extends?='extends' | super?='super') type=Type)?))
	 */
	protected void sequence_TypeArgument(ISerializationContext context, TypeArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeArguments returns TypeArguments
	 *
	 * Constraint:
	 *     (typeargument+=TypeArgument typeargument+=TypeArgument*)
	 */
	protected void sequence_TypeArguments(ISerializationContext context, TypeArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeBound returns TypeBound
	 *
	 * Constraint:
	 *     (type+=Type type+=Type*)
	 */
	protected void sequence_TypeBound(ISerializationContext context, TypeBound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeParameter returns TypeParameter
	 *
	 * Constraint:
	 *     (identifier=ID typebound=TypeBound?)
	 */
	protected void sequence_TypeParameter(ISerializationContext context, TypeParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeParameters returns TypeParameters
	 *
	 * Constraint:
	 *     (typeparameter+=TypeParameter typeparameter+=TypeParameter*)
	 */
	protected void sequence_TypeParameters(ISerializationContext context, TypeParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns UnaryOperation
	 *     Expression returns UnaryOperation
	 *     Assignment returns UnaryOperation
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns UnaryOperation
	 *     OrExpression returns UnaryOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     AndExpression returns UnaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     EqualityExpression returns UnaryOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     RelationalExpression returns UnaryOperation
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns UnaryOperation
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns UnaryOperation
	 *     OtherOperatorExpression returns UnaryOperation
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     AdditiveExpression returns UnaryOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     MultiplicativeExpression returns UnaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     UnaryOperation returns UnaryOperation
	 *     ParenthesizedExpression returns UnaryOperation
	 *     ExpressionOrVarDeclaration returns UnaryOperation
	 *
	 * Constraint:
	 *     (feature=OpUnary operand=UnaryOperation)
	 */
	protected void sequence_UnaryOperation(ISerializationContext context, UnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.UNARY_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.UNARY_OPERATION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.UNARY_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.UNARY_OPERATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryOperationAccess().getFeatureOpUnaryParserRuleCall_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getUnaryOperationAccess().getOperandUnaryOperationParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns Expression
	 *
	 * Constraint:
	 *     (((type=Type name=ValidID) | name=ValidID) right=Expression?)
	 */
	protected void sequence_VarDecl(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarator returns VariableDeclarator
	 *     IdentifierHaving returns VariableDeclarator
	 *
	 * Constraint:
	 *     (identifier=ID brackets+=Brackets* expression=Expression?)
	 */
	protected void sequence_VariableDeclarator(ISerializationContext context, VariableDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VisiblityModifier returns VisiblityModifier
	 *
	 * Constraint:
	 *     modifier=VisibilityModifierValue
	 */
	protected void sequence_VisiblityModifier(ISerializationContext context, VisiblityModifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.VISIBLITY_MODIFIER__MODIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.VISIBLITY_MODIFIER__MODIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVisiblityModifierAccess().getModifierVisibilityModifierValueEnumRuleCall_0(), semanticObject.getModifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns WhileExpression
	 *     Expression returns WhileExpression
	 *     Assignment returns WhileExpression
	 *     Assignment.BinaryOperation_1_1_0_0_0 returns WhileExpression
	 *     OrExpression returns WhileExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns WhileExpression
	 *     AndExpression returns WhileExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns WhileExpression
	 *     EqualityExpression returns WhileExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns WhileExpression
	 *     RelationalExpression returns WhileExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns WhileExpression
	 *     RelationalExpression.BinaryOperation_1_1_0_0_0 returns WhileExpression
	 *     OtherOperatorExpression returns WhileExpression
	 *     OtherOperatorExpression.BinaryOperation_1_0_0_0 returns WhileExpression
	 *     AdditiveExpression returns WhileExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns WhileExpression
	 *     MultiplicativeExpression returns WhileExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns WhileExpression
	 *     UnaryOperation returns WhileExpression
	 *     PostfixOperation returns WhileExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns WhileExpression
	 *     MemberFeatureCall returns WhileExpression
	 *     MemberFeatureCall.Assignment_1_0_0_0_0 returns WhileExpression
	 *     MemberFeatureCall.MemberFeatureCall_1_1_0_0_0 returns WhileExpression
	 *     PrimaryExpression returns WhileExpression
	 *     ParenthesizedExpression returns WhileExpression
	 *     WhileExpression returns WhileExpression
	 *     ExpressionOrVarDeclaration returns WhileExpression
	 *
	 * Constraint:
	 *     (predicate=Expression body=Expression)
	 */
	protected void sequence_WhileExpression(ISerializationContext context, WhileExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.WHILE_EXPRESSION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.WHILE_EXPRESSION__PREDICATE));
			if (transientValues.isValueTransient(semanticObject, JMLPackage.Literals.WHILE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JMLPackage.Literals.WHILE_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileExpressionAccess().getPredicateExpressionParserRuleCall_3_0(), semanticObject.getPredicate());
		feeder.accept(grammarAccess.getWhileExpressionAccess().getBodyExpressionParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
