import tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor
import static tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.*;

import "http://tools.vitruv.tests.metamodels.allElementTypes" as minimal

response collection: simpleChangesTests
from metamodel minimal to metamodel minimal

/*
 * UpdateSingleValuedEAttribute
 */
response: ReplacedSingleValuedEAttribute {
	after value replaced minimal.Root[singleValuedEAttribute]
	call replaceSingleValuedEAttribute(change.affectedEObject, change.newValue)
}

routine: replaceSingleValuedEAttribute(minimal.Root root, Int value) {
	match {
		// The check statements do only test that multiple check statements work
		check { ^root != null }
		retrieve required element minimal.Root as targetElement corresponding to root
		check { ^value != null }
	}
	effect {
		update element targetElement {
			targetElement.singleValuedEAttribute = value;
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedEAttribute);
		}
	} 
}

/*
 * UpdateSingleValuedEAttribute
 */
response: ReplacedNonRootId {
	after value replaced minimal.NonRoot[id]
	call replaceNonRootId(change.affectedEObject, change.newValue)
}

routine: replaceNonRootId(minimal.NonRoot nonRoot, String value) {
	match {
		retrieve required element minimal.NonRoot as targetElement corresponding to nonRoot
	}
	effect {
		update element targetElement {
			targetElement.id = value;
		}
	}
}

///*
// * UnsetSingleValuedEAttribute
// */
//response: UnsetSingleValuedEAttribute
//after delete value of minimal.Root[singleValuedEAttribute] 
//effect { update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} execute {
//	targetElement.singleValuedEAttribute = null;
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		UnsetEAttribute);
//}

/*
 * CreateNonRootEObjectInList
 */
response: CreatedNonRootEObjectInList {
	after list entry inserted minimal.Root[multiValuedContainmentEReference]
	call insertNonRoot(change.affectedEObject, change.newValue)
}

routine: insertNonRoot(minimal.Root root, minimal.NonRoot insertedNonRoot) {
	match {
		retrieve required element minimal.Root as targetElement corresponding to root
	}
	effect {
		create element minimal.NonRoot as newNonRoot initialized as {
			newNonRoot.id = insertedNonRoot.id
		}
		update element targetElement {
			targetElement.multiValuedContainmentEReference += newNonRoot;
		}
		add correspondence between newNonRoot and insertedNonRoot 
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(CreateNonRootEObjectInList);
		}
	}
}

/*
 * DeleteNonRootEObjectInList
 */
response: DeletedNonRootEObjectInList {
	after list entry removed minimal.Root[multiValuedContainmentEReference]
	call removeNonRoot(change.oldValue)
}

routine: removeNonRoot(minimal.NonRoot removedNonRoot) {
	match {
		retrieve required element minimal.NonRoot as targetElement corresponding to removedNonRoot
	}
	effect {
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(DeleteNonRootEObjectInList);
		}
		delete element targetElement
	}
}

/*
 * ReplaceNonRootEObjectSingle
 */
response: ReplacedNonRootEObjectSingleResponse {
	after value replaced minimal.Root[singleValuedContainmentEReference]
	call {
		if (change.fromNonDefaultValue) {
			deleteNonRootEObjectSingle(change.oldValue);
		}
		if (change.toNonDefaultValue) {
			createNonRootEObjectSingle(change.affectedEObject, change.newValue);
		}
	} 
}

routine: deleteNonRootEObjectSingle(minimal.NonRoot containedObject) {
	match {
		retrieve required element minimal.NonRoot as targetElement corresponding to containedObject
	}
	effect {
		delete element targetElement
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(DeleteNonRootEObjectSingle);
		}
	}
}

routine: createNonRootEObjectSingle(minimal.Root sourceRoot, minimal.NonRoot containedObject) {
	match {
		retrieve required element minimal.Root as targetElement corresponding to sourceRoot
	}
	effect {
		create element minimal.NonRoot as newNonRoot initialized as {
			newNonRoot.id = containedObject.id
		}
		update element targetElement {
			targetElement.singleValuedContainmentEReference = newNonRoot;
		}
		add correspondence between newNonRoot and containedObject
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(CreateNonRootEObjectSingle);
		}
	}
}

/*
 * UpdateSingleValuedNonContainmentEReference
 */
response: ReplacedSingleValuedNonContainmentEReference {
	after value replaced minimal.Root[singleValuedNonContainmentEReference]
	call replaceSingleValuedNonContainmentReference(change.affectedEObject, change.newValue)
}

routine: replaceSingleValuedNonContainmentReference(minimal.Root root, minimal.NonRoot newReferencedElement) {
	match {
		retrieve required element minimal.Root as targetContainer corresponding to root
		retrieve required element minimal.NonRoot as targetElement corresponding to newReferencedElement
	}
	effect {
		update element targetContainer {
			targetContainer.singleValuedNonContainmentEReference = targetElement;
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedNonContainmentEReference);
		}
	}
}

///*
// * UnsetNonContainmentEReference
// */
//response: UnsetNonContainmentEReference
//after delete value minimal.Root[singleValuedNonContainmentEReference] 
//effect { update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} 
//execute {
//	targetElement.singleValuedNonContainmentEReference = null; 
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		UnsetNonContainmentEReference);
//}

/*
 * InsertEAttributeValue
 */
response: InsertedEAttributeValue {
	after list entry inserted minimal.Root[multiValuedEAttribute] 
	call insertEAttribute(change.affectedEObject, change.newValue)
}

routine: insertEAttribute(minimal.Root root, Int attributeValue) {
	match {
		retrieve required element minimal.Root as targetElement corresponding to root
	}
	effect {
		update element targetElement {
			targetElement.multiValuedEAttribute.add(attributeValue);
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(InsertEAttributeValue);
		}
	}
}

/*
 * RemoveEAttributeValue
 */
response: RemovedEAttributeValue {
	after list entry removed minimal.Root[multiValuedEAttribute] 
	call removeEAttribute(change.affectedEObject, change.oldValue)
}

routine: removeEAttribute(minimal.Root root, Int removedAttributeValue) {
	match {
		retrieve required element minimal.Root as targetElement corresponding to root
	}
	effect {
		update element targetElement {
			val sourceValueList = root.multiValuedEAttribute;
			targetElement.multiValuedEAttribute.removeIf[!sourceValueList.contains(it.intValue)];
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(RemoveEAttributeValue);
		}
	}
}

/*
 * InsertNonContainmentEReference
 */
response: InsertedNonContainmentEReference {
	after list entry inserted minimal.Root[multiValuedNonContainmentEReference] 
	call insertNonContainmentReference(change.affectedEObject, change.newValue)
}

routine: insertNonContainmentReference(minimal.Root root, minimal.NonRoot insertedNonRoot) {
	match {
		retrieve required element minimal.Root as targetElement corresponding to root
	}
	effect {
		update element targetElement {
			val addedNonRoot = targetElement.nonRootObjectContainerHelper.nonRootObjectsContainment.findFirst[it.id == insertedNonRoot.id];
			targetElement.multiValuedNonContainmentEReference.add(addedNonRoot);
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(InsertNonContainmentEReference);
		}
	}
}


/*
 * RemoveNonContainmentEReference
 */
response: RemoveedNonContainmentEReference {
	after list entry removed minimal.Root[multiValuedNonContainmentEReference] 
	call removeNonContainmentReference(change.affectedEObject, change.oldValue)
}

routine: removeNonContainmentReference(minimal.Root root, minimal.NonRoot removedNonRoot) {
	match {
		retrieve required element minimal.Root as targetRoot corresponding to root
	}
	effect {
		update element targetRoot {
			targetRoot.multiValuedNonContainmentEReference.removeIf[it.id == removedNonRoot.id];
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(RemoveNonContainmentEReference);
		}
	}
}

///*
// * ReplaceNonContainmentEReference
// */
//response: ReplaceNonContainmentEReference
//after element update of minimal.Root[multiValuedNonContainmentEReference] 
//effect { update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} 
//execute {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		ReplaceNonContainmentEReference);
//}

///*
// * PermuteNonContainmentEReference
// */
//response: after element old change PermuteNonContainmentEReferenceValues of minimal.Root[multiValuedNonContainmentEReference] 
//effect { update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} execute {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		PermuteNonContainmentEReference);
//}


routine: createRoot(minimal.Root root) {
	effect {
		create element minimal.Root as newRoot initialized as {
			newRoot.id = root.id;
		}
		add correspondence between newRoot and root
		call {
			persistProjectRelative(root, newRoot, "model/" + root.id.replace("Source", "Target"));
		}
	}
}

routine: deleteRoot(minimal.Root root) {
	match {
		retrieve required element minimal.Root as oldModel corresponding to root
	}
	effect {
		delete element oldModel
	}
}

/*
 * Creates the model for comparing the further test model with.
 */
response: CreateRootTest {
	after root created minimal.Root
	call createRoot(change.newValue)
}

response: DeleteRootTest {
	after root deleted minimal.Root
	call deleteRoot(change.oldValue)
}

/**
 * Initializes the nonRootObjectContainer for second model
 */
response: HelperResponseForNonRootObjectContainerInitialization {
	after value replaced minimal.Root[nonRootObjectContainerHelper]
		with change.isToNonDefaultValue
	call createNonRootObjectContainer(change.affectedEObject, change.newValue)
}

routine: createNonRootObjectContainer(minimal.Root root, minimal.NonRootObjectContainerHelper nonRootObjectContainer) {
	match {
		retrieve required element minimal.Root as targetElement corresponding to root
	}
	effect {
		create element minimal.NonRootObjectContainerHelper as newNonRootContainer initialized as {
			newNonRootContainer.id = nonRootObjectContainer.id;
		}
		update element targetElement {
			targetElement.nonRootObjectContainerHelper = newNonRootContainer;
		}
		add correspondence between newNonRootContainer and nonRootObjectContainer
	}
}

/**
 * Initializes the nonRootObjectContainer for second model
 */
response: HelperResponseForNonRootObjectContainerContentsInitialization {
	after list entry inserted minimal.NonRootObjectContainerHelper[nonRootObjectsContainment]
	call createNonRootInContainer(change.affectedEObject, change.newValue)
}

routine: createNonRootInContainer(minimal.NonRootObjectContainerHelper container, minimal.NonRoot insertedNonRoot) {
	match {
		retrieve required element minimal.NonRootObjectContainerHelper as nonRootContainer corresponding to container
	}
	effect {
		create element minimal.NonRoot as newNonRoot initialized as {
			newNonRoot.id = insertedNonRoot.id;
		}
		update element nonRootContainer {
			nonRootContainer.nonRootObjectsContainment += newNonRoot;	
		}
		add correspondence between newNonRoot and insertedNonRoot
	}
}
