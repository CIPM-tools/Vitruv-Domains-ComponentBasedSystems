import tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor
import static tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.*;

import "http://tools.vitruv.tests.metamodels.allElementTypes" as minimal

responses from metamodel minimal to metamodel minimal
called simpleChangesTests 

/*
 * UpdateSingleValuedEAttribute
 */
response: ReplacedSingleValuedEAttribute
trigger: replaced value minimal.Root[singleValuedEAttribute]
call callReplaceSingleValuedEAttribute(change.affectedEObject, change.newValue)

routine: ReplaceSingleValuedEAttribute(minimal.Root root, Int value)
match:
	retrieve required element: minimal.Root as targetElement corresponding to root
effect: execute: {
	targetElement.singleValuedEAttribute = value;
	SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedEAttribute);
}

/*
 * UpdateSingleValuedEAttribute
 */
response: ReplacedNonRootId
trigger: replaced value minimal.NonRoot[id]
call callReplaceNonRootId(change.affectedEObject, change.newValue)

routine: ReplaceNonRootId(minimal.NonRoot nonRoot, String value)
match:
	retrieve required element: minimal.NonRoot as targetElement corresponding to nonRoot
effect: execute: {
	targetElement.id = value;
}

///*
// * UnsetSingleValuedEAttribute
// */
//response: UnsetSingleValuedEAttribute
//trigger: delete value of minimal.Root[singleValuedEAttribute] 
//effect: update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} execute: {
//	targetElement.singleValuedEAttribute = null;
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		UnsetEAttribute);
//}

/*
 * CreateNonRootEObjectInList
 */
response: CreatedNonRootEObjectInList
trigger: inserted into list minimal.Root[multiValuedContainmentEReference]
call callInsertNonRoot(change.affectedEObject, change.newValue)

routine: InsertNonRoot(minimal.Root root, minimal.NonRoot insertedNonRoot)
match:
	retrieve required element: minimal.Root as targetElement corresponding to root
effect:
	create element: minimal.NonRoot as newNonRoot
	add correspondence: newNonRoot, insertedNonRoot 
	execute: {
		newNonRoot.id = insertedNonRoot.id
		targetElement.multiValuedContainmentEReference += newNonRoot;
		SimpleChangesTestsExecutionMonitor.instance.set(CreateNonRootEObjectInList);
	}

/*
 * DeleteNonRootEObjectInList
 */
response: DeletedNonRootEObjectInList
trigger: removed from list minimal.Root[multiValuedContainmentEReference]
call callRemoveNonRoot(change.oldValue)

routine: RemoveNonRoot(minimal.NonRoot removedNonRoot)
match:
	retrieve required element: minimal.NonRoot as targetElement corresponding to removedNonRoot
effect:
	delete element: targetElement
	execute: {
		// It works, even if we remove element in the execute block and via effect as well
		org.eclipse.emf.ecore.util.EcoreUtil.remove(targetElement);
		SimpleChangesTestsExecutionMonitor.instance.set(DeleteNonRootEObjectInList);
	}

/*
 * ReplaceNonRootEObjectSingle
 */
response: ReplacedNonRootEObjectSingleResponse
trigger: replaced value minimal.Root[singleValuedContainmentEReference]
call {
	if (change.fromNonDefaultValue) {
		callDeleteNonRootEObjectSingle(change.oldValue);
	}
	if (change.toNonDefaultValue) {
		callCreateNonRootEObjectSingle(change.affectedEObject, change.newValue);
	}
} 

routine: DeleteNonRootEObjectSingle(minimal.NonRoot containedObject)
match:
	retrieve required element: minimal.NonRoot as targetElement corresponding to containedObject
effect:
	delete element: targetElement
	execute: {
		SimpleChangesTestsExecutionMonitor.instance.set(DeleteNonRootEObjectSingle);
	}

routine: CreateNonRootEObjectSingle(minimal.Root sourceRoot, minimal.NonRoot containedObject)
match:
	retrieve required element: minimal.Root as targetElement corresponding to sourceRoot
effect:
	create element: minimal.NonRoot as newNonRoot
	add correspondence: newNonRoot, containedObject
	execute: {
		newNonRoot.id = containedObject.id;
		targetElement.singleValuedContainmentEReference = newNonRoot;
		SimpleChangesTestsExecutionMonitor.instance.set(CreateNonRootEObjectSingle);
	}

/*
 * UpdateSingleValuedNonContainmentEReference
 */
response: ReplacedSingleValuedNonContainmentEReference
trigger: replaced value minimal.Root[singleValuedNonContainmentEReference]
call callReplaceSingleValuedNonContainmentReference(change.affectedEObject, change.newValue)

routine: ReplaceSingleValuedNonContainmentReference(minimal.Root root, minimal.NonRoot newReferencedElement)
match:
	retrieve required element: minimal.Root as targetContainer corresponding to root
	retrieve required element: minimal.NonRoot as targetElement corresponding to newReferencedElement
effect:
	execute: {
		targetContainer.singleValuedNonContainmentEReference = targetElement;    
		SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedNonContainmentEReference);
	}

///*
// * UnsetNonContainmentEReference
// */
//response: UnsetNonContainmentEReference
//trigger: delete value minimal.Root[singleValuedNonContainmentEReference] 
//effect: update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} 
//execute: {
//	targetElement.singleValuedNonContainmentEReference = null; 
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		UnsetNonContainmentEReference);
//}

/*
 * InsertEAttributeValue
 */
response: InsertedEAttributeValue
trigger: inserted into list minimal.Root[multiValuedEAttribute] 
call callInsertEAttribute(change.affectedEObject, change.newValue)

routine: InsertEAttribute(minimal.Root root, Int attributeValue)
match:
	retrieve required element: minimal.Root as targetElement corresponding to root
effect:
	execute: {
		targetElement.multiValuedEAttribute.add(attributeValue);    
		SimpleChangesTestsExecutionMonitor.instance.set(InsertEAttributeValue);
	}

/*
 * RemoveEAttributeValue
 */
response: RemovedEAttributeValue
trigger: removed from list minimal.Root[multiValuedEAttribute] 
call callRemoveEAttribute(change.affectedEObject, change.oldValue)

routine: RemoveEAttribute(minimal.Root root, Int removedAttributeValue)
match:
	retrieve required element: minimal.Root as targetElement corresponding to root
effect:
	execute: {
		val sourceValueList = root.multiValuedEAttribute;
		targetElement.multiValuedEAttribute.removeIf[!sourceValueList.contains(it.intValue)];
		SimpleChangesTestsExecutionMonitor.instance.set(RemoveEAttributeValue);
	}

/*
 * InsertNonContainmentEReference
 */
response: InsertedNonContainmentEReference
trigger: inserted into list minimal.Root[multiValuedNonContainmentEReference] 
call callInsertNonContainmentReference(change.affectedEObject, change.newValue)

routine: InsertNonContainmentReference(minimal.Root root, minimal.NonRoot insertedNonRoot)
match:
	retrieve required element: minimal.Root as targetElement corresponding to root
effect:
	execute: {
		val addedNonRoot = targetElement.nonRootObjectContainerHelper.nonRootObjectsContainment.findFirst[it.id == insertedNonRoot.id];
		targetElement.multiValuedNonContainmentEReference.add(addedNonRoot);    
		SimpleChangesTestsExecutionMonitor.instance.set(InsertNonContainmentEReference);
	}

/*
 * RemoveNonContainmentEReference
 */
response: RemoveedNonContainmentEReference
trigger: removed from list minimal.Root[multiValuedNonContainmentEReference] 
call callRemoveNonContainmentReference(change.affectedEObject, change.oldValue)

routine: RemoveNonContainmentReference(minimal.Root root, minimal.NonRoot removedNonRoot)
match:
	retrieve required element: minimal.Root as targetRoot corresponding to root
effect:
	execute: {
		targetRoot.multiValuedNonContainmentEReference.removeIf[it.id == removedNonRoot.id];
		SimpleChangesTestsExecutionMonitor.instance.set(RemoveNonContainmentEReference);
	}

///*
// * ReplaceNonContainmentEReference
// */
//response: ReplaceNonContainmentEReference
//trigger: element update of minimal.Root[multiValuedNonContainmentEReference] 
//effect: update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} 
//execute: {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		ReplaceNonContainmentEReference);
//}

///*
// * PermuteNonContainmentEReference
// */
//response: trigger: element old change PermuteNonContainmentEReferenceValues of minimal.Root[multiValuedNonContainmentEReference] 
//effect: update root minimal.Root corresponding to {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsUtils.findTypeInContainmentHierarchy(change.newAffectedEObject, allElementTypes.Root);
//} execute: {
//	tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.instance.set(
//		tools.vitruv.dsls.response.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.
//		PermuteNonContainmentEReference);
//}


/*
 * Creates the model for comparing the "TestModelSource", created in each test, with.
 */
response: HelperResponseForCreateSecondTestModel
trigger: created root minimal.Root
check: change.newValue.id == "EachTestModelSource"
call callCreateRoot(change.newValue)

routine: CreateRoot(minimal.Root root)
effect:
	create element: minimal.Root as newRoot
	add correspondence: newRoot, root
	// persist as root at project-relative location: "model/EachTestModelTarget"
	execute: {
		newRoot.id = root.id;
		persistProjectRelative(root, newRoot, "model/" + root.id.replace("Source", "Target"));
	}

response: HelperResponseForDeleteSecondTestModel
trigger: deleted root minimal.Root
check: change.oldValue.id == "EachTestModelSource"
call callDeleteRoot(change.oldValue)

routine: DeleteRoot(minimal.Root root)
match:
	retrieve required element: minimal.Root as oldModel corresponding to root
effect:
	delete element: oldModel

/*
 * Creates the model for comparing the further test model with.
 */
response: CreateRootTest
trigger: created root minimal.Root
check: change.newValue.id == "Further_Source_Test_Model"
call callCreateRoot(change.newValue)

//effect: create root minimal.Root at "Further_Target_Test_Model" auto-delete corresponding to change.newValue

response: DeleteRootTest
trigger: deleted root minimal.Root
check: change.oldValue.id == "Further_Source_Test_Model"
call callDeleteRoot(change.oldValue)


//response: DuplicateRootDelete
//trigger: remove root minimal.Root
//delete element: oldModel of type minimal.Root corresponding to change.oldValue


/**
 * Initializes the nonRootObjectContainer for second model
 */
response: HelperResponseForNonRootObjectContainerInitialization
trigger: replaced value minimal.Root[nonRootObjectContainerHelper]
check: change.isToNonDefaultValue
call callCreateNonRootObjectContainer(change.affectedEObject, change.newValue)

routine: CreateNonRootObjectContainer(minimal.Root root, minimal.NonRootObjectContainerHelper nonRootObjectContainer)
match:
	retrieve required element: minimal.Root as targetElement corresponding to root
effect:
	create element: minimal.NonRootObjectContainerHelper as newNonRootContainer
	add correspondence: newNonRootContainer, nonRootObjectContainer
	execute: {
		newNonRootContainer.id = nonRootObjectContainer.id;
		targetElement.nonRootObjectContainerHelper = newNonRootContainer;
	}

/**
 * Initializes the nonRootObjectContainer for second model
 */
response: HelperResponseForNonRootObjectContainerContentsInitialization
trigger: inserted into list minimal.NonRootObjectContainerHelper[nonRootObjectsContainment]
call callCreateNonRootInContainer(change.affectedEObject, change.newValue)

routine: CreateNonRootInContainer(minimal.NonRootObjectContainerHelper container, minimal.NonRoot insertedNonRoot)
match:
	retrieve required element: minimal.NonRootObjectContainerHelper as nonRootContainer corresponding to container
effect:
	create element: minimal.NonRoot as newNonRoot
	add correspondence: newNonRoot, insertedNonRoot
	execute: {
		newNonRoot.id = insertedNonRoot.id;
		nonRootContainer.nonRootObjectsContainment += newNonRoot;
	}
