grammar tools.vitruv.dsls.response.ResponseLanguage with tools.vitruv.dsls.mirbase.MirBase
hidden(WS, SL_COMMENT)

generate responseLanguage "http://www.kit.edu/ipd/sdq/vitruvius/dsls/response/ResponseLanguage"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mirbase/MirBase" as mirbase


ResponseFile:
	(namespaceImports=XImportSection)?
	MirBaseFile
	(responsesSegments+=ResponsesSegment)+;
	
ResponsesSegment:
	'response collection:' name=ValidID
	'from metamodel' fromMetamodel=MetamodelReference 
	'to metamodel' toMetamodel=MetamodelReference
	(responses+=Response |
		routines+=Routine)*;

Response:
	(documentation=ML_COMMENT)?
	'response:' name=ValidID '{'
		trigger=Trigger
		callRoutine=RoutineCallStatement
	'}';

// ****** TRIGGER ******

InvariantViolationEvent:
	'invariant' violation=[ecore::EClass|QualifiedName];

Trigger:
	// TODO HK Extend this by "before" executing the transformation before applying the change
	'after' (ModelChange | InvariantViolationEvent)
	('with' precondition=PreconditionCodeBlock)?;

ModelChange:
	ConcreteModelElementChange | ArbitraryModelElementChange;

ConcreteModelElementChange returns ConcreteModelElementChange:
	AtomicConcreteModelElementChange;

AtomicConcreteModelElementChange:
	AtomicRootObjectChange | AtomicFeatureChange;

AtomicRootObjectChange:
	('root created' {InsertRootChange} |
	'root deleted' {RemoveRootChange})
	changedElement=ModelElement;

AtomicFeatureChange:
	(AtomicMultiValuedFeatureChange | AtomicSingleValuedFeatureChange)
	changedFeature=FeatureOfElement;

AtomicMultiValuedFeatureChange returns AtomicMultiValuedFeatureChange:
	'list entry inserted' {MultiValuedFeatureInsertChange} |
	'list entry removed' {MultiValuedFeatureRemoveChange} |
	'list permuted' {MultiValuedFeaturePermuteChange};

AtomicSingleValuedFeatureChange returns AtomicSingleValuedFeatureChange:
	//'create value' {SingleValuedFeatureCreate} | 'delete value' {SingleValuedFeatureDelete} | 
	'value replaced' {SingleValuedFeatureReplace};

ArbitraryModelElementChange:
	{ArbitraryModelElementChange} 'any change';



// ****** EFFECTS ******

Routine:
	'routine:' name=ValidID '(' input=RoutineInput ')' '{'
		matching=Matching?
		effect=Effect
	'}';

RoutineInput:
	{RoutineInput}
	 ((modelInputElements+=ClassicallyNamedModelElement | "plain" javaInputElements+=NamedJavaElement)
		(',' (modelInputElements+=ClassicallyNamedModelElement | "plain" javaInputElements+=NamedJavaElement))*)?;

Matching:
	{Matching}
	'match' '{'
		retrievedElements+=RetrieveModelElement*
		('check' condition=PreconditionCodeBlock)?
	'}';

Effect:
	{Effect}
	'effect' '{'
		(effectStatement += EffectStatement)*
		callRoutine=RoutineCallStatement?
	'}';
	
RoutineCallStatement returns RoutineCallStatement:
	{RoutineCallStatement}
	'call' CodeBlock;
	
// ****** CORRESPONDENCE SPECIFICATION ******	

fragment Taggable:
	tag=TagCodeBlock;

RetrieveModelElement:
	(required?='retrieve required element' | optional?='retrieve optional element' | abscence?='require absence of element') 
	element=NamedModelElement 'corresponding to' correspondenceSource=CorrespondingObjectCodeBlock
	('tagged with' Taggable)? ('with' precondition=PreconditionCodeBlock)?;

ExistingElementReference:
	CodeBlock;

EffectStatement:
	CreateElement | DeleteElement | UpdateElement | CreateCorrespondence | RemoveCorrespondence;
	
CreateElement returns EffectStatement:
	{CreateElement}
	"create element" element=NamedModelElement ("initialized as" initializationBlock=ExecutionCodeBlock)?;
	
DeleteElement returns EffectStatement:
	{DeleteElement}
	"delete element" element=ExistingElementReference;

UpdateElement returns EffectStatement:
	{UpdateElement}
	"update element" element=ExistingElementReference updateBlock=ExecutionCodeBlock;


CreateCorrespondence returns EffectStatement:
	{CreateCorrespondence}
	"add correspondence between" firstElement=ExistingElementReference "and" secondElement=ExistingElementReference
	('tag with' Taggable)?;
	
RemoveCorrespondence returns EffectStatement:
	{RemoveCorrespondence}
	"remove correspondence" firstElement=ExistingElementReference "," secondElement=ExistingElementReference;


// ****** CODE BLOCKS ******

TagCodeBlock returns TagCodeBlock:
	{TagCodeBlock}
	CodeBlock;

PreconditionCodeBlock returns PreconditionCodeBlock:
	{PreconditionCodeBlock}
	CodeBlock;

CorrespondingObjectCodeBlock returns CorrespondingObjectCodeBlock:
	{CorrespondingObjectCodeBlock}
	CodeBlock;

ExecutionCodeBlock returns ExecutionCodeBlock:
	{ExecutionCodeBlock}
	CodeBlock;

fragment CodeBlock:
	code=XExpression;
