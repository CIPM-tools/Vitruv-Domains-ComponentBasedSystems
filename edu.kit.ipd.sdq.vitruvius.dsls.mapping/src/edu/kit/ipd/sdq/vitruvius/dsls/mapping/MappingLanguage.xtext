grammar edu.kit.ipd.sdq.vitruvius.dsls.mapping.MappingLanguage
	with org.eclipse.xtext.xbase.Xbase

generate mappingLanguage "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mapping/MappingLanguage"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

MappingFile:
	'generates' pluginName=QualifiedName
	
	(imports += Import)*
	
	(mappings += Mapping | mappings += DefaultMapping)*
;

Import returns Import: 
	'import' package=[ecore::EPackage|STRING]
	('as' name=ValidID)?;


DefaultMapping returns Mapping:
	{Mapping}
	default?='default' name=ValidID ':'
 	('create' (signatures+=Signature constraints+=SignatureConstraintBlock))*
;

Mapping returns Mapping:
	{Mapping}
	('mapping' name=ValidID ':')?
	
	('when' '('
		requires+=RequiredMapping (',' requires+=RequiredMapping)* 
	 ')')?
	 
 	(
	 	('map' signatures+=Signature constraints+=SignatureConstraintBlock
	 	 'and' signatures+=Signature constraints+=SignatureConstraintBlock)
	  	('{'
	  		constraintsBody=BodyConstraintBlock
	  		(submappings+=Mapping)* 
	  	'}')?
  	) |
  	(
  		'map' '{'
	  		constraintsBody=BodyConstraintBlock
	  		(submappings+=Mapping)* 
	  	'}'

  	)
;

Signature:
	{Signature}
	'{' (elements+=NamedEClass (',' elements+=NamedEClass)*)? '}'
;

NamedEClass:
	type=[ecore::EClass|QualifiedName] 'as' name=ValidID
;

RequiredMapping:
	mapping=[Mapping] 'as' name=ValidID
;


ConstraintBlock:
	SignatureConstraintBlock |
	BodyConstraintBlock
;

ConstraintExpression:
	SignatureConstraintExpression |
	BodyConstraintExpression
;

SignatureConstraintBlock:
	{SignatureConstraintBlock}
	('['
		(expressions+=SignatureConstraintExpression ';'?)*
	']')?
;

SignatureConstraintExpression returns ConstraintExpression:
 	InExpression
	| EqualsLiteralExpression
	| DefaultContainExpression
;

BodyConstraintBlock:
	{BodyConstraintBlock}
	('['
		(expressions+=BodyConstraintExpression ';'?)*
	']')?
;

BodyConstraintExpression returns ConstraintExpression:
	AttributeEquivalenceExpression
;


VariableRef returns ConstraintExpression:
	{VariableRef}
	target=ContextVariable
;

InExpression returns ConstraintExpression:
	{InExpression}
	'in' '(' target=ContextVariable ',' source=FeatureOfContextVariable ')'
;

DefaultContainExpression returns ConstraintExpression:
	{DefaultContainExpression}
	(('default-contain' '(' target=ContextVariable ',' source=FeatureOfContextVariable ')')
	| ('default-resource' '(' target=ContextVariable ',' resource=STRING ')'))
;

EqualsLiteralExpression returns ConstraintExpression:
	{EqualsLiteralExpression}
	'equal' '(' target=FeatureOfContextVariable ',' value=ConstraintLiteral ')'
;

AttributeEquivalenceExpression returns ConstraintExpression:
	{AttributeEquivalenceExpression}
	'equal' '(' left=FeatureOfContextVariable ',' right=FeatureOfContextVariable ')'
;

FeatureOfContextVariable:
	context=ContextVariable ('.' feature=[ecore::EStructuralFeature|ValidID])
;

ContextVariable:
	(requiredMappingPath=RequiredMappingPathBase)? ('::' targetClass=[NamedEClass|ValidID])
;

RequiredMappingPathBase:
	(requiredMapping=[RequiredMapping|ValidID]) (tail=RequiredMappingPathTail)?
;

RequiredMappingPathTail:
	('.' requiredMapping=[RequiredMapping|ValidID] (tail=RequiredMappingPathTail)?)
;




// LITERALS from Xbase.xtext
ConstraintLiteral:
	ConstraintBooleanLiteral |
	ConstraintNullLiteral |
	ConstraintNumberLiteral |
	ConstraintStringLiteral
;

ConstraintBooleanLiteral returns ConstraintLiteral :
	{ConstraintBooleanLiteral} ('false' | isTrue?='true');

ConstraintNullLiteral returns ConstraintLiteral :
	{ConstraintNullLiteral} 'null';

ConstraintNumberLiteral returns ConstraintLiteral :
	{ConstraintNumberLiteral} value=Number;

ConstraintStringLiteral returns ConstraintLiteral:
	{ConstraintStringLiteral} value=STRING;