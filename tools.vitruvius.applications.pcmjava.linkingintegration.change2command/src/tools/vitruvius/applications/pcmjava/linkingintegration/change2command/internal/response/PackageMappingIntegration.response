import org.emftext.language.java.members.Method
import org.eclipse.emf.ecore.util.EcoreUtil
import org.emftext.language.java.members.Field
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.repository.RepositoryFactory
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.DataType
import org.emftext.language.java.modifiers.Public
import org.emftext.language.java.modifiers.Private
import org.emftext.language.java.modifiers.Protected
import com.google.common.collect.Sets
import tools.vitruvius.framework.correspondence.CorrespondenceModelUtil
import tools.vitruvius.framework.userinteraction.UserInteractionType
import tools.vitruvius.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

responses from metamodel java to metamodel pcm
called PackageMappingIntegration

//empty implementation for add and remove imports
response: AddImportResponse
trigger: insert in list java.JavaRoot[imports]
effect: execute:{
	
}

response: RemoveImportResponse
trigger: remove from list java.JavaRoot[imports]
effect: execute:{
	
}



response: RenameMethod
trigger: replace value java.Method[name]
check:{
	return true
}
match:
	retrieve required element: pcm.OperationSignature as operationSignature corresponding to change.affectedEObject
effect: execute: {
	operationSignature.entityName = change.newValue
	//EvaluationHelper.instance.logChange2ActionHandeldByIntegrationResponse(change, "renamed operation signature " + operationSignature + " to " + change.newValue) 
}

response: RemoveMethodEvent
trigger: remove from list java.ConcreteClassifier[members]
check: {
	if(change.oldValue instanceof Method){
		//EvaluationHelper.
		return true
	}	
	return false
} 
match:
	retrieve required element: pcm.OperationSignature as opSig corresponding to change.oldValue
effect:
	remove correspondence: opSig, change.oldValue
	execute:{
			EcoreUtil.remove(opSig)
	}

response: AddMethodEvent
trigger: insert in list java.ConcreteClassifier[members]
	check: change.newValue instanceof Method
match:
	retrieve required element: pcm.OperationInterface as opInterface corresponding to change.affectedEObject
effect:
	execute:{	
		callCreateOperationSignature(opInterface, change.newValue as Method)
		

	}

routine:CreateOperationSignature
input: pcm.OperationInterface as opInterface, java.Method as newMethod
effect:
	execute:{
		// ask user whether to add the new method to the operationInterface
		val selection = userInteracting.selectFromMessage(UserInteractionType.MODAL, "Should the new method " + 
			newMethod.name + " be part of the OperationInterface "+ opInterface.entityName+ "? " , "Yes", "No")
		if(selection == 0){
			var OperationSignature opSig = RepositoryFactory.eINSTANCE.createOperationSignature
			opSig.entityName = newMethod.name
			opSig.interface__OperationSignature = opInterface
			CorrespondenceModelUtil.createAndAddCorrespondence(correspondenceModel, opSig, newMethod)
		}
	}

response: CreateMetodParameterEvent
trigger: insert in list java.Method[parameters]
match:
	retrieve required element: pcm.OperationSignature as opSignature corresponding to change.affectedEObject
effect:
	add correspondence: opSignature, change.newValue
	execute:{
		userInteracting.showMessage(UserInteractionType.MODAL, "Created new parameter for OperationSiganture" + opSignature)
		val pcmParameter = RepositoryFactory.eINSTANCE.createParameter
		pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.
			getCorrespondingPCMDataTypeForTypeReference(change.newValue.typeReference, correspondenceModel,
				userInteracting, opSignature.interface__OperationSignature.repository__Interface, change.newValue.arrayDimension)
		pcmParameter.entityName = change.newValue.name
	}

response: MethodParameterNameChangeEvent
trigger: replace value java.Parameter[name]
match: 
	retrieve required element: pcm.Parameter as pcmParam corresponding to change.affectedEObject
effect:
	execute:{
		userInteracting.showMessage(UserInteractionType.MODAL, "Renamed method parameter " + change.oldValue +  " to " + change.newValue )
		pcmParam.entityName = change.newValue
	}
	
response: ChangeMethodTypeEvent
trigger: replace value java.Method[typeReference]
match: 
	retrieve required element: pcm.OperationSignature as opSignature corresponding to change.affectedEObject
effect:
	execute:{
		val Repository repo = opSignature.interface__OperationSignature.repository__Interface
		val DataType newReturnValue = TypeReferenceCorrespondenceHelper.
			getCorrespondingPCMDataTypeForTypeReference(change.newValue,
				correspondenceModel, userInteracting, repo, change.affectedEObject.arrayDimension)
		opSignature.returnType__OperationSignature = newReturnValue
		userInteracting.showMessage(UserInteractionType.MODAL, "Changed return type of opSig to " + newReturnValue)
	}
	
response: RemoveFieldEvent
trigger: remove from list java.ConcreteClassifier[members]
check: change.oldValue instanceof Field
match: 
	retrieve required element: pcm.NamedElement as nameElement corresponding to change.oldValue	
effect:
	remove correspondence: change.oldValue, nameElement
	execute:{
		userInteracting.showMessage(UserInteractionType.MODAL, "Removed " + nameElement + " because the corresponding field " + change.oldValue + " has been removed"  )
		EcoreUtil.remove(change.oldValue)
	}
	
response: AddFieldEvent
trigger: insert in list java.ConcreteClassifier[members]
check: change.newValue instanceof Field
match:
	retrieve required element: pcm.BasicComponent as basicComponent corresponding to change.affectedEObject
	retrieve required element: pcm.OperationInterface as opInterface corresponding to (change.newValue as Field).typeReference
effect:
	execute:{
		//new Field with PCM Type corresponding to an OperationInterface has been added in basic component --> created requrired role
		callCreateRequiredRole(basicComponent, opInterface, change.newValue as Field)
	}
	
routine: CreateRequiredRole
input: pcm.BasicComponent as basicComponent, pcm.OperationInterface as opInterface, java.Field as field
effect:
	create element: pcm.OperationRequiredRole as opRequiredRole
	add correspondence: opRequiredRole, field
	execute:{
		opRequiredRole.requiredInterface__OperationRequiredRole = opInterface
		opRequiredRole.requiringEntity_RequiredRole = basicComponent
		userInteracting.showMessage(UserInteractionType.MODAL, "Create OperationRequiredRole between Component " + 
			basicComponent.entityName + " and Interface " + opInterface.entityName)	
	}

response: ChangeFieldTypeEvent
trigger: replace value java.Field[typeReference]
match:
	retrieve optional element: pcm.OperationInterface as oldCorrespondingOpInterface corresponding to change.oldValue
	retrieve optional element: pcm.OperationInterface as opInterface corresponding to change.newValue
	retrieve optional element: pcm.OperationRequiredRole as opRequiredRole corresponding to change.affectedEObject
	retrieve required element: pcm.BasicComponent as basicComponent corresponding to change.affectedEObject.containingConcreteClassifier
effect:
	execute:{
		if(null != oldCorrespondingOpInterface && null != opInterface && null != opRequiredRole){
			// reset required role 
			userInteracting.showMessage(UserInteractionType.MODAL, "the operation required role has been changed")
			opRequiredRole.requiredInterface__OperationRequiredRole = opInterface
			return
		}
		if(null == oldCorrespondingOpInterface && null != opInterface){
			// new required role needs to be added 
			userInteracting.showMessage(UserInteractionType.MODAL, "Create OperationRequiredRole between Component " + 
				basicComponent.entityName + " and Interface " + opInterface.entityName)
			callCreateRequiredRole(basicComponent, opInterface, change.affectedEObject)
			return
		}
		if(null != oldCorrespondingOpInterface && null == opInterface && null != opRequiredRole){
			// remove required role and correspondence
			userInteracting.showMessage(UserInteractionType.MODAL, "Remove OperationRequiredRole between Component " + 
				basicComponent.entityName + " and Interface " + oldCorrespondingOpInterface.entityName)
			callRemoveRequiredRoleAndCorrespondence(opRequiredRole, change.affectedEObject)
		}
	}

routine: RemoveRequiredRoleAndCorrespondence
input: pcm.OperationRequiredRole as orr, java.Field as field
effect:
	remove correspondence: orr, field
	execute:{
		EcoreUtil.delete(orr)
	}

// empty implementation for changeFieldModifier, because the change is not architectural relevant
response: ChangeFieldModifierEvent
trigger: insert in list java.Field[annotationsAndModifiers]
effect:
	execute:{
		
	}

response: RemoveFieldModifierEvent
trigger: remove from list java.Field[annotationsAndModifiers]
effect:
	execute:{
		
	}
	
// if the method was public and had a corresponding opSig--> ask user whether to delete the correspondence
// if the method was non-public and is public now and the classifier has a corresponding interface 
//--> ask user whether to add the signature to the corresponding interface 
response: ChangeMethodModifierEvent
trigger: insert in list java.Method[annotationsAndModifiers]
match:
	retrieve optional element: pcm.OperationSignature as operationSignature corresponding to change.affectedEObject
	retrieve required element: pcm.OperationInterface as operationInterface corresponding to change.affectedEObject.containingConcreteClassifier
effect:
	execute:{
		if(change.newValue instanceof Public){ 
			//new public method created	
			callCreateOperationSignature(operationInterface, change.affectedEObject)
			return
		}else if(null!=operationSignature &&(change.newValue instanceof Protected||change.newValue instanceof Private)){		
			// public method with corresponding signature has been deleted
			userInteracting.showMessage(UserInteractionType.MODAL, "Public method with correspondence has been made private. 
				The corresponding operaitonSignature " + operationSignature.entityName + " will be deleted as well.")
			correspondenceModel.removeCorrespondencesThatInvolveAtLeastAndDependend(Sets.newHashSet(operationSignature))
			EcoreUtil.remove(operationSignature)
			return
		}
	}
	