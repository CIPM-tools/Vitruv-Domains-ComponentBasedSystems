import http://www.topcased.org/2.0/sysML as sysML
import http://edu.kit.ipd.sdq.smlnk/1.0 as smlnk
import http://www.eclipse.org/uml2/4.0.0/UML as uml

map sysML::View to model:smlnk::Model {
	with name:String to name:String
	// In the ETL transformations the sysml2simulink direction uses all blocks of all viewpoints as parts of a model, whereas the backward direction simulink2sysml creates a single viewpoint that has the same name as the model and adds all blocks to this single viewpoint 
	// packagedElements is typed uml::PackageableElement but we restrict the mapping to sysML::Viewpoint
	with packagedElements:Viewpoint to model { // this is a nested mapping to an element of parent mapping
		// If somebody would add a second viewpoint that has the same name as the view to a view, what should we do in simulink? Add another model? Use the same model as for the same viewpoint? Both would cause problems. Therefore, we forbid it.
		// We could also do this with a separate invariant but the special keyword "once" makes things less redundant
		when once name = model.name
		// Viewpoint extends Class and Class has nestedClassifier reference
		// nestedClassifier is typed uml::Classifier but we restrict the mapping to sysML::Block
		// the conqat parser calls systems blocks in simulink: systems that are parts of a model in simNG are subBlocks of the model block for the conqat parser
		with nestedClassifier:Block to subBlocks:Block
	}
}
// how would this look like if we would write the mapping with switched sides (model to view)?

// Do we need this as separate mapping or could it be inlined where the nestedClassifier reference is mapped to the subBlocks reference?
map sysML::Block to smlnk::Block {
	with name:String to name:String
	// Block extends Class extends EncapsulatedClassifier extends StructuredClassifier has ownedAttribute
	// ownedAttribute is typed uml::Property but we restrict the mapping to 
	with ownedAttributes:FlowPort as flowPort to inPorts:InPort {
		when flowPort.direction = FlowDirection::in
		// simNG has names for ports, the conqast parser only has an index that "may be a number or a string like 'enable' indicating a special port", and the online simulink reference mentions ports only briefly but the example shows that ports can have names
		// it remains to be checked whether the conqast parser puts these names in the index field or how he stores the port names
		with name:String to name:String
	}
	with ownedAttributes:FlowPort as flowPort to outPorts:OutPort {
		when flowPort.direction = FlowDirection::out
		with name:String to name:String
	}
}

// LINES / CONNECTORS ARE NOT TRANSFORMED IN THE ETL TRANSFORMATIONS
