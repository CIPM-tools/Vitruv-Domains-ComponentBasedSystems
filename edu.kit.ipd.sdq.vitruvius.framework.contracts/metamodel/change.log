+ AdditiveChange
+ SubtractiveChange
+ AdditiveAttributeChange
+ SubtractiveAttributeChange
+ AdditiveReferenceChange
+ SubtractiveReferenceChange

!~ EFeatureChange.newAffectedEObject -> affectedEObject
- EFeatureChange.oldAffectedEObject
+ EFeatureChange.oldTUIDOfAffectedEObject:TUID
+ UpdateEFeature extends EChange
- UnsetEFeature
- UnsetEAttribute
- UnsetERefernce
      - UnsetEAttribute.oldValue
      + UnsetEAttribute extends SubtractiveAttributeChange
      - UnsetERefernce.oldValue
      + UnsetERefernce extends SubtractiveReferenceChange
- UnsetContainmentEReference
- UnsetNonContainmentEReference
      + UnsetEReference.isContainment():bool

- EObjectChange.T

- object pkg
- EObjectChange
- CreateEObject
	~ CreateEObject.isAbstract -> false
	+ CreateEObject extends AdditiveReferenceChange
- DeleteEObject
	~ DeleteEObject.isAbstract -> false
	+ DeleteEObject extends SubtractiveReferenceChange
- ReplaceEObject
+ root Pkg
+ InsertRootEObject
+ RemoveRootEObject
- CreateRootEObject
	- CreateRootEObject.newValue
	+ CreateRootEObject extends InsertRootEObject
- DeleteRootEObject
	- DeleteRootEObject.oldValue
	+ DeleteRootEObject extends RemoveRootEObject
- ReplaceRootEObject
	- ReplaceRootEObject.newValue
	- ReplaceRootEObject.oldValue
	+ ReplaceRootEObject extends DeleteERootObject, CreateRootEObject, 

+ pkg compound
+ CompoundChange
	+ CreateEObjectAndAdd
	+ DeleteEObjectAndSubtract
	+ DeleteEObjectCreateEObject
	+ DeleteEObjectCreateEObjectAndReplaceSingle
	+ DeleteEObjectCreateEObjectAndReplaceInList
+ MoveEObject
+ ReplaceInEList
+ ExplicitUnsetEFeature


- InsertInEList.newValue
  + InsertInEList extends AdditiveChange
- RemoveFromEList.oldValue
  + RemoveFromEList extends SubtractiveChange
- ReplaceInEList
	- ReplaceInEList.newValue
	- ReplaceInEList.oldValue
	- ReplaceInEList extends UpdateMultiValuedEFeature
	+ ReplaceInEList extends RemoveFromEList, InsertInEList
~ PermuteEList.newIndexForElementAt:EIntegerObject -> EInt
~ PermuteEList.newIndexForElementAt.upperBound -1 -> 1

!~ UpdateSingleValuedEAttribute -> ReplaceSingleValuedEAttribute
- UpdateSingleValuedEAttribute.oldValue
- UpdateSingleValuedEAttribute.newValue
+ UpdateSingleValuedEAttribute extends AdditiveAttributeChange
+ UpdateSingleValuedEAttribute extends SubtractiveAttributeChange
+ InsertEAttributeValue extends AdditiveAttributeChange
+ RemoveEAttributeValue extends SubtractiveAttributeChange
- ReplaceEAttributeValue
	- ReplaceEAttributeValue extends ReplaceInEList, UpdateEAttribute
	+ ReplaceEAttributeValue extends RemoveEAttributeValue, InsertEAttributeValue, ReplaciveAttributeChange

+ UpdateEReference.isContainment():bool
- UpdateNonContainmentEReference
# jedes extends UpdateNonContainmentEReference durch extends UpdateEReference ersetzt
~ UpdateSingleValuedNonContainmentEReference -> ReplaceSingleValuedEReference
- ReplaceSingleValuedEReference.oldValue
- ReplaceSingleValuedEReference.newValue
+ ReplaceSingleValuedEReference extends AdditiveReferenceChange
+ ReplaceSingleValuedEReference extends SubtractiveReferenceChange
~ InsertNonContainmentEReference -> InsertEReference
+ InsertEReference extends AdditiveReferenceChange
~ RemoveNonContainmentEReference -> RemoveEReference
+ RemoveEReference extends SubtractiveReferenceChange
- ReplaceEReference
	~ ReplaceNonContainmentEReference -> ReplaceEReference
	- ReplaceEReference extends ReplaceInEList, UpdateEReference
	+ ReplaceEReference extends ReplaciveReferenceChange
~ PermuteNonContainmentEReferenceValues -> PermuteEReferenceValues

- pkg containment
	~ UpdateSingleValuedContainmentEReference -> ReplaceSingleValuedContainmentEReference
	- ReplaceSingleValuedContainmentEReference extends UpdateSingleValuedEAttribute, UpdateContainmentEReference
	+ ReplaceSingleValuedContainmentEReference extends ReplaceSingleValuedEReference
	~ CreateNonRootEObjectSingle -> CreateNonRootEObject
	- CreateNonRootEObject.newValue
	~ DeleteNonRootEObjectSingle -> DeleteNonRootEObject
	- DeleteNonRootEObject.oldValue
	~ ReplaceNonRootEObjectSingle -> ReplaceNonRootEObject
	- ReplaceNonRootEObject.oldValue
	- ReplaceNonRootEObject.newValue
	- ReplaceNonRootEObject extends ReplaceSingleValuedContainmentEReference
	+ ReplaceNonRootEObject extends DeleteNonRootEObject, CreateNonRootEObject
	- InsertNonRootEObjectInContainmentList extends InsertInEList, UpdateContainmentEReference
	+ InsertNonRootEObjectInContainmentList extends InsertEReference
	- RemoveNonRootEObjectInContainmentList extends RemoveInEList, UpdateContainmentEReference
	+ RemoveNonRootEObjectInContainmentList extends RemoveEReference
	- CreateNonRootEObjectInList extends InsertInEList, UpdateContainmentEReference
	+ CreateNonRootEObjectInList extends InsertNonRootEObjectInContainmentList
	- DeleteNonRootEObjectInList extends DeleteInEList, UpdateContainmentEReference
	+ DeleteNonRootEObjectInList extends RemoveNonRootEObjectInContainmentList
	- ReplaceNonRootEObjectInList extends ReplaceInEList, UpdateContainmentEReference
	+ ReplaceNonRootEObjectInList extends ReplaceEReference
	- PermuteContainmentEReferenceValues
	- UpdateContainmentEReference

-----------------------------------------

== unset ==
* ohne unser change mm kann man für den Fall dass für eine EStructuralFeature unsettable nicht auf true gesetzt wurde ein [http://download.eclipse.org/modeling/emf/emf/javadoc/2.4.2/org/eclipse/emf/ecore/EObject.html#eSet%28org.eclipse.emf.ecore.EStructuralFeature,%20java.lang.Object%29 eSet(defaultValue)] nicht von einem [http://download.eclipse.org/modeling/emf/emf/javadoc/2.4.2/org/eclipse/emf/ecore/EObject.html#eUnset%28org.eclipse.emf.ecore.EStructuralFeature%29 eUnset()] unterscheiden (durch aufrufen von [http://download.eclipse.org/modeling/emf/emf/javadoc/2.4.2/org/eclipse/emf/ecore/EObject.html#eIsSet%28org.eclipse.emf.ecore.EStructuralFeature%29 eIsSet()])
* mit unserem change mm hat man die Möglichkeit unabhängig von unsettable auf ein eUnset anders als auf ein eSet(defaultValue) zu reagieren (oder sich dafür zu entscheiden dies nicht zu tun)

== umschiffte Probleme ==
* InsertInEList und RemoveFromEList können doch nicht vom allgemeinen AdditiveChange und SubtractiveChange erben, dass ist aber kein Problem da alle unterklassen von InsertInEList schon von einer Unterklasse von AdditiveChange erben und analog für Remove und Subtract
* Ich habe ReplaceAttributeInEList und ReplaceReferenceInEList nicht unterschieden da letzteres nicht von ReplaciveReferenceChange erben kann um replaceChange in DeleteEObjectCreateEObjectAndReplace typen zu können. Daher musste ich zwei Versionen von DeleteEObjectCreateEObjectAndReplaceInList zu erstellen.
* ExplicitUnsetEFeature erbt nicht von EFeatureChange da alle Informationen zum feature in den enthaltenen subtractiveChanges enthalten sind und ExplicitUnsetEFeature ansonsten atomic und compound zugleich wäre
* wir können den TypParameter-für-AtomicChanges-Trick nicht bei Move anwenden da InsertRoot und RemoveRoot nicht auch von EFeatureChange erben

== Verwendung des change mm ==
* auf jeden Fall bei der Reaktion von unten nach oben in der Vererbungshierarchie reagieren
* es gibt kein InsertWithoutCreate sondern wenn man dass behandeln will muss man prüfen ob es keine Instanz von Create... ist

== Alternativen für Informationen über gelöschte Objekte ==

* drei Möglichkeiten Informationen über gelöschte Objekte zur Verfügung zu stellen
*# verworfen: TUIDCalculatorAndResolver aus einer ID ohne Speicherbedarf den Wert eines Features das in die TUID eingeflossen ist berechnen lassen
*#* dann muss die Objekt->TUID-Abbildung rechtseindeutig sein
*#* geht nicht für Features die nicht in die TUID eingeflossen sind
*#* verkompliziert jeden TUIDCalculatorAndResolver
*# verworfen: VSUM eine Map von TUID und FeatureName auf alten Wert vorhalten lassen
*#* benötigt Speicher
*#* geht immer nur für Werte des letzten Objektes mit einer TUID
*# gewählt: direkt im SubtractiveReferenceChange eine Map von FeatureName auf alten Wert
*#* wenn der Change weggeworfen wird werden automatisch die alten Werte vergessen
*#* erlaubt es für mehre Löschungen von Objekten mit gleicher TUID unterschiedliche Werte zu erhalten
*#* unabhängig vom TUIDCalculatorAndResolver

== find right metaclass algorithm ==
=== for free ===
* durch das feature ergibt sich automatisch (daher im algorithmus eingeklammert)
** attribute oder reference (und dann ob containment)
** single oder multi
** root oder nicht (parent null oder nicht)
=== to ask ===
* atomic
** object
*** create - done
*** delete - done
** feature
*** unset - done
*** update
**** (single) replace (attribute or reference) - done
**** (multi) 
***** insert (attribute or reference) - done
***** remove (attribute or reference) - done
***** permute (attribute or reference) - done
* compound
** move - done
** replace in list - done
** unset - done
