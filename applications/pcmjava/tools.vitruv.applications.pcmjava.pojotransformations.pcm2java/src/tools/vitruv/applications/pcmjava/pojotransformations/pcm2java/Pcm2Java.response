import org.eclipse.emf.ecore.util.EcoreUtil
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import com.google.common.collect.Sets
import org.emftext.language.java.statements.ExpressionStatement
import org.emftext.language.java.expressions.AssignmentExpression
import org.emftext.language.java.references.SelfReference
import org.emftext.language.java.references.IdentifierReference
import org.emftext.language.java.statements.Statement
import java.util.Set
import java.util.HashSet
import java.util.ArrayList
import java.util.LinkedList
import java.util.Vector
import java.util.Stack
import java.util.List
import tools.vitruv.framework.userinteraction.UserInteractionType
import org.emftext.language.java.generics.GenericsFactory
import static extension tools.vitruv.applications.pcmjava.pojotransformations.pcm2java.Pcm2JavaHelper.*
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.emftext.language.java.types.TypeReference
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.emftext.language.java.types.PrimitiveType
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.members.Field
import org.emftext.language.java.parameters.Parameter

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

responses from metamodel pcm to metamodel java
called pcm2java

// ###################################################
// ################ PACKAGE RESPONSES ################


response: CreatedRepository
trigger: created root pcm.Repository
effect:
	execute: {
		val repository = change.newValue;
		callCreateJavaPackage(repository, null, repository.entityName, "repository_root");
		callCreateRepositorySubPackages(repository);
	}

routine: CreateRepositorySubPackages(pcm.Repository repository)
match:
	retrieve required element: java.Package as repositoryPackage corresponding to repository
effect:
	execute: {
		callCreateJavaPackage(repository, repositoryPackage, "datatypes", "datatypes");
		callCreateJavaPackage(repository, repositoryPackage, "contracts", "contracts");
	}

response: RenamedRepository
trigger: replaced value pcm.Repository[entityName]
match:
	retrieve required element: java.Package as rootPackage corresponding to change.affectedEObject
		tagged with "repository_root"
effect: 
	execute: {
		val repository = change.affectedEObject;
		rootPackage.name = change.newValue;
		callRenameJavaPackage(repository, rootPackage, "contracts", "contracts");
		callRenameJavaPackage(repository, rootPackage, "datatypes", "datatypes");	
		for (component : repository.components__Repository.filter(BasicComponent)) {
			callRenameComponentPackageAndClass(component);
		}
		for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
			callRenameInterface(interface);
		}
		for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
			callRenameCompositeDataType(dataType);
		}
		for (dataType : repository.dataTypes__Repository.filter(CollectionDataType)) {
			callRenameCollectionDataType(dataType);
		}
		persistProjectRelative(change.affectedEObject, rootPackage, buildJavaFilePath(rootPackage));
	}



// ################################################################################
// ############################# COMPOSED STRUCTURES ##############################

response: CreatedSystem
trigger: created root pcm.System
effect: execute: {
	val system = change.newValue;
	callCreateJavaPackage(system, null, system.entityName, "root_system");
	callCreateImplementationForSystem(system);
}

routine: CreateImplementationForSystem(pcm.System system)
match:
	retrieve required element: java.Package as systemPackage corresponding to system
effect: 
	execute: callCreateJavaClass(system, systemPackage, system.entityName + "Impl")

response: DeletedSystem
trigger: deleted root pcm.System
effect: execute: {
	val system = change.oldValue;
	callDeleteJavaPackage(system, system.entityName, "root_system");
	callDeleteJavaClassifier(system);
}

response: ChangedSystemName
trigger: replaced value pcm.System[entityName]
match:
	retrieve required element: java.Package as systemPackage corresponding to change.affectedEObject
effect: 
	execute: {
		val system = change.affectedEObject;
		callRenameJavaPackage(system, null, system.entityName, null);
		callRenameJavaClassifier(system, systemPackage, system.entityName + "Impl");
	}

response: AddedAssemblyContextToComposedStructure
trigger: inserted into list pcm.ComposedStructure[assemblyContexts__ComposedStructure]
match:
	retrieve required element: java.Class as compositeComponentJavaClass corresponding to change.affectedEObject
	retrieve required element: java.Class as encapsulatedComponentJavaClass corresponding to change.newValue.encapsulatedComponent__AssemblyContext
effect:
	create element: java.Field as assemblyContextField
	create element: java.NewConstructorCall as newConstructorCall
	create element: java.ClassifierImport as contextClassImport
	create element: java.Constructor as constructor
	add correspondence: assemblyContextField, change.newValue
	add correspondence: newConstructorCall, change.newValue
	add correspondence: contextClassImport, change.newValue
	add correspondence: constructor, change.newValue
	execute: {
		val assemblyContext = change.newValue;
		val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
		createPrivateField(assemblyContextField, typeRef, assemblyContext.entityName);
		compositeComponentJavaClass.members += assemblyContextField;
		addConstructorToClass(constructor, compositeComponentJavaClass)
		addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
		createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
	}

// #####################################################
// ################ COMPONENT RESPONSES ################

response: CreatedComponent
trigger: inserted into list pcm.Repository[components__Repository]
match:
	retrieve required element: java.Package as repositoryPackage corresponding to change.newValue.repository__RepositoryComponent
		tagged with "repository_root"
effect: 
	execute: {
		val component = change.newValue;
		callCreateJavaPackage(component, repositoryPackage, component.entityName, null);
		callCreateImplementationForComponent(component);
	}

routine: CreateImplementationForComponent(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as componentPackage corresponding to component
effect: 
	execute: callCreateJavaClass(component, componentPackage, component.entityName + "Impl")

response: RenameComponent
trigger: replaced value pcm.RepositoryComponent[entityName]
effect: 
	execute: {
		val component = change.affectedEObject;
		callRenameComponentPackageAndClass(component);
	}

routine: RenameComponentPackageAndClass(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as repositoryPackage corresponding to component.repository__RepositoryComponent
		with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
effect: 
	execute: {
		callRenameJavaPackage(component, repositoryPackage, component.entityName, null);
		callRenameComponentClass(component);
	}

routine: RenameComponentClass(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as componentPackage corresponding to component
effect: 
	execute: callRenameJavaClassifier(component, componentPackage, component.entityName + "Impl")

response: DeletedComponent
trigger: removed from list pcm.Repository[components__Repository]
effect: 
	execute: {
		callDeleteJavaPackage(change.oldValue, change.oldValue.entityName, "")
		callDeleteJavaClassifier(change.oldValue)
	}


// #####################################################
// ################ INTERFACE RESPONSES ################

response: CreatedInterface
trigger: inserted into list pcm.Repository[interfaces__Repository]
match:
	retrieve required element: java.Package as contractsPackage corresponding to change.affectedEObject
		with contractsPackage.name == "contracts"
effect: 
	execute: {
		val interf = change.newValue;
		callCreateJavaInterface(interf, contractsPackage, interf.entityName);
	}

response: RenamedInterface
trigger: replaced value pcm.Interface[entityName]
effect: 
	execute: callRenameInterface(change.affectedEObject as OperationInterface)

routine: RenameInterface(pcm.OperationInterface interf)
match:
	retrieve required element: java.Package as contractsPackage corresponding to interf.repository__Interface
		with contractsPackage.name == "contracts"
effect: 
	execute: callRenameJavaClassifier(interf, contractsPackage, interf.entityName)


// ######################################################
// ################ DATA TYPES RESPONSES ################

response: CreatedCompositeDataType
trigger: inserted into list pcm.Repository[dataTypes__Repository]
	check: change.newValue instanceof CompositeDataType
match:
	retrieve required element: java.Package as datatypesPackage corresponding to change.affectedEObject with datatypesPackage.name == "datatypes"
effect: 
	execute: {
		val compositeDataType = change.newValue as CompositeDataType;
		callCreateJavaClass(compositeDataType, datatypesPackage, compositeDataType.entityName);
	}

response: RenamedCompositeDataType
trigger: replaced value pcm.CompositeDataType[entityName]
effect: 
	execute: callRenameCompositeDataType(change.affectedEObject)

routine: RenameCompositeDataType(pcm.CompositeDataType compositeDataType)
match:
	retrieve required element: java.Package as datatypesPackage corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
effect: 
	execute: callRenameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)

response: DeletedCompositeDataType
trigger: removed from list pcm.Repository[dataTypes__Repository]
	check: change.oldValue instanceof CompositeDataType
effect: 
	execute: callDeleteJavaClassifier(change.oldValue as CompositeDataType)

response: CreatedCollectionDataType
trigger: inserted into list pcm.Repository[dataTypes__Repository]
	check: change.newValue instanceof CollectionDataType
match:
	retrieve optional element: java.Class as innerTypeClass corresponding to (change.newValue as CollectionDataType).innerType_CollectionDataType
	retrieve required element: java.Package as datatypesPackage corresponding to change.affectedEObject with datatypesPackage.name == "datatypes"
effect:
	execute: {
		// create correct (and in case of primitive types wrapped) type reference for the inner type
		val dataType = change.newValue as CollectionDataType;
		val innerTypeRef = createTypeReference(dataType.innerType_CollectionDataType, innerTypeClass);
		var innerTypeClassOrWrapper = innerTypeRef;
		if (innerTypeRef instanceof PrimitiveType) {
			innerTypeClassOrWrapper = getWrapperTypeReferenceForPrimitiveType(innerTypeRef);
		}
		
		// Let user select the class to map the collection type to
		var Set<Class<?>> collectionDataTypes = new HashSet
		collectionDataTypes += #[ArrayList, LinkedList, Vector, Stack, HashSet]
		val List<String> collectionDataTypeNames = new ArrayList<String>(collectionDataTypes.size)
		for (collectionDataType : collectionDataTypes) {
			collectionDataTypeNames.add(collectionDataType.name)
		}
		val String selectTypeMsg = "Please select type (or interface) that should be used for the type"
		val int selectedType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectTypeMsg,
			collectionDataTypeNames)
		val Class<?> selectedClass = collectionDataTypes.get(selectedType)
	
		callCreateJavaClass(dataType, datatypesPackage, dataType.entityName);
		callAddSuperTypeToDataType(dataType, innerTypeClassOrWrapper, selectedClass.name);
	}

routine: AddSuperTypeToDataType(pcm.DataType dataType, java.TypeReference innerTypeReference, String superTypeQualifiedName)
match:
	retrieve required element: java.Class as dataTypeImplementation corresponding to dataType
	retrieve required element: java.CompilationUnit as dataTypeImplementationCU corresponding to dataType
effect: 
	create element: java.NamespaceClassifierReference as namespaceClassifier
	add correspondence: namespaceClassifier, dataType
	execute: {
		val collectionTypeClassImport = getJavaClassImport(superTypeQualifiedName);
		dataTypeImplementationCU.imports += collectionTypeClassImport;
		createNamespaceClassifierReference(namespaceClassifier, collectionTypeClassImport.classifier);
		val qualifiedTypeArgument = GenericsFactory.eINSTANCE.createQualifiedTypeArgument();
		qualifiedTypeArgument.typeReference = innerTypeReference;
		namespaceClassifier.classifierReferences.get(0).typeArguments += qualifiedTypeArgument;
		dataTypeImplementation.extends = namespaceClassifier;
	}

response: RenamedCollectionDataType
trigger: replaced value pcm.CollectionDataType[entityName]
effect: 
	execute: callRenameCollectionDataType(change.affectedEObject)

routine: RenameCollectionDataType(pcm.CollectionDataType collectionDataType)
match:
	retrieve required element: java.Package as datatypesPackage corresponding to collectionDataType.repository__DataType with datatypesPackage.name == "datatypes"
effect: 
	execute: callRenameJavaClassifier(collectionDataType, datatypesPackage, collectionDataType.entityName)

response: DeletedCollectionDataType
trigger: removed from list pcm.Repository[dataTypes__Repository]
	check: change.oldValue instanceof CollectionDataType
effect: 
	execute: callDeleteJavaClassifier(change.oldValue as CollectionDataType)


// ################ DATA TYPES - INNER DECLARATION RESPONSES ################

response: CreatedInnerDeclaration
trigger: inserted into list pcm.CompositeDataType[innerDeclaration_CompositeDataType]
match:
	retrieve optional element: java.Class as nonPrimitiveInnerDataTypeClass corresponding to change.newValue.datatype_InnerDeclaration
effect: 
	execute: {
		val innerDataTypeReference = createTypeReference(change.newValue.datatype_InnerDeclaration, nonPrimitiveInnerDataTypeClass);
		val compositeDataType = change.affectedEObject;
		val innerDeclaration = change.newValue;
		callAddInnerDeclarationToCompositeDataType(compositeDataType, innerDeclaration, innerDataTypeReference);
	}

routine: AddInnerDeclarationToCompositeDataType(pcm.CompositeDataType compositeDataType, pcm.InnerDeclaration innerDeclaration, java.TypeReference dataTypeReference)
match:
	retrieve required element: java.Class as dataTypeClass corresponding to compositeDataType
effect: 
	create element: java.Field as innerDataTypeField
	create element: java.ClassMethod as getterMethod
	create element: java.ClassMethod as setterMethod
	add correspondence: innerDataTypeField, innerDeclaration
	add correspondence: getterMethod, innerDeclaration tag with "getter"
	add correspondence: setterMethod, innerDeclaration tag with "setter"
	execute: {
		createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);
		createSetter(innerDataTypeField, setterMethod);
		createGetter(innerDataTypeField, getterMethod);
		dataTypeClass.members += innerDataTypeField;
		dataTypeClass.members += getterMethod;
		dataTypeClass.members += setterMethod;
		sortMembers(dataTypeClass.members);
	}

response: RenameInnerDeclaration
trigger: replaced value pcm.InnerDeclaration[entityName]
match:
	retrieve required element: java.Field as compositeTypeField corresponding to change.affectedEObject
	retrieve required element: java.ClassMethod as compositeTypeGetterMethod corresponding to change.affectedEObject tagged with "getter"
	retrieve required element: java.ClassMethod as compositeTypeSetterMethod corresponding to change.affectedEObject tagged with "setter"
effect: 
	execute: {
		val newName = change.newValue;
		compositeTypeField.name = newName;
		compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
		if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
			val parameter = compositeTypeSetterMethod.parameters.get(0)
			parameter.name = "set" + newName.toFirstUpper;
		}
	}

response: ChangeTypeOfInnerDeclaration
trigger: replaced value pcm.InnerDeclaration[datatype_InnerDeclaration]
match:
	retrieve optional element: java.Class as newJavaDataType corresponding to change.newValue
effect: 
	execute: {
		val innerDeclaration = change.affectedEObject;
		val newDataTypeReference = createTypeReference(change.newValue, newJavaDataType);
		callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
	}

routine: ChangeInnerDeclarationType(pcm.InnerDeclaration innerDeclaration, java.TypeReference newTypeReference)
match:
	retrieve required element: java.Field as compositeTypeField corresponding to innerDeclaration
	retrieve required element: java.Method as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
	retrieve required element: java.Method as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
effect: 
	execute: {
		compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
		compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
		if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
			val parameter = compositeTypeSetterMethod.parameters.get(0)
			parameter.typeReference = EcoreUtil.copy(newTypeReference)
		}
	}


// ######################################################
// ################ JAVA PACKAGE EFFECTS ################

routine: CreateJavaPackage(EObject sourceElementMappedToPackage, java.Package parentPackage, String packageName, String newTag)
match:
	require absence of element: java.Package corresponding to sourceElementMappedToPackage tagged with newTag
effect: 
	create element: java.Package as javaPackage
	add correspondence: javaPackage, sourceElementMappedToPackage
		tag with newTag //persist as root at project-relative location: buildJavaFilePath(javaPackage)
	execute: {
		if (parentPackage != null) {
			javaPackage.namespaces += parentPackage.namespaces;
			javaPackage.namespaces += parentPackage.name; 
		}
		javaPackage.name = packageName;
		persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
	}

routine: RenameJavaPackage(pcm.NamedElement sourceElementMappedToPackage, java.Package parentPackage, String packageName, String expectedTag)
match:
	retrieve required element: java.Package as javaPackage corresponding to sourceElementMappedToPackage
		tagged with expectedTag	//move containing model to project-relative location: buildJavaFilePath(javaPackage)
effect: 
	execute: {
		javaPackage.namespaces.clear();
		if (parentPackage != null) {
			javaPackage.namespaces += parentPackage.namespaces;
			javaPackage.namespaces += parentPackage.name; 
		}
		javaPackage.name = packageName;
		persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
	}

routine: DeleteJavaPackage(pcm.NamedElement sourceElementMappedToPackage, String packageName, String expectedTag)
match:
	retrieve required element: java.Package as javaPackage corresponding to sourceElementMappedToPackage tagged with expectedTag
effect: 
	delete element: javaPackage


// ######################################################
// ################ JAVA CLASS EFFECTS ##################

routine: CreateJavaClass(pcm.NamedElement sourceElementMappedToClass, java.Package containingPackage, String className)
effect: 
	create element: java.Class as javaClass
	add correspondence: javaClass, sourceElementMappedToClass
	execute: {
		javaClass.name = className;
		javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		callCreateCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage);
	}

routine: CreateJavaInterface(pcm.NamedElement sourceElementMappedToClass, java.Package containingPackage, String className)
effect: 
	create element: java.Interface as javaInterface
	add correspondence: javaInterface, sourceElementMappedToClass
	execute: {
		javaInterface.name = className;
		javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		callCreateCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage);
	}

routine: CreateCompilationUnit(pcm.NamedElement sourceElementMappedToClass, java.ConcreteClassifier classifier, java.Package containingPackage)
effect: 
	create element:  java.CompilationUnit as compilationUnit
	add correspondence: compilationUnit, sourceElementMappedToClass
		//persist as root at project-relative location: buildJavaFilePath(compilationUnit)
	execute: {
		compilationUnit.namespaces += containingPackage.namespaces;
		compilationUnit.namespaces += containingPackage.name;
		compilationUnit.name = classifier.name;
		compilationUnit.classifiers.add(classifier);
		persistProjectRelative(sourceElementMappedToClass, compilationUnit, buildJavaFilePath(compilationUnit));
	}

routine: RenameJavaClassifier(pcm.NamedElement classSourceElement, java.Package containingPackage, String className)
match:
	retrieve required element: java.CompilationUnit as compilationUnit corresponding to classSourceElement
		//move containing model to project-relative location: buildJavaFilePath(compilationUnit)
	retrieve required element: java.ConcreteClassifier as javaClassifier corresponding to classSourceElement
effect: 
	execute: {
		javaClassifier.name = className;
		compilationUnit.name = className;
		compilationUnit.namespaces.clear;
		compilationUnit.namespaces += containingPackage.namespaces;
		compilationUnit.namespaces += containingPackage.name;
		persistProjectRelative(classSourceElement, compilationUnit, buildJavaFilePath(compilationUnit));
	}

routine: DeleteJavaClassifier(pcm.NamedElement sourceElement)
match:
	retrieve required element: java.ConcreteClassifier as javaClassifier corresponding to sourceElement
	retrieve required element: java.CompilationUnit as compilationUnit corresponding to sourceElement
effect: 
	delete element: javaClassifier
	delete element: compilationUnit


// ####################################################
// ################ PROVIDED ROLES ####################

response: CreatedProvidedRole
trigger: inserted into list pcm.InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	check: change.newValue instanceof OperationProvidedRole
effect: execute: callAddProvidedRole(change.newValue as OperationProvidedRole)

routine: AddProvidedRole(pcm.OperationProvidedRole providedRole)
match:
	retrieve required element: java.Interface as operationProvidingInterface corresponding to providedRole.providedInterface__OperationProvidedRole
	retrieve required element: java.Class as javaClass corresponding to providedRole.providingEntity_ProvidedRole
effect: 
	create element: java.ClassifierImport as interfaceImport
	create element: java.NamespaceClassifierReference as namespaceClassifierReference
	add correspondence: interfaceImport, providedRole
	add correspondence: namespaceClassifierReference,  providedRole
	execute: {
		createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
		javaClass.implements.add(namespaceClassifierReference)
		addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
	}

response: ChangedProvidedInterfaceOfProvidedRole
trigger: replaced value pcm.OperationProvidedRole[providedInterface__OperationProvidedRole]
effect: 
	execute: {
		val operationProvidedRole = change.affectedEObject;
		callRemoveProvidedRole(operationProvidedRole);
		callAddProvidedRole(operationProvidedRole);
	}

response: ChangedProvidingEntityOfProvidedRole
trigger: replaced value pcm.OperationProvidedRole[providingEntity_ProvidedRole]
effect: 
	execute: {
		val operationProvidedRole = change.affectedEObject;	
		callRemoveProvidedRole(operationProvidedRole);
		callAddProvidedRole(operationProvidedRole);
	}

response: DeletedProvidedRoleFromSystem
trigger: removed from list pcm.System[providedRoles_InterfaceProvidingEntity]
effect: 
	execute: callRemoveProvidedRole(change.oldValue)

response: DeletedProvidedRoleFromComponent
trigger: removed from list pcm.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
effect: 
	execute: callRemoveProvidedRole(change.oldValue)

routine: RemoveProvidedRole(pcm.ProvidedRole providedRole)
match:
	retrieve required element: java.ClassifierImport as requiredInterfaceImport corresponding to providedRole
	retrieve required element: java.NamespaceClassifierReference as namespaceClassifierReference corresponding to providedRole
effect: 
	delete element: requiredInterfaceImport
	delete element: namespaceClassifierReference

// ####################################################
// ################ REQUIRED ROLES ####################

// TODO HK implement ctor statement as correspondence (dynamic in explicit effect for each ctor) to remove them easily
// Use as example for responses best practices chapter
// TODO HK Implement rename correctly when having all four correspondences correctly 
response: CreatedRequiredRole
trigger: inserted into list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	check: change.newValue instanceof OperationRequiredRole
effect: 
	execute: callAddRequiredRole(change.newValue as OperationRequiredRole)

routine: AddRequiredRole(pcm.OperationRequiredRole requiredRole)
match:
	retrieve required element: java.Interface as requiredInterface corresponding to requiredRole.requiredInterface__OperationRequiredRole
	retrieve required element: java.Class as javaClass corresponding to requiredRole.requiringEntity_RequiredRole
effect: 
	create element: java.ClassifierImport as requiredInterfaceImport
	create element: java.Field as requiredInterfaceField
	add correspondence: requiredInterfaceImport, requiredRole
	add correspondence: requiredInterfaceField, requiredRole
	execute: {
		val typeRef = createNamespaceClassifierReference(requiredInterface);
		addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
		val requiredRoleName = requiredRole.entityName;
		createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
		javaClass.members += requiredInterfaceField;
		if (javaClass.members.filter(typeof(Constructor)).nullOrEmpty) {
			addConstructorToClass(javaClass)
		}
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			callAddParameterAndAssignmentToConstructor(requiredRole, ctor, typeRef, requiredInterfaceField, requiredRoleName);
		}
	}

routine: AddParameterAndAssignmentToConstructor(pcm.NamedElement parameterCorrespondenceSource, java.Constructor constructor, 
	java.NamespaceClassifierReference typeReference, java.Field fieldToBeAssigned, String parameterName)
effect: 
	create element: java.OrdinaryParameter as newParameter
	add correspondence: newParameter, parameterCorrespondenceSource
	execute: {
		newParameter.name = parameterName;
		newParameter.typeReference = EcoreUtil.copy(typeReference);
		constructor.parameters.add(newParameter)
		val asssignment = createAssignmentFromParameterToField(fieldToBeAssigned, newParameter);
		constructor.statements.add(asssignment)
	}


response: DeletedRequiredRole
trigger: removed from list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	check: change.oldValue instanceof OperationRequiredRole
effect: 
	execute: {
		callRemoveRequiredRole(change.oldValue, change.affectedEObject as RepositoryComponent);
	}

routine: RemoveRequiredRole(pcm.RequiredRole requiredRole, pcm.InterfaceRequiringEntity requiringEntity)
match:
	retrieve required element: java.ClassifierImport as requiredInterfaceImport corresponding to requiredRole
	retrieve required element: java.Field as requiredInterfaceField corresponding to requiredRole
	retrieve required element: java.Class as javaClass corresponding to requiringEntity
effect: 
	delete element: requiredInterfaceImport
	delete element: requiredInterfaceField
	execute: {
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			callRemoveCorrespondingParameterFromConstructor(ctor, requiredRole);
			var Statement statementToRemove = null;
			for (statement : ctor.statements) {
				if (statement instanceof ExpressionStatement) {
					val assignmentExpression = statement.expression
					if (assignmentExpression instanceof AssignmentExpression) {
						val selfReference = assignmentExpression.child;
						if (selfReference instanceof SelfReference) {
							val fieldReference = selfReference.next;
							if (fieldReference instanceof IdentifierReference) {
								val field = fieldReference.target;
								if (field instanceof Field) {
									if (field.name.equals(requiredRole.entityName)) {
										statementToRemove = statement;
									}
								}
							}
							
						}
					}
				}
			}
			var Parameter parameterToRemove = null;
			for (parameter : ctor.parameters) {
				if (parameter.name.equals(requiredRole.entityName)) {
					parameterToRemove = parameter;
				}
			}
			if (statementToRemove != null) {
				ctor.statements.remove(statementToRemove);
			}
			if (parameterToRemove != null) {
				ctor.parameters.remove(parameterToRemove);
			}
		}
	}

routine: RemoveCorrespondingParameterFromConstructor(java.Constructor ctor, pcm.NamedElement correspondenceSource)
match:
	retrieve required element: java.OrdinaryParameter as param corresponding to correspondenceSource
		with ctor.parameters.contains(param)
effect: 
	delete element: param

routine: ReinitializeOperationRequiredRole(pcm.OperationRequiredRole requiredRole)
effect: 
	execute: {
		callRemoveRequiredRole(requiredRole, requiredRole.requiringEntity_RequiredRole);
		callAddRequiredRole(requiredRole);
	}

response: RenameOperationRequiredRole
trigger: replaced value pcm.OperationRequiredRole[entityName]
effect: 
	execute: callReinitializeOperationRequiredRole(change.affectedEObject)

response: ChangeOperationRequiredRoleEntity
trigger: replaced value pcm.OperationRequiredRole[requiringEntity_RequiredRole]
effect: 
	execute: {
		val requiredRole = change.affectedEObject;
		callRemoveRequiredRole(requiredRole, change.oldValue);
		callAddRequiredRole(requiredRole);
	}

response: ChangeOperationRequiredRoleInterface
trigger: replaced value pcm.OperationRequiredRole[requiredInterface__OperationRequiredRole]
effect: 
	execute: callReinitializeOperationRequiredRole(change.affectedEObject)


// ##########################################################
// ################ OPERATION SIGNATURES ####################

// TODO HK Implement changing the signature interface. All components with their SEFFs have to be updated.
// Use more reasonable correspondences than Michael
response: CreatedOperationSignature
trigger: inserted into list pcm.OperationInterface[signatures__OperationInterface]
match:
	retrieve required element: java.Interface as javaInterface corresponding to change.affectedEObject
effect: 
	create element: java.InterfaceMethod as interfaceMethod
	add correspondence: interfaceMethod, change.newValue
	execute: {
		interfaceMethod.name = change.newValue.entityName;
		callChangeInterfaceMethodReturnType(interfaceMethod, change.newValue.returnType__OperationSignature);
		javaInterface.members += interfaceMethod;
	}

response: RenameOperationSignature
trigger: replaced value pcm.OperationSignature[entityName]
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.affectedEObject
effect: execute: {
	val operationSignature = change.affectedEObject;
	val operationInterface = operationSignature.interface__OperationSignature;
	interfaceMethod.name = change.newValue;
	// get implementing components
	val implementingComponents = Sets.newHashSet
	operationInterface.repository__Interface.components__Repository.forEach [ comp |
		val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
		opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
			implementingComponents.add(opProRole.providingEntity_ProvidedRole)
		]
	]
	val basicComponents = implementingComponents.filter(BasicComponent)
	basicComponents.forEach[
		it.serviceEffectSpecifications__BasicComponent.forEach[
			callUpdateSEFFImplementingMethodName(it)
		]
	]
}

response: ChangeOperationSignatureReturnType
trigger: replaced value pcm.OperationSignature[returnType__OperationSignature]
match: 
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.affectedEObject
effect: 
	execute: callChangeInterfaceMethodReturnType(interfaceMethod, change.affectedEObject.returnType__OperationSignature)

routine: ChangeInterfaceMethodReturnType(java.InterfaceMethod interfaceMethod, pcm.DataType returnType)
match: 
	retrieve optional element: java.Class as returnTypeClass corresponding to returnType
effect: 
	execute: {
		val returnTypeReference = createTypeReference(returnType, returnTypeClass);
		interfaceMethod.typeReference = returnTypeReference;
	}

response: DeletedOperationSignature
trigger: removed from list pcm.OperationInterface[signatures__OperationInterface]
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.oldValue
effect: 
	delete element: interfaceMethod

// ################################################################################
// ################################## PARAMETERS ##################################

response: CreatedParameter
trigger: inserted into list pcm.OperationSignature[parameters__OperationSignature]
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.affectedEObject
effect: 
	create element: java.OrdinaryParameter as javaParameter
	add correspondence: javaParameter, change.newValue
	execute: {
		javaParameter.name = change.newValue.parameterName;
		callChangeParameterType(javaParameter, change.newValue.dataType__Parameter);
		interfaceMethod.parameters += javaParameter;
	}

response: RenamedParameter
trigger: replaced value pcm.Parameter[parameterName]
match:
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to change.affectedEObject
effect: 
	execute: {
		javaParameter.name = change.newValue;
	}

response: ChangedParameterType
trigger: replaced value pcm.Parameter[dataType__Parameter]
match:
	// retrieve the interface method to update the TUID according to the new parameter type
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.affectedEObject.eContainer
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to change.affectedEObject
effect: 
	execute: callChangeParameterType(javaParameter, change.newValue)

routine: ChangeParameterType(java.OrdinaryParameter javaParameter, pcm.DataType parameterType)
match:
	retrieve optional element: java.Class as javaParameterTypeClass corresponding to parameterType
effect: 
	execute: {
		val parameterTypeReference = createTypeReference(parameterType, javaParameterTypeClass);
		javaParameter.typeReference = parameterTypeReference;
	}

response: DeletedParameter
trigger: removed from list pcm.OperationSignature[parameters__OperationSignature]
match:
	// retrieve the interface method to update the TUID according to the removed parameter type
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.affectedEObject
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to change.oldValue
effect: 
	delete element: javaParameter


// ################################################################################
// ##################### RESOURCE DEMANDING INTERNAL BEHAVIOR #####################

response: CreatedResourceDemandingInternalBehavior
trigger: inserted into list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
match:
	retrieve required element: java.Class as componentClass corresponding to change.affectedEObject
effect: 
	create element: java.ClassMethod as javaMethod
	add correspondence: javaMethod, change.newValue
	execute: {
		javaMethod.name = change.newValue.entityName;
		javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid;
		componentClass.members += javaMethod;
	}

response: RenameResourceDemandingInternalBehavior
trigger: replaced value pcm.ResourceDemandingInternalBehaviour[entityName]
match:
	retrieve required element: java.ClassMethod as javaMethod corresponding to change.affectedEObject
effect: 
	execute: {
		javaMethod.name = change.newValue;
	}

response: DeletedDemandingInternalBehavior
trigger: removed from list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
match:
	retrieve required element: java.ClassMethod as javaMethod corresponding to change.oldValue
effect: 
	delete element: javaMethod


// ################################################################################
// #################################### SEFFS #####################################

response: CreatedSEFF
trigger: inserted into list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
effect: execute: callCreateSEFF(change.newValue)

routine: CreateSEFF(pcm.ServiceEffectSpecification seff)
match:
	retrieve required element: java.Class as componentClass corresponding to seff.basicComponent_ServiceEffectSpecification
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to seff.describedService__SEFF
	check: seff.describedService__SEFF instanceof OperationSignature
effect: 
	create element: java.ClassMethod as classMethod
	add correspondence: classMethod, seff
	execute: {
		initializeClassMethod(classMethod, interfaceMethod, true);
		var correspondingClassMethod = componentClass.findMethodInClass(classMethod)
		if (null == correspondingClassMethod) {
			componentClass.members.add(classMethod)
			correspondingClassMethod = classMethod
		} else {
			correspondingClassMethod.name = interfaceMethod.name
		}
	}

response: ChangeOperationSignatureOfSeff
trigger: replaced value pcm.ResourceDemandingSEFF[describedService__SEFF]
match:
	retrieve optional element: java.ClassMethod as oldClassMethod corresponding to change.affectedEObject
effect: 
	delete element: oldClassMethod
	execute: callCreateSEFF(change.affectedEObject)

routine: UpdateSEFFImplementingMethodName(pcm.ServiceEffectSpecification seff)
match:
	retrieve required element: java.ClassMethod as classMethod corresponding to seff
effect: 
	execute: {
		classMethod.name = seff.describedService__SEFF.entityName;
	}

response: DeletedSeff
trigger: removed from list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
match:
	retrieve required element: java.ClassMethod as classMethod corresponding to change.oldValue
effect: 
	delete element: classMethod



