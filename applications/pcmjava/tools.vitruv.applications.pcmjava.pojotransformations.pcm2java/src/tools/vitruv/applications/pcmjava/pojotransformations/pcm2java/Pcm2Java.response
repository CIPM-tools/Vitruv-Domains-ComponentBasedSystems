import org.eclipse.emf.ecore.util.EcoreUtil
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import com.google.common.collect.Sets
import org.emftext.language.java.statements.ExpressionStatement
import org.emftext.language.java.expressions.AssignmentExpression
import org.emftext.language.java.references.SelfReference
import org.emftext.language.java.references.IdentifierReference
import org.emftext.language.java.statements.Statement
import java.util.Set
import java.util.HashSet
import java.util.ArrayList
import java.util.LinkedList
import java.util.Vector
import java.util.Stack
import java.util.List
import tools.vitruv.framework.userinteraction.UserInteractionType
import org.emftext.language.java.generics.GenericsFactory
import static extension tools.vitruv.applications.pcmjava.pojotransformations.pcm2java.Pcm2JavaHelper.*
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.emftext.language.java.types.TypeReference
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.emftext.language.java.types.PrimitiveType
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.members.Field
import org.palladiosimulator.pcm.repository.InnerDeclaration

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

responses from metamodel pcm to metamodel java
called pcm2java

// ###################################################
// ################ PACKAGE RESPONSES ################


response: CreatedRepository
trigger: created root pcm.Repository
call {
	val repository = change.newValue
	callCreateJavaPackage(repository, null, repository.entityName, "repository_root");
	callCreateRepositorySubPackages(repository);
}

routine: CreateRepositorySubPackages(pcm.Repository repository)
match:
	retrieve required element: java.Package as repositoryPackage corresponding to repository
effect:
	call {
		callCreateJavaPackage(repository, repositoryPackage, "datatypes", "datatypes");
		callCreateJavaPackage(repository, repositoryPackage, "contracts", "contracts");
	}

response: RenamedRepository
trigger: replaced value pcm.Repository[entityName]
call callRenamePackageForRepository(change.affectedEObject)

routine: RenamePackageForRepository(pcm.Repository repository)
match:
	retrieve required element: java.Package as rootPackage corresponding to repository
		tagged with "repository_root"
effect: 
	execute: {
		rootPackage.name = repository.entityName;
	}
	call {
		callRenameJavaPackage(repository, rootPackage, "contracts", "contracts");
		callRenameJavaPackage(repository, rootPackage, "datatypes", "datatypes");	
		for (component : repository.components__Repository.filter(BasicComponent)) {
			callRenameComponentPackageAndClass(component);
		}
		for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
			callRenameInterface(interface);
		}
		for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
			callRenameCompositeDataType(dataType);
		}
		for (dataType : repository.dataTypes__Repository.filter(CollectionDataType)) {
			callRenameCollectionDataType(dataType);
		}
		persistProjectRelative(repository, rootPackage, buildJavaFilePath(rootPackage));
	}



// ################################################################################
// ############################# COMPOSED STRUCTURES ##############################

response: CreatedSystem
trigger: created root pcm.System
call {
	val system = change.newValue;
	callCreateJavaPackage(system, null, system.entityName, "root_system");
	callCreateImplementationForSystem(system);
}

routine: CreateImplementationForSystem(pcm.System system)
match:
	retrieve required element: java.Package as systemPackage corresponding to system
effect: 
	call callCreateJavaClass(system, systemPackage, system.entityName + "Impl")

response: DeletedSystem
trigger: deleted root pcm.System
call {
	val system = change.oldValue;
	callDeleteJavaPackage(system, system.entityName, "root_system");
	callDeleteJavaClassifier(system);
}

response: ChangedSystemName
trigger: replaced value pcm.System[entityName]
call callChangeSystemImplementationName(change.affectedEObject)

routine: ChangeSystemImplementationName(pcm.System system)
match:
	retrieve required element: java.Package as systemPackage corresponding to system
effect: 
	call {
		callRenameJavaPackage(system, null, system.entityName, null);
		callRenameJavaClassifier(system, systemPackage, system.entityName + "Impl");
	}

response: AddedAssemblyContextToComposedStructure
trigger: inserted into list pcm.ComposedStructure[assemblyContexts__ComposedStructure]
call callAddAssemblyContextToComposedStructure(change.affectedEObject, change.newValue)

routine: AddAssemblyContextToComposedStructure(pcm.ComposedStructure composedStructure, pcm.AssemblyContext assemblyContext)
match:
	retrieve required element: java.Class as compositeComponentJavaClass corresponding to composedStructure
	retrieve required element: java.Class as encapsulatedComponentJavaClass corresponding to assemblyContext.encapsulatedComponent__AssemblyContext
effect:
	create element: java.Field as assemblyContextField
	create element: java.NewConstructorCall as newConstructorCall
	create element: java.ClassifierImport as contextClassImport
	create element: java.Constructor as constructor
	add correspondence: assemblyContextField, assemblyContext
	add correspondence: newConstructorCall, assemblyContext
	add correspondence: contextClassImport, assemblyContext
	add correspondence: constructor, assemblyContext
	execute: {
		val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
		createPrivateField(assemblyContextField, typeRef, assemblyContext.entityName);
		compositeComponentJavaClass.members += assemblyContextField;
		addConstructorToClass(constructor, compositeComponentJavaClass)
		addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
		createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
	}

// #####################################################
// ################ COMPONENT RESPONSES ################

response: CreatedComponent
trigger: inserted into list pcm.Repository[components__Repository]
call callCreateComponentImplementation(change.newValue)

routine: CreateComponentImplementation(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as repositoryPackage corresponding to component.repository__RepositoryComponent
		tagged with "repository_root"
effect: 
	call {
		callCreateJavaPackage(component, repositoryPackage, component.entityName, null);
		callCreateImplementationForComponent(component);
	}

routine: CreateImplementationForComponent(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as componentPackage corresponding to component
effect: 
	call callCreateJavaClass(component, componentPackage, component.entityName + "Impl")

response: RenameComponent
trigger: replaced value pcm.RepositoryComponent[entityName]
call {
	val component = change.affectedEObject;
	callRenameComponentPackageAndClass(component);
}

routine: RenameComponentPackageAndClass(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as repositoryPackage corresponding to component.repository__RepositoryComponent
		with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
effect: 
	call {
		callRenameJavaPackage(component, repositoryPackage, component.entityName, null);
		callRenameComponentClass(component);
	}

routine: RenameComponentClass(pcm.RepositoryComponent component)
match:
	retrieve required element: java.Package as componentPackage corresponding to component
effect: 
	call callRenameJavaClassifier(component, componentPackage, component.entityName + "Impl")

response: DeletedComponent
trigger: removed from list pcm.Repository[components__Repository]
call {
	callDeleteJavaPackage(change.oldValue, change.oldValue.entityName, "")
	callDeleteJavaClassifier(change.oldValue)
}


// #####################################################
// ################ INTERFACE RESPONSES ################

response: CreatedInterface
trigger: inserted into list pcm.Repository[interfaces__Repository]
call callCreateInterfaceImplementation(change.newValue)

routine: CreateInterfaceImplementation(pcm.Interface interf)
match:
	retrieve required element: java.Package as contractsPackage corresponding to interf.repository__Interface
		with contractsPackage.name == "contracts"
effect: 
	call {
		callCreateJavaInterface(interf, contractsPackage, interf.entityName);
	}

response: RenamedInterface
trigger: replaced value pcm.Interface[entityName]
call callRenameInterface(change.affectedEObject as OperationInterface)

routine: RenameInterface(pcm.OperationInterface interf)
match:
	retrieve required element: java.Package as contractsPackage corresponding to interf.repository__Interface
		with contractsPackage.name == "contracts"
effect: 
	call callRenameJavaClassifier(interf, contractsPackage, interf.entityName)


// ######################################################
// ################ DATA TYPES RESPONSES ################

response: CreatedCompositeDataType
trigger: inserted into list pcm.Repository[dataTypes__Repository]
	check: change.newValue instanceof CompositeDataType
call callCreateCompositeDataTypeImplementation(change.newValue as CompositeDataType)

routine: CreateCompositeDataTypeImplementation(pcm.CompositeDataType dataType)
match:
	retrieve required element: java.Package as datatypesPackage corresponding to dataType.repository__DataType with datatypesPackage.name == "datatypes"
effect:
	call {
		callCreateJavaClass(dataType, datatypesPackage, dataType.entityName);
	}

response: RenamedCompositeDataType
trigger: replaced value pcm.CompositeDataType[entityName]
call callRenameCompositeDataType(change.affectedEObject)

routine: RenameCompositeDataType(pcm.CompositeDataType compositeDataType)
match:
	retrieve required element: java.Package as datatypesPackage corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
effect: 
	call callRenameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)

response: DeletedCompositeDataType
trigger: removed from list pcm.Repository[dataTypes__Repository]
	check: change.oldValue instanceof CompositeDataType
call callDeleteJavaClassifier(change.oldValue as CompositeDataType)

response: CreatedCollectionDataType
trigger: inserted into list pcm.Repository[dataTypes__Repository]
	check: change.newValue instanceof CollectionDataType
call callCreateCollectionDataTypeImplementation(change.newValue as CollectionDataType)

routine: CreateCollectionDataTypeImplementation(pcm.CollectionDataType dataType)
match:
	retrieve optional element: java.Class as innerTypeClass corresponding to dataType.innerType_CollectionDataType
	retrieve required element: java.Package as datatypesPackage corresponding to dataType.repository__DataType with datatypesPackage.name == "datatypes"
effect:
	call {
		// create correct (and in case of primitive types wrapped) type reference for the inner type
		val innerTypeRef = createTypeReference(dataType.innerType_CollectionDataType, innerTypeClass);
		var innerTypeClassOrWrapper = innerTypeRef;
		if (innerTypeRef instanceof PrimitiveType) {
			innerTypeClassOrWrapper = getWrapperTypeReferenceForPrimitiveType(innerTypeRef);
		}
		
		// Let user select the class to map the collection type to
		var Set<Class<?>> collectionDataTypes = new HashSet
		collectionDataTypes += #[ArrayList, LinkedList, Vector, Stack, HashSet]
		val List<String> collectionDataTypeNames = new ArrayList<String>(collectionDataTypes.size)
		for (collectionDataType : collectionDataTypes) {
			collectionDataTypeNames.add(collectionDataType.name)
		}
		val String selectTypeMsg = "Please select type (or interface) that should be used for the type"
		val int selectedType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectTypeMsg,
			collectionDataTypeNames)
		val Class<?> selectedClass = collectionDataTypes.get(selectedType)
	
		callCreateJavaClass(dataType, datatypesPackage, dataType.entityName);
		callAddSuperTypeToDataType(dataType, innerTypeClassOrWrapper, selectedClass.name);
	}

routine: AddSuperTypeToDataType(pcm.DataType dataType, java.TypeReference innerTypeReference, String superTypeQualifiedName)
match:
	retrieve required element: java.Class as dataTypeImplementation corresponding to dataType
	retrieve required element: java.CompilationUnit as dataTypeImplementationCU corresponding to dataType
effect: 
	create element: java.NamespaceClassifierReference as namespaceClassifier
	add correspondence: namespaceClassifier, dataType
	execute: {
		val collectionTypeClassImport = getJavaClassImport(superTypeQualifiedName);
		dataTypeImplementationCU.imports += collectionTypeClassImport;
		createNamespaceClassifierReference(namespaceClassifier, collectionTypeClassImport.classifier);
		val qualifiedTypeArgument = GenericsFactory.eINSTANCE.createQualifiedTypeArgument();
		qualifiedTypeArgument.typeReference = innerTypeReference;
		namespaceClassifier.classifierReferences.get(0).typeArguments += qualifiedTypeArgument;
		dataTypeImplementation.extends = namespaceClassifier;
	}

response: RenamedCollectionDataType
trigger: replaced value pcm.CollectionDataType[entityName]
call callRenameCollectionDataType(change.affectedEObject)

routine: RenameCollectionDataType(pcm.CollectionDataType collectionDataType)
match:
	retrieve required element: java.Package as datatypesPackage corresponding to collectionDataType.repository__DataType with datatypesPackage.name == "datatypes"
effect: 
	call callRenameJavaClassifier(collectionDataType, datatypesPackage, collectionDataType.entityName)

response: DeletedCollectionDataType
trigger: removed from list pcm.Repository[dataTypes__Repository]
	check: change.oldValue instanceof CollectionDataType
call callDeleteJavaClassifier(change.oldValue as CollectionDataType)


// ################ DATA TYPES - INNER DECLARATION RESPONSES ################

response: CreatedInnerDeclaration
trigger: inserted into list pcm.CompositeDataType[innerDeclaration_CompositeDataType]
call callCreateInnerDeclarationImplementation(change.newValue)

routine: CreateInnerDeclarationImplementation(pcm.InnerDeclaration innerDeclaration)
match:
	retrieve optional element: java.Class as nonPrimitiveInnerDataTypeClass corresponding to innerDeclaration.datatype_InnerDeclaration
effect: 
	call {
		val innerDataTypeReference = createTypeReference(innerDeclaration.datatype_InnerDeclaration, nonPrimitiveInnerDataTypeClass);
		callAddInnerDeclarationToCompositeDataType(innerDeclaration.compositeDataType_InnerDeclaration, innerDeclaration, innerDataTypeReference);
	}

routine: AddInnerDeclarationToCompositeDataType(pcm.CompositeDataType dataType, pcm.InnerDeclaration innerDeclaration, java.TypeReference dataTypeReference)
match:
	retrieve required element: java.Class as dataTypeClass corresponding to dataType
effect: 
	create element: java.Field as innerDataTypeField
	create element: java.ClassMethod as getterMethod
	create element: java.ClassMethod as setterMethod
	add correspondence: innerDataTypeField, innerDeclaration
	add correspondence: getterMethod, innerDeclaration tag with "getter"
	add correspondence: setterMethod, innerDeclaration tag with "setter"
	execute: {
		createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);
		createSetter(innerDataTypeField, setterMethod);
		createGetter(innerDataTypeField, getterMethod);
		dataTypeClass.members += innerDataTypeField;
		dataTypeClass.members += getterMethod;
		dataTypeClass.members += setterMethod;
		sortMembers(dataTypeClass.members);
	}

response: RenameInnerDeclaration
trigger: replaced value pcm.InnerDeclaration[entityName]
call callRenameInnerDeclarationImplementation(change.affectedEObject)

routine: RenameInnerDeclarationImplementation(pcm.InnerDeclaration innerDeclaration)
match:
	retrieve required element: java.Field as compositeTypeField corresponding to innerDeclaration
	retrieve required element: java.ClassMethod as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
	retrieve required element: java.ClassMethod as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
effect: 
	execute: {
		val newName = innerDeclaration.entityName;
		compositeTypeField.name = newName;
		compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
		if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
			val parameter = compositeTypeSetterMethod.parameters.get(0)
			parameter.name = "set" + newName.toFirstUpper;
		}
	}

response: ChangeTypeOfInnerDeclaration
trigger: replaced value pcm.InnerDeclaration[datatype_InnerDeclaration]
call callChangeTypeOfInnerDeclarationImplementation(change.affectedEObject)

routine: ChangeTypeOfInnerDeclarationImplementation(pcm.InnerDeclaration innerDeclaration)
match:
	retrieve optional element: java.Class as newJavaDataType corresponding to innerDeclaration.datatype_InnerDeclaration
effect: 
	call {
		val newDataTypeReference = createTypeReference(innerDeclaration.datatype_InnerDeclaration, newJavaDataType);
		callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
	}

routine: ChangeInnerDeclarationType(pcm.InnerDeclaration innerDeclaration, java.TypeReference newTypeReference)
match:
	retrieve required element: java.Field as compositeTypeField corresponding to innerDeclaration
	retrieve required element: java.Method as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
	retrieve required element: java.Method as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
effect: 
	execute: {
		compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
		compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
		if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
			val parameter = compositeTypeSetterMethod.parameters.get(0)
			parameter.typeReference = EcoreUtil.copy(newTypeReference)
		}
	}


// ######################################################
// ################ JAVA PACKAGE EFFECTS ################

routine: CreateJavaPackage(EObject sourceElementMappedToPackage, java.Package parentPackage, String packageName, String newTag)
match:
	require absence of element: java.Package corresponding to sourceElementMappedToPackage tagged with newTag
effect: 
	create element: java.Package as javaPackage
	add correspondence: javaPackage, sourceElementMappedToPackage
		tag with newTag //persist as root at project-relative location: buildJavaFilePath(javaPackage)
	execute: {
		if (parentPackage != null) {
			javaPackage.namespaces += parentPackage.namespaces;
			javaPackage.namespaces += parentPackage.name; 
		}
		javaPackage.name = packageName;
		persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
	}

routine: RenameJavaPackage(pcm.NamedElement sourceElementMappedToPackage, java.Package parentPackage, String packageName, String expectedTag)
match:
	retrieve required element: java.Package as javaPackage corresponding to sourceElementMappedToPackage
		tagged with expectedTag	//move containing model to project-relative location: buildJavaFilePath(javaPackage)
effect: 
	execute: {
		javaPackage.namespaces.clear();
		if (parentPackage != null) {
			javaPackage.namespaces += parentPackage.namespaces;
			javaPackage.namespaces += parentPackage.name; 
		}
		javaPackage.name = packageName;
		persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
	}

routine: DeleteJavaPackage(pcm.NamedElement sourceElementMappedToPackage, String packageName, String expectedTag)
match:
	retrieve required element: java.Package as javaPackage corresponding to sourceElementMappedToPackage tagged with expectedTag
effect: 
	delete element: javaPackage


// ######################################################
// ################ JAVA CLASS EFFECTS ##################

routine: CreateJavaClass(pcm.NamedElement sourceElementMappedToClass, java.Package containingPackage, String className)
effect: 
	create element: java.Class as javaClass
	add correspondence: javaClass, sourceElementMappedToClass
	call {
		javaClass.name = className;
		javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		callCreateCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage);
	}

routine: CreateJavaInterface(pcm.NamedElement sourceElementMappedToClass, java.Package containingPackage, String className)
effect: 
	create element: java.Interface as javaInterface
	add correspondence: javaInterface, sourceElementMappedToClass
	call {
		javaInterface.name = className;
		javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		callCreateCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage);
	}

routine: CreateCompilationUnit(pcm.NamedElement sourceElementMappedToClass, java.ConcreteClassifier classifier, java.Package containingPackage)
effect: 
	create element:  java.CompilationUnit as compilationUnit
	add correspondence: compilationUnit, sourceElementMappedToClass
		//persist as root at project-relative location: buildJavaFilePath(compilationUnit)
	execute: {
		compilationUnit.namespaces += containingPackage.namespaces;
		compilationUnit.namespaces += containingPackage.name;
		compilationUnit.name = classifier.name;
		compilationUnit.classifiers.add(classifier);
		persistProjectRelative(sourceElementMappedToClass, compilationUnit, buildJavaFilePath(compilationUnit));
	}

routine: RenameJavaClassifier(pcm.NamedElement classSourceElement, java.Package containingPackage, String className)
match:
	retrieve required element: java.CompilationUnit as compilationUnit corresponding to classSourceElement
		//move containing model to project-relative location: buildJavaFilePath(compilationUnit)
	retrieve required element: java.ConcreteClassifier as javaClassifier corresponding to classSourceElement
effect: 
	execute: {
		javaClassifier.name = className;
		compilationUnit.name = className;
		compilationUnit.namespaces.clear;
		compilationUnit.namespaces += containingPackage.namespaces;
		compilationUnit.namespaces += containingPackage.name;
		persistProjectRelative(classSourceElement, compilationUnit, buildJavaFilePath(compilationUnit));
	}

routine: DeleteJavaClassifier(pcm.NamedElement sourceElement)
match:
	retrieve required element: java.ConcreteClassifier as javaClassifier corresponding to sourceElement
	retrieve required element: java.CompilationUnit as compilationUnit corresponding to sourceElement
effect: 
	delete element: javaClassifier
	delete element: compilationUnit


// ####################################################
// ################ PROVIDED ROLES ####################

response: CreatedProvidedRole
trigger: inserted into list pcm.InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	check: change.newValue instanceof OperationProvidedRole
call callAddProvidedRole(change.newValue as OperationProvidedRole)

routine: AddProvidedRole(pcm.OperationProvidedRole providedRole)
match:
	retrieve required element: java.Interface as operationProvidingInterface corresponding to providedRole.providedInterface__OperationProvidedRole
	retrieve required element: java.Class as javaClass corresponding to providedRole.providingEntity_ProvidedRole
effect: 
	create element: java.ClassifierImport as interfaceImport
	create element: java.NamespaceClassifierReference as namespaceClassifierReference
	add correspondence: interfaceImport, providedRole
	add correspondence: namespaceClassifierReference,  providedRole
	execute: {
		createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
		javaClass.implements.add(namespaceClassifierReference)
		addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
	}

response: ChangedProvidedInterfaceOfProvidedRole
trigger: replaced value pcm.OperationProvidedRole[providedInterface__OperationProvidedRole]
call {
	val operationProvidedRole = change.affectedEObject;
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: ChangedProvidingEntityOfProvidedRole
trigger: replaced value pcm.OperationProvidedRole[providingEntity_ProvidedRole]
call {
	val operationProvidedRole = change.affectedEObject;	
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: DeletedProvidedRoleFromSystem
trigger: removed from list pcm.System[providedRoles_InterfaceProvidingEntity]
call callRemoveProvidedRole(change.oldValue)

response: DeletedProvidedRoleFromComponent
trigger: removed from list pcm.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
call callRemoveProvidedRole(change.oldValue)

routine: RemoveProvidedRole(pcm.ProvidedRole providedRole)
match:
	retrieve required element: java.ClassifierImport as requiredInterfaceImport corresponding to providedRole
	retrieve required element: java.NamespaceClassifierReference as namespaceClassifierReference corresponding to providedRole
effect: 
	delete element: requiredInterfaceImport
	delete element: namespaceClassifierReference

// ####################################################
// ################ REQUIRED ROLES ####################

// TODO HK implement ctor statement as correspondence (dynamic in explicit effect for each ctor) to remove them easily
// Use as example for responses best practices chapter
// TODO HK Implement rename correctly when having all four correspondences correctly 
response: CreatedRequiredRole
trigger: inserted into list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	check: change.newValue instanceof OperationRequiredRole
call callAddRequiredRole(change.newValue as OperationRequiredRole)

routine: AddRequiredRole(pcm.OperationRequiredRole requiredRole)
match:
	retrieve required element: java.Interface as requiredInterface corresponding to requiredRole.requiredInterface__OperationRequiredRole
	retrieve required element: java.Class as javaClass corresponding to requiredRole.requiringEntity_RequiredRole
effect: 
	create element: java.ClassifierImport as requiredInterfaceImport
	create element: java.Field as requiredInterfaceField
	add correspondence: requiredInterfaceImport, requiredRole
	add correspondence: requiredInterfaceField, requiredRole
	execute: {
		val typeRef = createNamespaceClassifierReference(requiredInterface);
		addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
		val requiredRoleName = requiredRole.entityName;
		createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
		javaClass.members += requiredInterfaceField;
		if (javaClass.members.filter(typeof(Constructor)).nullOrEmpty) {
			addConstructorToClass(javaClass)
		}
	}
	call {
		val typeRef = createNamespaceClassifierReference(requiredInterface);
		val requiredRoleName = requiredRole.entityName;
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			callAddParameterAndAssignmentToConstructor(requiredRole, ctor, typeRef, requiredInterfaceField, requiredRoleName);
		}
	}

routine: AddParameterAndAssignmentToConstructor(pcm.NamedElement parameterCorrespondenceSource, java.Constructor constructor, 
	java.NamespaceClassifierReference typeReference, java.Field fieldToBeAssigned, String parameterName)
effect: 
	create element: java.OrdinaryParameter as newParameter
	add correspondence: newParameter, parameterCorrespondenceSource
	execute: {
		newParameter.name = parameterName;
		newParameter.typeReference = EcoreUtil.copy(typeReference);
		constructor.parameters.add(newParameter)
		val asssignment = createAssignmentFromParameterToField(fieldToBeAssigned, newParameter);
		constructor.statements.add(asssignment)
	}


response: DeletedRequiredRole
trigger: removed from list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	check: change.oldValue instanceof OperationRequiredRole
call {
	callRemoveRequiredRole(change.oldValue, change.affectedEObject as RepositoryComponent);
}

routine: RemoveRequiredRole(pcm.RequiredRole requiredRole, pcm.InterfaceRequiringEntity requiringEntity)
match:
	retrieve required element: java.ClassifierImport as requiredInterfaceImport corresponding to requiredRole
	retrieve required element: java.Field as requiredInterfaceField corresponding to requiredRole
	retrieve required element: java.Class as javaClass corresponding to requiringEntity
effect: 
	delete element: requiredInterfaceImport
	delete element: requiredInterfaceField
	execute: {
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			var Statement statementToRemove = null;
			for (statement : ctor.statements) {
				if (statement instanceof ExpressionStatement) {
					val assignmentExpression = statement.expression
					if (assignmentExpression instanceof AssignmentExpression) {
						val selfReference = assignmentExpression.child;
						if (selfReference instanceof SelfReference) {
							val fieldReference = selfReference.next;
							if (fieldReference instanceof IdentifierReference) {
								val field = fieldReference.target;
								if (field instanceof Field) {
									if (field.name.equals(requiredRole.entityName)) {
										statementToRemove = statement;
									}
								}
							}
							
						}
					}
				}
			}
			if (statementToRemove != null) {
				ctor.statements.remove(statementToRemove);
			}
		}
	}
	call {
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			callRemoveCorrespondingParameterFromConstructor(ctor, requiredRole);
		}
	}

routine: RemoveCorrespondingParameterFromConstructor(java.Constructor ctor, pcm.NamedElement correspondenceSource)
match:
	retrieve required element: java.OrdinaryParameter as param corresponding to correspondenceSource
		with ctor.parameters.contains(param)
effect: 
	delete element: param

routine: ReinitializeOperationRequiredRole(pcm.OperationRequiredRole requiredRole)
effect: 
	call {
		callRemoveRequiredRole(requiredRole, requiredRole.requiringEntity_RequiredRole);
		callAddRequiredRole(requiredRole);
	}

response: RenameOperationRequiredRole
trigger: replaced value pcm.OperationRequiredRole[entityName]
call callReinitializeOperationRequiredRole(change.affectedEObject)

response: ChangeOperationRequiredRoleEntity
trigger: replaced value pcm.OperationRequiredRole[requiringEntity_RequiredRole]
call {
	val requiredRole = change.affectedEObject;
	callRemoveRequiredRole(requiredRole, change.oldValue);
	callAddRequiredRole(requiredRole);
}

response: ChangeOperationRequiredRoleInterface
trigger: replaced value pcm.OperationRequiredRole[requiredInterface__OperationRequiredRole]
call callReinitializeOperationRequiredRole(change.affectedEObject)


// ##########################################################
// ################ OPERATION SIGNATURES ####################

// TODO HK Implement changing the signature interface. All components with their SEFFs have to be updated.
// Use more reasonable correspondences than Michael
response: CreatedOperationSignature
trigger: inserted into list pcm.OperationInterface[signatures__OperationInterface]
call callCreateMethodForOperationSignature(change.newValue)

routine: CreateMethodForOperationSignature(pcm.OperationSignature operationSignature)
match:
	retrieve required element: java.Interface as javaInterface corresponding to operationSignature.interface__OperationSignature
effect: 
	create element: java.InterfaceMethod as interfaceMethod
	add correspondence: interfaceMethod, operationSignature
	call {
		interfaceMethod.name = operationSignature.entityName;
		callChangeInterfaceMethodReturnType(interfaceMethod, operationSignature.returnType__OperationSignature);
		javaInterface.members += interfaceMethod;
	}

response: RenameOperationSignature
trigger: replaced value pcm.OperationSignature[entityName]
call callRenameMethodForOperationSignature(change.affectedEObject)

routine: RenameMethodForOperationSignature(pcm.OperationSignature operationSignature)
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to operationSignature
effect: execute: {
	interfaceMethod.name = operationSignature.entityName;
	}
call {
	val operationInterface = operationSignature.interface__OperationSignature;
	// get implementing components
	val implementingComponents = Sets.newHashSet
	operationInterface.repository__Interface.components__Repository.forEach [ comp |
		val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
		opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
			implementingComponents.add(opProRole.providingEntity_ProvidedRole)
		]
	]
	val basicComponents = implementingComponents.filter(BasicComponent)
	basicComponents.forEach[
		it.serviceEffectSpecifications__BasicComponent.forEach[
			callUpdateSEFFImplementingMethodName(it)
		]
	]
}

response: ChangeOperationSignatureReturnType
trigger: replaced value pcm.OperationSignature[returnType__OperationSignature]
call callChangeReturnTypeOfMethodForOperationSignature(change.affectedEObject)

routine: ChangeReturnTypeOfMethodForOperationSignature(pcm.OperationSignature operationSignature)
match: 
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to operationSignature
effect: 
	call callChangeInterfaceMethodReturnType(interfaceMethod, operationSignature.returnType__OperationSignature)

routine: ChangeInterfaceMethodReturnType(java.InterfaceMethod interfaceMethod, pcm.DataType returnType)
match: 
	retrieve optional element: java.Class as returnTypeClass corresponding to returnType
effect: 
	execute: {
		val returnTypeReference = createTypeReference(returnType, returnTypeClass);
		interfaceMethod.typeReference = returnTypeReference;
	}

response: DeletedOperationSignature
trigger: removed from list pcm.OperationInterface[signatures__OperationInterface]
call callDeleteMethodForOperationSignature(change.oldValue)

routine: DeleteMethodForOperationSignature(pcm.OperationSignature operationSignature)
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to operationSignature
effect: 
	delete element: interfaceMethod

// ################################################################################
// ################################## PARAMETERS ##################################

response: CreatedParameter
trigger: inserted into list pcm.OperationSignature[parameters__OperationSignature]
call callCreateParameter(change.newValue)

// TODO HK Consolidate with ChangeParameterType!
routine: CreateParameter(pcm.Parameter parameter)
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to parameter.operationSignature__Parameter
	retrieve optional element: java.Class as javaParameterTypeClass corresponding to parameter.dataType__Parameter
effect: 
	create element: java.OrdinaryParameter as javaParameter
	add correspondence: javaParameter, parameter
	execute: {
		javaParameter.name = parameter.parameterName;
		interfaceMethod.parameters += javaParameter;
		val parameterTypeReference = createTypeReference(parameter.dataType__Parameter, javaParameterTypeClass);
		javaParameter.typeReference = parameterTypeReference;
	}

response: RenamedParameter
trigger: replaced value pcm.Parameter[parameterName]
call callRenameParameter(change.affectedEObject)

routine: RenameParameter(pcm.Parameter parameter)
match:
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to parameter
effect: 
	execute: {
		javaParameter.name = parameter.parameterName;
	}

response: ChangedParameterType
trigger: replaced value pcm.Parameter[dataType__Parameter]
call callChangeParameterType(change.affectedEObject)

routine: ChangeParameterType(pcm.Parameter parameter)
match:
	// retrieve the interface method to update the TUID according to the new parameter type
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to parameter.operationSignature__Parameter
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to parameter
	retrieve optional element: java.Class as javaParameterTypeClass corresponding to parameter.dataType__Parameter
effect: 
	execute: {
		val parameterTypeReference = createTypeReference(parameter.dataType__Parameter, javaParameterTypeClass);
		javaParameter.typeReference = parameterTypeReference;
	}


response: DeletedParameter
trigger: removed from list pcm.OperationSignature[parameters__OperationSignature]
call callDeleteParameter(change.affectedEObject, change.oldValue)

routine: DeleteParameter(pcm.OperationSignature signature, pcm.Parameter parameter)
match:
	// retrieve the interface method to update the TUID according to the removed parameter type
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to signature
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to parameter
effect: 
	delete element: javaParameter


// ################################################################################
// ##################### RESOURCE DEMANDING INTERNAL BEHAVIOR #####################

response: CreatedResourceDemandingInternalBehavior
trigger: inserted into list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
call callCreateMethodForResourceDemandingBehavior(change.newValue)

routine: CreateMethodForResourceDemandingBehavior(pcm.ResourceDemandingInternalBehaviour behavior)
match:
	retrieve required element: java.Class as componentClass corresponding to behavior.basicComponent_ResourceDemandingInternalBehaviour
effect: 
	create element: java.ClassMethod as javaMethod
	add correspondence: javaMethod, behavior
	execute: {
		javaMethod.name = behavior.entityName;
		javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid;
		componentClass.members += javaMethod;
	}

response: RenameResourceDemandingInternalBehavior
trigger: replaced value pcm.ResourceDemandingInternalBehaviour[entityName]
call callRenameMethodForResourceDemandingBehavior(change.affectedEObject)

routine: RenameMethodForResourceDemandingBehavior(pcm.ResourceDemandingInternalBehaviour behavior)
match:
	retrieve required element: java.ClassMethod as javaMethod corresponding to behavior
effect: 
	execute: {
		javaMethod.name = behavior.entityName;
	}

response: DeletedDemandingInternalBehavior
trigger: removed from list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
call callDeleteMethodForResourceDemandingBehavior(change.oldValue)

routine: DeleteMethodForResourceDemandingBehavior(pcm.ResourceDemandingInternalBehaviour behavior)
match:
	retrieve required element: java.ClassMethod as javaMethod corresponding to behavior
effect: 
	delete element: javaMethod


// ################################################################################
// #################################### SEFFS #####################################

response: CreatedSEFF
trigger: inserted into list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
call callCreateSEFF(change.newValue)

routine: CreateSEFF(pcm.ServiceEffectSpecification seff)
match:
	retrieve required element: java.Class as componentClass corresponding to seff.basicComponent_ServiceEffectSpecification
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to seff.describedService__SEFF
	check: seff.describedService__SEFF instanceof OperationSignature
effect: 
	create element: java.ClassMethod as classMethod
	add correspondence: classMethod, seff
	execute: {
		initializeClassMethod(classMethod, interfaceMethod, true);
		var correspondingClassMethod = componentClass.findMethodInClass(classMethod)
		if (null == correspondingClassMethod) {
			componentClass.members.add(classMethod)
			correspondingClassMethod = classMethod
		} else {
			correspondingClassMethod.name = interfaceMethod.name
		}
	}

response: ChangeOperationSignatureOfSeff
trigger: replaced value pcm.ResourceDemandingSEFF[describedService__SEFF]
call callChangeMethodForSeff(change.affectedEObject)

routine: ChangeMethodForSeff(pcm.ResourceDemandingSEFF seff)
match:
	retrieve optional element: java.ClassMethod as oldClassMethod corresponding to seff
effect: 
	delete element: oldClassMethod
	call callCreateSEFF(seff)

routine: UpdateSEFFImplementingMethodName(pcm.ServiceEffectSpecification seff)
match:
	retrieve required element: java.ClassMethod as classMethod corresponding to seff
effect: 
	execute: {
		classMethod.name = seff.describedService__SEFF.entityName;
	}

response: DeletedSeff
trigger: removed from list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
call callDeleteMethodForSeff(change.oldValue)

routine: DeleteMethodForSeff(pcm.ServiceEffectSpecification seff)
match:
	retrieve required element: java.ClassMethod as classMethod corresponding to seff
effect: 
	delete element: classMethod



