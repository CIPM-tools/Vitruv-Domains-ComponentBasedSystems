import org.eclipse.emf.ecore.util.EcoreUtil
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import com.google.common.collect.Sets
import org.emftext.language.java.statements.ExpressionStatement
import org.emftext.language.java.expressions.AssignmentExpression
import org.emftext.language.java.references.SelfReference
import org.emftext.language.java.references.IdentifierReference
import java.util.Set
import java.util.HashSet
import java.util.ArrayList
import java.util.LinkedList
import java.util.Vector
import java.util.Stack
import java.util.List
import tools.vitruv.framework.userinteraction.UserInteractionType
import org.emftext.language.java.generics.GenericsFactory
import static extension tools.vitruv.applications.pcmjava.pojotransformations.pcm2java.Pcm2JavaHelper.*
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.emftext.language.java.types.TypeReference
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.emftext.language.java.types.PrimitiveType
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.members.Field
import org.palladiosimulator.pcm.repository.OperationSignature
import org.emftext.language.java.imports.ClassifierImport

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

reactions: pcm2java
in reaction to changes in pcm 
execute actions in java

// ###################################################
// ################ PACKAGE REACTIONS ################


reaction CreatedRepository {
	after root created and inserted pcm::Repository
	call {
		val repository = change.newValue
		createJavaPackage(repository, null, repository.entityName, "repository_root");
		createRepositorySubPackages(repository);
	}
}

routine createRepositorySubPackages(pcm::Repository repository) {
	match {
		val repositoryPackage = retrieve java::Package corresponding to repository
	}
	action {
		call {
			createJavaPackage(repository, repositoryPackage, "datatypes", "datatypes");
			createJavaPackage(repository, repositoryPackage, "contracts", "contracts");
		}
	}
}	
	

reaction RenamedRepository {
	after value replaced for pcm::Repository[entityName]
	call renamePackageForRepository(change.affectedEObject)
}

routine renamePackageForRepository(pcm::Repository repository) {
	match {
		val rootPackage = retrieve java::Package corresponding to repository
			tagged with "repository_root"
	}
	action { 
		update rootPackage {
			rootPackage.name = repository.entityName;
		}
		call {
			renameJavaPackage(repository, rootPackage, "contracts", "contracts");
			renameJavaPackage(repository, rootPackage, "datatypes", "datatypes");	
			for (component : repository.components__Repository.filter(BasicComponent)) {
				renameComponentPackageAndClass(component);
			}
			for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
				renameInterface(interface);
			}
			for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
				renameCompositeDataType(dataType);
			}
			for (dataType : repository.dataTypes__Repository.filter(CollectionDataType)) {
				renameCollectionDataType(dataType);
			}
			persistProjectRelative(repository, rootPackage, buildJavaFilePath(rootPackage));
		}
	}
}


// ################################################################################
// ############################# COMPOSED STRUCTURES ##############################

reaction CreatedSystem {
	after root created and inserted pcm::System
	call {
		val system = change.newValue;
		createJavaPackage(system, null, system.entityName, "root_system");
		createImplementationForSystem(system);
	}
}

routine createImplementationForSystem(pcm::System system) { 
	match {
		val systemPackage = retrieve java::Package corresponding to system
	} 
	action { 
		call createJavaClass(system, systemPackage, system.entityName + "Impl")
	}
}
	
reaction DeletedSystem {
	after root deleted and removed pcm::System
	call {
		val system = change.oldValue;
		deleteJavaPackage(system, system.entityName, "root_system");
		deleteJavaClassifier(system);
	}
}

reaction ChangedSystemName {
	after value replaced for pcm::System[entityName]
	call changeSystemImplementationName(change.affectedEObject)
}
	
routine changeSystemImplementationName(pcm::System system) {
	match {
		val systemPackage = retrieve java::Package corresponding to system
	}
	action { 
		call {
			renameJavaPackage(system, null, system.entityName, null);
			renameJavaClassifier(system, systemPackage, system.entityName + "Impl");
		}
	}
}

reaction AddedAssemblyContextToComposedStructure { 
	after list entry created and inserted in pcm::ComposedStructure[assemblyContexts__ComposedStructure]
	call addAssemblyContextToComposedStructure(change.affectedEObject, change.newValue)
}

// TODO HK This is ugly...
routine addAssemblyContextToComposedStructure(pcm::ComposedStructure composedStructure, pcm::AssemblyContext assemblyContext) {
	match {
		val compositeComponentJavaClass = retrieve java::Class corresponding to composedStructure
		val encapsulatedComponentJavaClass = retrieve java::Class corresponding to assemblyContext.encapsulatedComponent__AssemblyContext
	} action {
		val assemblyContextField = create java::Field and initialize {
			val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
			createPrivateField(assemblyContextField, typeRef, assemblyContext.entityName);	
		}
		val newConstructorCall = create java::NewConstructorCall
		val contextClassImport = create java::ClassifierImport
		val constructor = create java::Constructor
		add correspondence between assemblyContextField and assemblyContext
		add correspondence between newConstructorCall and assemblyContext
		add correspondence between contextClassImport and assemblyContext
		add correspondence between constructor and assemblyContext
		update compositeComponentJavaClass {
			compositeComponentJavaClass.members += assemblyContextField;
			addConstructorToClass(constructor, compositeComponentJavaClass)
			addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
		}
		update constructor {
			createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
		}
	}
}

// #####################################################
// ################ COMPONENT REACTIONS ################

reaction CreatedComponent { 
	after list entry created and inserted in pcm::Repository[components__Repository]
	call createComponentImplementation(change.newValue)
}

routine createComponentImplementation(pcm::RepositoryComponent component) {
	match {
		val repositoryPackage = retrieve java::Package corresponding to component.repository__RepositoryComponent
			tagged with "repository_root"
	}
	action { 
		call {
			createJavaPackage(component, repositoryPackage, component.entityName, null);
			createImplementationForComponent(component);
		}
	}
}

routine createImplementationForComponent(pcm::RepositoryComponent component) {
	match {
		val componentPackage = retrieve java::Package corresponding to component
	}
	action { 
		call createJavaClass(component, componentPackage, component.entityName + "Impl")
	}
}

reaction RenameComponent {
	after value replaced for pcm::RepositoryComponent[entityName]
	call {
		val component = change.affectedEObject;
		renameComponentPackageAndClass(component);
	}
}

routine renameComponentPackageAndClass(pcm::RepositoryComponent component) { 
	match {
		val repositoryPackage = retrieve java::Package corresponding to component.repository__RepositoryComponent
			with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
	}
	action { 
		call {
			renameJavaPackage(component, repositoryPackage, component.entityName, null);
			renameComponentClass(component);
		}
	}
}

routine renameComponentClass(pcm::RepositoryComponent component) {
	match {
		val componentPackage = retrieve java::Package corresponding to component
	}
	action { 
		call renameJavaClassifier(component, componentPackage, component.entityName + "Impl")
	}
}

reaction DeletedComponent {
	after list entry deleted and removed in pcm::Repository[components__Repository]
	call {
		deleteJavaPackage(change.oldValue, change.oldValue.entityName, "")
		deleteJavaClassifier(change.oldValue)
	}
}

// #####################################################
// ################ INTERFACE REACTIONS ################

reaction CreatedInterface { 
	after list entry created and inserted in pcm::Repository[interfaces__Repository]
	call createInterfaceImplementation(change.newValue)
}

routine createInterfaceImplementation(pcm::Interface interf) { 
	match {
		val contractsPackage = retrieve java::Package corresponding to interf.repository__Interface
			with contractsPackage.name == "contracts"
	} 
	action { 
		call {
			createJavaInterface(interf, contractsPackage, interf.entityName);
		}
	}
}

reaction RenamedInterface { 
	after value replaced for pcm::Interface[entityName]
	call renameInterface(change.affectedEObject as OperationInterface)
}

routine renameInterface(pcm::OperationInterface interf) { 
	match {
		val contractsPackage = retrieve java::Package corresponding to interf.repository__Interface
			with contractsPackage.name == "contracts"
	} 
	action { 
		call renameJavaClassifier(interf, contractsPackage, interf.entityName)
	}
}

// ######################################################
// ################ DATA TYPES REACTIONS ################

reaction CreatedCompositeDataType { 
	after list entry created and inserted in pcm::Repository[dataTypes__Repository]
		with change.newValue instanceof CompositeDataType
	call createCompositeDataTypeImplementation(change.newValue as CompositeDataType)
}

routine createCompositeDataTypeImplementation(pcm::CompositeDataType dataType) { 
	match {
		val datatypesPackage = retrieve java::Package corresponding to dataType.repository__DataType 
			with datatypesPackage.name == "datatypes"
	} 
	action {
		call {
			createJavaClass(dataType, datatypesPackage, dataType.entityName);
		}
	}
}

reaction RenamedCompositeDataType { 
	after value replaced for pcm::CompositeDataType[entityName]
	call renameCompositeDataType(change.affectedEObject)
}

routine renameCompositeDataType(pcm::CompositeDataType compositeDataType) { 
	match {
		val datatypesPackage = retrieve java::Package corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
	} 
	action { 
		call renameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)
	}
}

reaction DeletedCompositeDataType {
	after list entry deleted and removed in pcm::Repository[dataTypes__Repository]
		with change.oldValue instanceof CompositeDataType
	call deleteJavaClassifier(change.oldValue as CompositeDataType)
}

reaction CreatedCollectionDataType { 
	after list entry created and inserted in pcm::Repository[dataTypes__Repository]
		with change.newValue instanceof CollectionDataType
	call createCollectionDataTypeImplementation(change.newValue as CollectionDataType)
}

routine createCollectionDataTypeImplementation(pcm::CollectionDataType dataType) { 
	match {
		val innerTypeClass = retrieve optional java::Class corresponding to dataType.innerType_CollectionDataType
		val datatypesPackage = retrieve java::Package corresponding to dataType.repository__DataType with datatypesPackage.name == "datatypes"
	} 
	action {
		call {
			// create correct (and in case of primitive types wrapped) type reference for the inner type
			val innerTypeRef = createTypeReference(dataType.innerType_CollectionDataType, innerTypeClass);
			var innerTypeClassOrWrapper = innerTypeRef;
			if (innerTypeRef instanceof PrimitiveType) {
				innerTypeClassOrWrapper = getWrapperTypeReferenceForPrimitiveType(innerTypeRef);
			}
			
			// Let user select the class to map the collection type to
			var Set<Class<?>> collectionDataTypes = new HashSet
			collectionDataTypes += #[ArrayList, LinkedList, Vector, Stack, HashSet]
			val List<String> collectionDataTypeNames = new ArrayList<String>(collectionDataTypes.size)
			for (collectionDataType : collectionDataTypes) {
				collectionDataTypeNames.add(collectionDataType.name)
			}
			val String selectTypeMsg = "Please select type (or interface) that should be used for the type"
			val int selectedType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectTypeMsg,
				collectionDataTypeNames)
			val Class<?> selectedClass = collectionDataTypes.get(selectedType)
	
			createJavaClass(dataType, datatypesPackage, dataType.entityName);
			addSuperTypeToDataType(dataType, innerTypeClassOrWrapper, selectedClass.name);
		}
	}
}

routine addSuperTypeToDataType(pcm::DataType dataType, java::TypeReference innerTypeReference, String superTypeQualifiedName) {
	match {
		val dataTypeImplementation = retrieve java::Class corresponding to dataType
		val dataTypeImplementationCU = retrieve java::CompilationUnit corresponding to dataType
	} 
	action { 
		update dataTypeImplementationCU {
			val collectionTypeClassImport = getJavaClassImport(superTypeQualifiedName);
			dataTypeImplementationCU.imports += collectionTypeClassImport;
		}
		val namespaceClassifier = create java::NamespaceClassifierReference and initialize {
			createNamespaceClassifierReference(namespaceClassifier, dataTypeImplementationCU.imports.filter(ClassifierImport).last.classifier);
			val qualifiedTypeArgument = GenericsFactory.eINSTANCE.createQualifiedTypeArgument();
			qualifiedTypeArgument.typeReference = innerTypeReference;
			namespaceClassifier.classifierReferences.get(0).typeArguments += qualifiedTypeArgument;
		}
		add correspondence between namespaceClassifier and dataType
		update dataTypeImplementation {
			dataTypeImplementation.extends = namespaceClassifier;
		}
	}
}

reaction RenamedCollectionDataType {
	after value replaced for pcm::CollectionDataType[entityName]
	call renameCollectionDataType(change.affectedEObject)
}

routine renameCollectionDataType(pcm::CollectionDataType collectionDataType) { 
	match {
		val datatypesPackage = retrieve java::Package corresponding to collectionDataType.repository__DataType with datatypesPackage.name == "datatypes"
	} 
	action { 
		call renameJavaClassifier(collectionDataType, datatypesPackage, collectionDataType.entityName)
	}
}

reaction DeletedCollectionDataType { 
	after list entry deleted and removed in pcm::Repository[dataTypes__Repository]
		with change.oldValue instanceof CollectionDataType
	call deleteJavaClassifier(change.oldValue as CollectionDataType)
}

// ################ DATA TYPES - INNER DECLARATION REACTIONS ################

reaction CreatedInnerDeclaration { 
	after list entry created and inserted in pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	call createInnerDeclarationImplementation(change.newValue)
}

routine createInnerDeclarationImplementation(pcm::InnerDeclaration innerDeclaration) { 
	match {
		val nonPrimitiveInnerDataTypeClass = retrieve optional java::Class corresponding to innerDeclaration.datatype_InnerDeclaration
	} action { 
		call {
			val innerDataTypeReference = createTypeReference(innerDeclaration.datatype_InnerDeclaration, nonPrimitiveInnerDataTypeClass);
			addInnerDeclarationToCompositeDataType(innerDeclaration.compositeDataType_InnerDeclaration, innerDeclaration, innerDataTypeReference);
		}
	}
}

routine addInnerDeclarationToCompositeDataType(pcm::CompositeDataType dataType, pcm::InnerDeclaration innerDeclaration, java::TypeReference dataTypeReference) { 
	match {
		val dataTypeClass = retrieve java::Class corresponding to dataType
	} 
	action { 
		val innerDataTypeField = create java::Field and initialize {
			createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);	
		}
		add correspondence between innerDataTypeField and innerDeclaration
		val getterMethod  = create java::ClassMethod and initialize {
			createGetter(innerDataTypeField, getterMethod);
		}
		add correspondence between getterMethod and innerDeclaration tag with "getter"
		val setterMethod = create java::ClassMethod and initialize {
			createSetter(innerDataTypeField, setterMethod);
		}
		add correspondence between setterMethod and innerDeclaration tag with "setter"
		update dataTypeClass {
			dataTypeClass.members += innerDataTypeField;
			dataTypeClass.members += getterMethod;
			dataTypeClass.members += setterMethod;
			sortMembers(dataTypeClass.members);
		}
	}
}

reaction RenameInnerDeclaration { 
	after value replaced for pcm::InnerDeclaration[entityName]
	call renameInnerDeclarationImplementation(change.affectedEObject)
}

routine renameInnerDeclarationImplementation(pcm::InnerDeclaration innerDeclaration) { 
	match {
		val compositeTypeField = retrieve java::Field corresponding to innerDeclaration
		val compositeTypeGetterMethod = retrieve java::ClassMethod corresponding to innerDeclaration tagged with "getter"
		val compositeTypeSetterMethod = retrieve java::ClassMethod corresponding to innerDeclaration tagged with "setter"
	} 
	action {
		update compositeTypeField {
			compositeTypeField.name = innerDeclaration.entityName;
		}
		update compositeTypeGetterMethod {
			compositeTypeGetterMethod.name = "get" + innerDeclaration.entityName.toFirstUpper;
		}
		update compositeTypeSetterMethod {
			if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
				val parameter = compositeTypeSetterMethod.parameters.get(0)
				parameter.name = "set" + innerDeclaration.entityName.toFirstUpper;
			}
		}
	}
}
	
reaction ChangeTypeOfInnerDeclaration { 
	after value replaced for pcm::InnerDeclaration[datatype_InnerDeclaration]
	call changeTypeOfInnerDeclarationImplementation(change.affectedEObject)
}

routine changeTypeOfInnerDeclarationImplementation(pcm::InnerDeclaration innerDeclaration) { 
	match {
		val newJavaDataType = retrieve optional java::Class corresponding to innerDeclaration.datatype_InnerDeclaration
	} 
	action { 
		call {
			val newDataTypeReference = createTypeReference(innerDeclaration.datatype_InnerDeclaration, newJavaDataType);
			changeInnerDeclarationType(innerDeclaration, newDataTypeReference);
		}
	}
}

routine changeInnerDeclarationType(pcm::InnerDeclaration innerDeclaration, java::TypeReference newTypeReference) { 
	match {
		val compositeTypeField = retrieve java::Field corresponding to innerDeclaration
		val compositeTypeGetterMethod = retrieve java::Method corresponding to innerDeclaration tagged with "getter"
		val compositeTypeSetterMethod = retrieve java::Method corresponding to innerDeclaration tagged with "setter"
	} 
	action {
		update compositeTypeField {
			compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
		}
		update compositeTypeGetterMethod {
			compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
		}
		update compositeTypeSetterMethod {
			if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
				val parameter = compositeTypeSetterMethod.parameters.get(0)
				parameter.typeReference = EcoreUtil.copy(newTypeReference)
			}
		} 
	}
}


// ######################################################
// ################ JAVA PACKAGE ROUTINES ################

routine createJavaPackage(EObject sourceElementMappedToPackage, java::Package parentPackage, String packageName, String newTag)	 { 
	match {
		require absence of java::Package corresponding to sourceElementMappedToPackage tagged with newTag
	} 
	action { 
		val javaPackage = create java::Package and initialize {
			if (parentPackage != null) {
				javaPackage.namespaces += parentPackage.namespaces;
				javaPackage.namespaces += parentPackage.name; 
			}
			javaPackage.name = packageName;
			persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
		}
		add correspondence between javaPackage and sourceElementMappedToPackage
			tag with newTag
	}
}

routine renameJavaPackage(pcm::NamedElement sourceElementMappedToPackage, java::Package parentPackage, String packageName, String expectedTag) {
	match {
		val javaPackage = retrieve java::Package corresponding to sourceElementMappedToPackage
			tagged with expectedTag	//move containing model to project-relative location: buildJavaFilePath(javaPackage)
	} 
	action { 
		update javaPackage {
			javaPackage.namespaces.clear();
			if (parentPackage != null) {
				javaPackage.namespaces += parentPackage.namespaces;
				javaPackage.namespaces += parentPackage.name; 
			}
			javaPackage.name = packageName;
			persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
		}
	}
}

routine deleteJavaPackage(pcm::NamedElement sourceElementMappedToPackage, String packageName, String expectedTag) { 
	match {
		val javaPackage = retrieve java::Package corresponding to sourceElementMappedToPackage tagged with expectedTag
	} 
	action { 
		delete javaPackage
	}
}
	
// ######################################################
// ################ JAVA CLASS ROUTINES ##################

routine createJavaClass(pcm::NamedElement sourceElementMappedToClass, java::Package containingPackage, String className) {
	action { 
		val javaClass = create java::Class and initialize {
			javaClass.name = className;
			javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		}
		add correspondence between javaClass and sourceElementMappedToClass
		call createCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage)
	}
}

routine createJavaInterface(pcm::NamedElement sourceElementMappedToClass, java::Package containingPackage, String className) {
	action { 
		val javaInterface = create java::Interface and initialize {
			javaInterface.name = className;
			javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		}
		add correspondence between javaInterface and sourceElementMappedToClass
		call createCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage)
	}
}

routine createCompilationUnit(pcm::NamedElement sourceElementMappedToClass, java::ConcreteClassifier classifier, java::Package containingPackage) {
	action { 
		val compilationUnit = create java::CompilationUnit and initialize {
			compilationUnit.namespaces += containingPackage.namespaces;
			compilationUnit.namespaces += containingPackage.name;
			compilationUnit.name = classifier.name;
			compilationUnit.classifiers.add(classifier);
			persistProjectRelative(sourceElementMappedToClass, compilationUnit, buildJavaFilePath(compilationUnit));
		}
		add correspondence between compilationUnit and sourceElementMappedToClass
	}
}

routine renameJavaClassifier(pcm::NamedElement classSourceElement, java::Package containingPackage, String className) { 
	match {
		val compilationUnit = retrieve java::CompilationUnit corresponding to classSourceElement
		// move containing model to project-relative location: buildJavaFilePath(compilationUnit)
		val javaClassifier = retrieve java::ConcreteClassifier corresponding to classSourceElement
	} 
	action { 
		update javaClassifier {
			javaClassifier.name = className;
		}
		update compilationUnit {
			compilationUnit.name = className;
			compilationUnit.namespaces.clear;
			compilationUnit.namespaces += containingPackage.namespaces;
			compilationUnit.namespaces += containingPackage.name;
			persistProjectRelative(classSourceElement, compilationUnit, buildJavaFilePath(compilationUnit));
		}
	}
}

routine deleteJavaClassifier(pcm::NamedElement sourceElement) { 
	match {
		val javaClassifier = retrieve java::ConcreteClassifier corresponding to sourceElement
		val compilationUnit = retrieve java::CompilationUnit corresponding to sourceElement
	}
	action { 
		delete javaClassifier
		delete compilationUnit
	}
}


// ####################################################
// ################ PROVIDED ROLES ####################

reaction CreatedProvidedRole { 
	after list entry created and inserted in pcm::InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
		with change.newValue instanceof OperationProvidedRole
	call addProvidedRole(change.newValue as OperationProvidedRole)
}

routine addProvidedRole(pcm::OperationProvidedRole providedRole) { 
	match {
		val operationProvidingInterface = retrieve java::Interface corresponding to providedRole.providedInterface__OperationProvidedRole
		val javaClass = retrieve java::Class corresponding to providedRole.providingEntity_ProvidedRole
	} 
	action {
		// TODO HK This should be partly in the context of the compilation unit
		val interfaceImport = create java::ClassifierImport and initialize {
			addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
		}
		add correspondence between interfaceImport and providedRole
		val namespaceClassifierReference = create java::NamespaceClassifierReference and initialize {
			createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
		}
		add correspondence between namespaceClassifierReference and providedRole
		update javaClass {
			javaClass.implements.add(namespaceClassifierReference)
		}
	}
}

reaction ChangedProvidedInterfaceOfProvidedRole { 
	after value replaced for pcm::OperationProvidedRole[providedInterface__OperationProvidedRole]
	call {
		val operationProvidedRole = change.affectedEObject;
		removeProvidedRole(operationProvidedRole);
		addProvidedRole(operationProvidedRole);
	}
}

reaction ChangedProvidingEntityOfProvidedRole { 
	after value replaced for pcm::OperationProvidedRole[providingEntity_ProvidedRole]
	call {
		val operationProvidedRole = change.affectedEObject;	
		removeProvidedRole(operationProvidedRole);
		addProvidedRole(operationProvidedRole);
	}
}

reaction DeletedProvidedRoleFromSystem { 
	after list entry deleted and removed in pcm::System[providedRoles_InterfaceProvidingEntity]
	call removeProvidedRole(change.oldValue)
}

reaction DeletedProvidedRoleFromComponent { 
	after list entry deleted and removed in pcm::RepositoryComponent[providedRoles_InterfaceProvidingEntity]
	call removeProvidedRole(change.oldValue)
}

routine removeProvidedRole(pcm::ProvidedRole providedRole) { 
	match {
		val requiredInterfaceImport = retrieve java::ClassifierImport corresponding to providedRole
		val namespaceClassifierReference = retrieve java::NamespaceClassifierReference corresponding to providedRole
	} 
	action { 
		delete requiredInterfaceImport
		delete namespaceClassifierReference
	}
}


// ####################################################
// ################ REQUIRED ROLES ####################

// TODO HK implement ctor statement as correspondence (dynamic in explicit action for each ctor) to remove them easily
// Use as example for reactions best practices chapter
// TODO HK Implement rename correctly after having all four correspondences correctly 
reaction CreatedRequiredRole { 
	after list entry created and inserted in pcm::InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
		with change.newValue instanceof OperationRequiredRole
	call addRequiredRole(change.newValue as OperationRequiredRole)
}

// TODO HK This routine is hard to read, isn't it?
routine addRequiredRole(pcm::OperationRequiredRole requiredRole) { 
	match {
		val requiredInterface = retrieve java::Interface corresponding to requiredRole.requiredInterface__OperationRequiredRole
		val javaClass = retrieve java::Class corresponding to requiredRole.requiringEntity_RequiredRole
	} action {
		// TODO HK this should be partly in the context of the compilation unit
		val requiredInterfaceImport = create java::ClassifierImport and initialize {
			addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
		}
		add correspondence between requiredInterfaceImport and requiredRole
		val requiredInterfaceField = create java::Field and initialize {
			val typeRef = createNamespaceClassifierReference(requiredInterface);
			val requiredRoleName = requiredRole.entityName;
			createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
		}
		add correspondence between requiredInterfaceField and requiredRole
		update javaClass {
			javaClass.members += requiredInterfaceField;
			if (javaClass.members.filter(typeof(Constructor)).nullOrEmpty) {
				addConstructorToClass(javaClass)
			}
		}
		call {
			val typeRef = createNamespaceClassifierReference(requiredInterface);
			val requiredRoleName = requiredRole.entityName;
			for (ctor : javaClass.members.filter(typeof(Constructor))) {
				addParameterAndAssignmentToConstructor(requiredRole, ctor, typeRef, requiredInterfaceField, requiredRoleName);
			}
		}
	}
}

routine addParameterAndAssignmentToConstructor(pcm::NamedElement parameterCorrespondenceSource, java::Constructor constructor, 
		java::NamespaceClassifierReference typeReference, java::Field fieldToBeAssigned, String parameterName) {
	action { 
		val newParameter = create java::OrdinaryParameter and initialize {
			newParameter.name = parameterName;
			newParameter.typeReference = EcoreUtil.copy(typeReference);
		}
		add correspondence between newParameter and parameterCorrespondenceSource
		update constructor {
			constructor.parameters.add(newParameter)
			val asssignment = createAssignmentFromParameterToField(fieldToBeAssigned, newParameter);
			constructor.statements.add(asssignment)
		}
	}
}

reaction DeletedRequiredRole { 
	after list entry deleted and removed in pcm::InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
		with change.oldValue instanceof OperationRequiredRole
	call {
		removeRequiredRole(change.oldValue, change.affectedEObject as RepositoryComponent);
	}
}

routine removeRequiredRole(pcm::RequiredRole requiredRole, pcm::InterfaceRequiringEntity requiringEntity) { 
	match {
		val requiredInterfaceImport = retrieve java::ClassifierImport corresponding to requiredRole
		val requiredInterfaceField = retrieve java::Field corresponding to requiredRole
		val javaClass = retrieve java::Class corresponding to requiringEntity
	} 
	action { 
		delete requiredInterfaceImport
		delete requiredInterfaceField
		call {
			for (ctor : javaClass.members.filter(typeof(Constructor))) {
				removeParameterToFieldAssignmentFromConstructor(ctor, requiredRole.entityName)
				removeCorrespondingParameterFromConstructor(ctor, requiredRole);
			}
		}
	}
}

routine removeParameterToFieldAssignmentFromConstructor(java::Constructor ctor, String fieldName) {
	action {
		update ctor {
			for (statement : ctor.statements) {
				if (statement instanceof ExpressionStatement) {
					val assignmentExpression = statement.expression
					if (assignmentExpression instanceof AssignmentExpression) {
						val selfReference = assignmentExpression.child;
						if (selfReference instanceof SelfReference) {
							val fieldReference = selfReference.next;
							if (fieldReference instanceof IdentifierReference) {
								val field = fieldReference.target;
								if (field instanceof Field) {
									if (field.name.equals(fieldName)) {
										ctor.statements.remove(statement);
										return;
									}
								}
							}
							
						}
					}
				}
			}
		}
	}
}

routine removeCorrespondingParameterFromConstructor(java::Constructor ctor, pcm::NamedElement correspondenceSource) { 
	match {
		val param = retrieve java::OrdinaryParameter corresponding to correspondenceSource
			with ctor.parameters.contains(param)
	} 
	action { 
		delete param
	}
}

routine reinitializeOperationRequiredRole(pcm::OperationRequiredRole requiredRole) {
	action { 
		call {
			removeRequiredRole(requiredRole, requiredRole.requiringEntity_RequiredRole);
			addRequiredRole(requiredRole);
		}
	}
}

reaction RenameOperationRequiredRole { 
	after value replaced for pcm::OperationRequiredRole[entityName]
	call reinitializeOperationRequiredRole(change.affectedEObject)
}

reaction ChangeOperationRequiredRoleEntity { 
	after value replaced for pcm::OperationRequiredRole[requiringEntity_RequiredRole]
	call {
		val requiredRole = change.affectedEObject;
		removeRequiredRole(requiredRole, change.oldValue);
		addRequiredRole(requiredRole);
	}
}

reaction ChangeOperationRequiredRoleInterface { 
	after value replaced for pcm::OperationRequiredRole[requiredInterface__OperationRequiredRole]
	call reinitializeOperationRequiredRole(change.affectedEObject)
}


// ##########################################################
// ################ OPERATION SIGNATURES ####################

// TODO HK Implement changing the signature interface. All components with their SEFFs have to be updated.
// Use more reasonable correspondences than Michael
reaction CreatedOperationSignature { 
	after list entry created and inserted in pcm::OperationInterface[signatures__OperationInterface]
	call createMethodForOperationSignature(change.newValue)
}

routine createMethodForOperationSignature(pcm::OperationSignature operationSignature) { 
	match {
		val javaInterface = retrieve java::Interface corresponding to operationSignature.interface__OperationSignature
	}
	action { 
		val interfaceMethod = create java::InterfaceMethod
		add correspondence between interfaceMethod and operationSignature
		call {
			interfaceMethod.name = operationSignature.entityName;
			changeInterfaceMethodReturnType(interfaceMethod, operationSignature.returnType__OperationSignature);
			javaInterface.members += interfaceMethod;
		}
	}
}

reaction RenameOperationSignature { 
	after value replaced for pcm::OperationSignature[entityName]
	call renameMethodForOperationSignature(change.affectedEObject)
}

routine renameMethodForOperationSignature(pcm::OperationSignature operationSignature) { 
	match {
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to operationSignature
	} 
	action { 
		update interfaceMethod {
			interfaceMethod.name = operationSignature.entityName;
		}
		call {
			val operationInterface = operationSignature.interface__OperationSignature;
			// get implementing components
			val implementingComponents = Sets.newHashSet
			operationInterface.repository__Interface.components__Repository.forEach [ comp |
				val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
				opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
					implementingComponents.add(opProRole.providingEntity_ProvidedRole)
				]
			]
			val basicComponents = implementingComponents.filter(BasicComponent)
			basicComponents.forEach[
				it.serviceEffectSpecifications__BasicComponent.forEach[
					updateSEFFImplementingMethodName(it)
				]
			]
		}
	}
}

reaction ChangeOperationSignatureReturnType { 
	after value replaced for pcm::OperationSignature[returnType__OperationSignature]
	call changeReturnTypeOfMethodForOperationSignature(change.affectedEObject)
}

routine changeReturnTypeOfMethodForOperationSignature(pcm::OperationSignature operationSignature) { 
	match { 
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to operationSignature
	} 
	action { 
		call changeInterfaceMethodReturnType(interfaceMethod, operationSignature.returnType__OperationSignature)
	}
}

routine changeInterfaceMethodReturnType(java::InterfaceMethod interfaceMethod, pcm::DataType returnType) { 
	match { 
		val returnTypeClass = retrieve optional java::Class corresponding to returnType
	} 
	action { 
		update interfaceMethod {
			val returnTypeReference = createTypeReference(returnType, returnTypeClass);
			interfaceMethod.typeReference = returnTypeReference;
		}
	}
}

reaction DeletedOperationSignature { 
	after list entry deleted and removed in pcm::OperationInterface[signatures__OperationInterface]
	call deleteMethodForOperationSignature(change.oldValue)
}

routine deleteMethodForOperationSignature(pcm::OperationSignature operationSignature) { 
	match {
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to operationSignature
	} 
	action { 
		delete interfaceMethod
	}
}
 

// ################################################################################
// ################################## PARAMETERS ##################################

reaction CreatedParameter { 
	after list entry created and inserted in pcm::OperationSignature[parameters__OperationSignature]
	call createParameter(change.newValue)
}

// TODO HK Consolidate with ChangeParameterType!
routine createParameter(pcm::Parameter parameter) { 
	match {
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to parameter.operationSignature__Parameter
		val javaParameterTypeClass = retrieve optional java::Class corresponding to parameter.dataType__Parameter
	} 
	action { 
		val javaParameter = create java::OrdinaryParameter and initialize {
			javaParameter.name = parameter.parameterName;
			val parameterTypeReference = createTypeReference(parameter.dataType__Parameter, javaParameterTypeClass);
			javaParameter.typeReference = parameterTypeReference;
		}
		add correspondence between javaParameter and parameter
		update interfaceMethod {
			interfaceMethod.parameters += javaParameter;
		}
	}
}

reaction RenamedParameter { 
	after value replaced for pcm::Parameter[parameterName]
	call renameParameter(change.affectedEObject)
}

routine renameParameter(pcm::Parameter parameter) { 
	match {
		val javaParameter = retrieve java::OrdinaryParameter corresponding to parameter
	} 
	action { 
		update javaParameter {
			javaParameter.name = parameter.parameterName;
		}
	}
}

reaction ChangedParameterType { 
	after value replaced for pcm::Parameter[dataType__Parameter]
	call changeParameterType(change.affectedEObject)
}

routine changeParameterType(pcm::Parameter parameter) { 
	match {
		// retrieve the interface method to update the TUID according to the new parameter type
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to parameter.operationSignature__Parameter
		val javaParameter = retrieve java::OrdinaryParameter corresponding to parameter
		val javaParameterTypeClass = retrieve optional java::Class corresponding to parameter.dataType__Parameter
	} 
	action { 
		update parameter {
			val parameterTypeReference = createTypeReference(parameter.dataType__Parameter, javaParameterTypeClass);
			javaParameter.typeReference = parameterTypeReference;
		}
	}
}

reaction DeletedParameter { 
	after list entry deleted and removed in pcm::OperationSignature[parameters__OperationSignature]
	call deleteParameter(change.affectedEObject, change.oldValue)
}

routine deleteParameter(pcm::OperationSignature signature, pcm::Parameter parameter) { 
	match {
		// retrieve the interface method to update the TUID according to the removed parameter type
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to signature
		val javaParameter = retrieve java::OrdinaryParameter corresponding to parameter
	} 
	action { 
		delete javaParameter
	}
}

// ################################################################################
// ##################### RESOURCE DEMANDING INTERNAL BEHAVIOR #####################

reaction CreatedResourceDemandingInternalBehavior { 
	after list entry created and inserted in pcm::BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
	call createMethodForResourceDemandingBehavior(change.newValue)
}

routine createMethodForResourceDemandingBehavior(pcm::ResourceDemandingInternalBehaviour behavior) { 
	match {
		val componentClass = retrieve java::Class corresponding to behavior.basicComponent_ResourceDemandingInternalBehaviour
	} 
	action { 
		val javaMethod = create java::ClassMethod and initialize {
			javaMethod.name = behavior.entityName;
			javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid;
		}
		add correspondence between javaMethod and behavior
		update componentClass {
			componentClass.members += javaMethod;
		}
	}
}

reaction RenameResourceDemandingInternalBehavior { 
	after value replaced for pcm::ResourceDemandingInternalBehaviour[entityName]
	call renameMethodForResourceDemandingBehavior(change.affectedEObject)
}

routine renameMethodForResourceDemandingBehavior(pcm::ResourceDemandingInternalBehaviour behavior) { 
	match {
		val javaMethod = retrieve java::ClassMethod corresponding to behavior
	} 
	action { 
		update javaMethod {
			javaMethod.name = behavior.entityName;
		}
	}
}

reaction DeletedDemandingInternalBehavior { 
	after list entry deleted and removed in pcm::BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
	call deleteMethodForResourceDemandingBehavior(change.oldValue)
}

routine deleteMethodForResourceDemandingBehavior(pcm::ResourceDemandingInternalBehaviour behavior) {
	match {
		val javaMethod = retrieve java::ClassMethod corresponding to behavior
	} action { 
		delete javaMethod
	}
}

// ################################################################################
// #################################### SEFFS #####################################

reaction CreatedSEFF { 
	after list entry created and inserted in pcm::BasicComponent[serviceEffectSpecifications__BasicComponent]
	call createSEFF(change.newValue)
}

routine createSEFF(pcm::ServiceEffectSpecification seff) { 
	match {
		val componentClass = retrieve java::Class corresponding to seff.basicComponent_ServiceEffectSpecification
		val interfaceMethod = retrieve java::InterfaceMethod corresponding to seff.describedService__SEFF
		check seff.describedService__SEFF instanceof OperationSignature
	} 
	action { 
		val classMethod = create java::ClassMethod and initialize  {
			initializeClassMethod(classMethod, interfaceMethod, true);
		}
		add correspondence between classMethod and seff
		// TODO HK This is not completely in the context of the component class, but in contained elements...
		update componentClass {
			var correspondingClassMethod = componentClass.findMethodInClass(classMethod)
			if (null == correspondingClassMethod) {
				componentClass.members.add(classMethod)
				correspondingClassMethod = classMethod
			} else {
				correspondingClassMethod.name = interfaceMethod.name
			}
		}
	}
}

reaction ChangeOperationSignatureOfSeff { 
	after value replaced for pcm::ResourceDemandingSEFF[describedService__SEFF]
	call changeMethodForSeff(change.affectedEObject)
}

routine changeMethodForSeff(pcm::ResourceDemandingSEFF seff) { 
	match {
		val oldClassMethod = retrieve optional java::ClassMethod corresponding to seff
	} 
	action { 
		delete oldClassMethod
		call createSEFF(seff)
	}
}

routine updateSEFFImplementingMethodName(pcm::ServiceEffectSpecification seff) { 
	match {
		val classMethod = retrieve java::ClassMethod corresponding to seff
	} 
	action { 
		update classMethod {
			classMethod.name = seff.describedService__SEFF.entityName;
		}
	}
}

reaction DeletedSeff { 
	after list entry deleted and removed in pcm::BasicComponent[serviceEffectSpecifications__BasicComponent]
	call deleteMethodForSeff(change.oldValue)
}

routine deleteMethodForSeff(pcm::ServiceEffectSpecification seff) { 
	match {
		val classMethod = retrieve java::ClassMethod corresponding to seff
	} 
	action { 
		delete classMethod
	}
}



