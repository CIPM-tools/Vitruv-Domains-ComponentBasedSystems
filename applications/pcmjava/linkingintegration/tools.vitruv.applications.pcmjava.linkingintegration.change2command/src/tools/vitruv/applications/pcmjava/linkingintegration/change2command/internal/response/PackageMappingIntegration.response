import org.emftext.language.java.members.Method
import org.eclipse.emf.ecore.util.EcoreUtil
import org.emftext.language.java.members.Field
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.repository.RepositoryFactory
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.DataType
import org.emftext.language.java.modifiers.Public
import org.emftext.language.java.modifiers.Private
import org.emftext.language.java.modifiers.Protected
import com.google.common.collect.Sets
import tools.vitruv.framework.correspondence.CorrespondenceModelUtil
import tools.vitruv.framework.userinteraction.UserInteractionType
import tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

// TODO We can convert several custom statements to response language statements, e.g. correspondence creation, element creation
response collection: PackageMappingIntegration
from metamodel java to metamodel pcm

//empty implementation for add and remove imports
response: AddImportResponse {
	after list entry inserted java.JavaRoot[imports]
	call {}
}

response: RemoveImportResponse {
	after list entry removed java.JavaRoot[imports]
	call {}
}

response: RenameMethod {
	after value replaced java.Method[name]
	call renamedMethod(change.affectedEObject, change.newValue)
}

routine: renamedMethod(java.Method method, String newMethodName) {
	match {
		retrieve required element pcm.OperationSignature as operationSignature corresponding to method
	}
	effect {
		update element operationSignature {
			operationSignature.entityName = newMethodName
			//EvaluationHelper.instance.logChange2ActionHandeldByIntegrationResponse(change, "renamed operation signature " + operationSignature + " to " + change.newValue)
		}
	} 
}

response: RemoveMethodEvent {
	after list entry removed java.ConcreteClassifier[members]
		with { 
			if (change.oldValue instanceof Method){
			// EvaluationHelper.
				return true
			}	
			return false
		}
	call removedMethodEvent(change.oldValue as Method)
} 

routine: removedMethodEvent(java.Method method) {
	match {
		retrieve required element pcm.OperationSignature as opSig corresponding to method
	}
	effect {
		remove correspondence between opSig and method
		update element opSig {
			EcoreUtil.remove(opSig)
		}
	}
}

response: AddMethodEvent {
	after list entry inserted java.ConcreteClassifier[members]
		with change.newValue instanceof Method
	call addedMethodEvent(change.affectedEObject, change.newValue as Method)
}

routine: addedMethodEvent(java.ConcreteClassifier clazz, java.Method method) {
	match {
		retrieve required element pcm.OperationInterface as opInterface corresponding to clazz
	}
	effect {
		call {	
			createOperationSignature(opInterface, method)
		}
	}
}

routine: createOperationSignature(pcm.OperationInterface opInterface, java.Method newMethod) {
	effect {
		update element newMethod {
			// ask user whether to add the new method to the operationInterface
			val selection = userInteracting.selectFromMessage(UserInteractionType.MODAL, "Should the new method " + 
				newMethod.name + " be part of the OperationInterface "+ opInterface.entityName+ "? " , "Yes", "No")
			if(selection == 0){
				var OperationSignature opSig = RepositoryFactory.eINSTANCE.createOperationSignature
				opSig.entityName = newMethod.name
				opSig.interface__OperationSignature = opInterface
				CorrespondenceModelUtil.createAndAddCorrespondence(correspondenceModel, opSig, newMethod)
			}
		}
	}
}

response: CreateMetodParameterEvent {
	after list entry inserted java.Method[parameters]
	call createdMethodParameterEvent(change.affectedEObject, change.newValue)
}

routine: createdMethodParameterEvent(java.Method method, java.Parameter parameter) {
	match {
		retrieve required element pcm.OperationSignature as opSignature corresponding to method
	}
	effect {
		add correspondence between opSignature and parameter
		update element opSignature {
			userInteracting.showMessage(UserInteractionType.MODAL, "Created new parameter for OperationSiganture" + opSignature)
			val pcmParameter = RepositoryFactory.eINSTANCE.createParameter
			pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.
				getCorrespondingPCMDataTypeForTypeReference(parameter.typeReference, correspondenceModel,
					userInteracting, opSignature.interface__OperationSignature.repository__Interface, parameter.arrayDimension)
			pcmParameter.entityName = parameter.name
		}
	}
}

response: MethodParameterNameChangeEvent {
	after value replaced java.Parameter[name]
	call methodParameterNameChangedEvent(change.affectedEObject, change.oldValue, change.newValue)
}

routine: methodParameterNameChangedEvent(java.Parameter parameter, String oldParameterName, String newParameterName) {
	match { 
		retrieve required element pcm.Parameter as pcmParam corresponding to parameter
	}
	effect {
		update element pcmParam {
			userInteracting.showMessage(UserInteractionType.MODAL, "Renamed method parameter " + oldParameterName +  " to " + newParameterName)
			pcmParam.entityName = newParameterName
		}
	}
}	

response: ChangeMethodTypeEvent {
	after value replaced java.Method[typeReference]
	call changedMethodType(change.affectedEObject, change.newValue)
}
	
routine: changedMethodType(java.Method method, java.TypeReference newType) {
	match { 	
		retrieve required element pcm.OperationSignature as opSignature corresponding to method
	}
	effect {
		update element opSignature {
			val Repository repo = opSignature.interface__OperationSignature.repository__Interface
			val DataType newReturnValue = TypeReferenceCorrespondenceHelper.
				getCorrespondingPCMDataTypeForTypeReference(newType,
					correspondenceModel, userInteracting, repo, method.arrayDimension)
			opSignature.returnType__OperationSignature = newReturnValue
			userInteracting.showMessage(UserInteractionType.MODAL, "Changed return type of opSig to " + newReturnValue)
		}
	}
}

response: RemoveFieldEvent {
	after list entry removed java.ConcreteClassifier[members]
		with change.oldValue instanceof Field
	call removedFieldEvent(change.oldValue as Field)
}
	
routine: removedFieldEvent(java.Field field) {
	match { 
		retrieve required element pcm.NamedElement as namedElement corresponding to field
	}	
	effect {
		remove correspondence between field and namedElement
		update element field {
			userInteracting.showMessage(UserInteractionType.MODAL, "Removed " + namedElement + " because the corresponding field " + field + " has been removed"  )
			// TODO This is wrong, isnt't it? Should be "namedElement"!?
			EcoreUtil.remove(field)
		}
	}
}
	
response: AddFieldEvent {
	after list entry inserted java.ConcreteClassifier[members]
		with change.newValue instanceof Field
	call addedFieldEvent(change.affectedEObject, change.newValue as Field)
}

routine: addedFieldEvent(java.ConcreteClassifier clazz, java.Field field) {
	match {
		retrieve required element pcm.BasicComponent as basicComponent corresponding to clazz
		retrieve required element pcm.OperationInterface as opInterface corresponding to field.typeReference
	}
	effect {
		call {
			//new Field with PCM Type corresponding to an OperationInterface has been added in basic component --> created requrired role
			createRequiredRole(basicComponent, opInterface, field)
		}
	}
}

routine: createRequiredRole(pcm.BasicComponent basicComponent, pcm.OperationInterface opInterface, java.Field field) {
	effect {
		create element pcm.OperationRequiredRole as opRequiredRole
		add correspondence between opRequiredRole and field
		update element opRequiredRole {
			opRequiredRole.requiredInterface__OperationRequiredRole = opInterface
			opRequiredRole.requiringEntity_RequiredRole = basicComponent
			userInteracting.showMessage(UserInteractionType.MODAL, "Create OperationRequiredRole between Component " + 
				basicComponent.entityName + " and Interface " + opInterface.entityName)	
		}
	}
}

response: ChangeFieldTypeEvent {
	after value replaced java.Field[typeReference]
	call changedFieldTypeEvent(change.affectedEObject, change.oldValue, change.newValue)
}

routine: changedFieldTypeEvent(java.Field field, java.TypeReference oldType, java.TypeReference newType) {
	match {
		retrieve optional element pcm.OperationInterface as oldCorrespondingOpInterface corresponding to oldType
		retrieve optional element pcm.OperationInterface as opInterface corresponding to newType
		retrieve optional element pcm.OperationRequiredRole as opRequiredRole corresponding to field
		retrieve required element pcm.BasicComponent as basicComponent corresponding to field.containingConcreteClassifier
	}
	effect {
		call {
			if(null != oldCorrespondingOpInterface && null != opInterface && null != opRequiredRole){
				// reset required role 
				userInteracting.showMessage(UserInteractionType.MODAL, "the operation required role has been changed")
				opRequiredRole.requiredInterface__OperationRequiredRole = opInterface
				return
			}
			if(null == oldCorrespondingOpInterface && null != opInterface){
				// new required role needs to be added 
				userInteracting.showMessage(UserInteractionType.MODAL, "Create OperationRequiredRole between Component " + 
					basicComponent.entityName + " and Interface " + opInterface.entityName)
				createRequiredRole(basicComponent, opInterface, field)
				return
			}
			if(null != oldCorrespondingOpInterface && null == opInterface && null != opRequiredRole){
				// remove required role and correspondence
				userInteracting.showMessage(UserInteractionType.MODAL, "Remove OperationRequiredRole between Component " + 
					basicComponent.entityName + " and Interface " + oldCorrespondingOpInterface.entityName)
				removeRequiredRoleAndCorrespondence(opRequiredRole, field)
			}
		}
	}
}
	

routine: removeRequiredRoleAndCorrespondence(pcm.OperationRequiredRole orr, java.Field field) {
	effect {
		remove correspondence between orr and field
		update element orr {
			EcoreUtil.delete(orr)
		}
	}
}

// empty implementation for changeFieldModifier, because the change is not architectural relevant
response: ChangeFieldModifierEvent {
	after list entry inserted java.Field[annotationsAndModifiers]
	call { }
}

response: RemoveFieldModifierEvent {
	after list entry removed java.Field[annotationsAndModifiers]
	call { }
}

// if the method was public and had a corresponding opSig--> ask user whether to delete the correspondence
// if the method was non-public and is public now and the classifier has a corresponding interface 
//--> ask user whether to add the signature to the corresponding interface 
response: ChangeMethodModifierEvent {
	after list entry inserted java.Method[annotationsAndModifiers]
	call changedMethodModifierEvent(change.affectedEObject, change.newValue)
}

routine: changedMethodModifierEvent(java.Method method, java.AnnotationInstanceOrModifier annotationOrModifier) {
	match {
		retrieve optional element pcm.OperationSignature as operationSignature corresponding to method
		retrieve required element pcm.OperationInterface as operationInterface corresponding to method.containingConcreteClassifier
	}
	effect {
		call {
			if (annotationOrModifier instanceof Public){ 
				//new public method created	
				createOperationSignature(operationInterface, method)
				return
			} else if (null!=operationSignature &&(annotationOrModifier instanceof Protected || annotationOrModifier instanceof Private)){		
				// public method with corresponding signature has been deleted
				userInteracting.showMessage(UserInteractionType.MODAL, "Public method with correspondence has been made private. 
					The corresponding operaitonSignature " + operationSignature.entityName + " will be deleted as well.")
				correspondenceModel.removeCorrespondencesThatInvolveAtLeastAndDependend(Sets.newHashSet(operationSignature))
				EcoreUtil.remove(operationSignature)
				return
			}
		}
	}
}

	