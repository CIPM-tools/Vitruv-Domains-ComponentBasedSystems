import tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper
import org.emftext.language.java.commons.NamedElement
import org.emftext.language.java.members.Field
import org.emftext.language.java.members.InterfaceMethod

import static tools.vitruv.applications.pcmjava.ejbtransformations.java2pcm.EJBJava2PcmHelper.*

import static extension tools.vitruv.applications.pcmjava.ejbtransformations.java2pcm.EJBAnnotationHelper.*
import org.emftext.language.java.members.ClassMethod
import tools.vitruv.applications.pcmjava.ejbtransformations.java2pcm.EJBJava2PcmHelper
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.RepositoryFactory
import java.util.Collections
import org.palladiosimulator.pcm.repository.OperationInterface
import org.palladiosimulator.pcm.repository.OperationSignature
import tools.vitruv.framework.correspondence.CorrespondenceModelUtil

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

response collection: ejbjava2pcm
from metamodel java to metamodel pcm

// ###################################################
// ################ create Repository for first package################
response: CreatedFirstPackage {
	after root created java.Package
	call createRepositoryForFirstPackage(change.newValue)
}

routine: createRepositoryForFirstPackage(java.Package javaPackage) {
	effect {
		call {
			if (null == EJBJava2PcmHelper.findRepository(correspondenceModel)){
				val Repository repository = RepositoryFactory.eINSTANCE.createRepository
				repository.setEntityName(javaPackage.name)
				persistProjectRelative(javaPackage, repository, "model/" + repository.entityName + ".repository")
				correspondenceModel.createAndAddCorrespondence(Collections.singletonList(repository), Collections.singletonList(javaPackage))
			}		
		}
	}
}

// ###################################################
// ################ create Component from EJB class################
 
response: CreatedClass {
	after list entry inserted java.CompilationUnit[classifiers]
		with change.newValue.isEJBClass 	
	call {
		val Repository repo = EJBJava2PcmHelper.findRepository(correspondenceModel)
		createBasicComponent(repo, change.newValue);
	} 
}

response: CreateClassAnnotation {
	after list entry inserted java.Class[annotationsAndModifiers]
		with change.affectedEObject.isEJBClass 
	call {
		val Repository repo = EJBJava2PcmHelper.findRepository(correspondenceModel) 
		createBasicComponent(repo, change.affectedEObject as NamedElement)
	} 
}

routine: createBasicComponent(pcm.Repository repo, java.NamedElement namedElement) {
	effect {
		create element pcm.BasicComponent as basicComponent
		add correspondence between basicComponent and namedElement
		update element basicComponent {
			basicComponent.entityName = namedElement.name;
			repo.components__Repository.add(basicComponent);		
		}
	}
}
	
// ###################################################
// ################ create Interface from EJB interface################

response: CreatedInterface {
	after list entry inserted java.CompilationUnit[classifiers]
		with change.newValue.isEJBBuisnessInterface 
	call {
		val Repository repo = EJBJava2PcmHelper.findRepository(correspondenceModel)
		createOperationInterface(repo, change.newValue)
	}
}

response: CreateInterfaceAnnotation {
	after list entry inserted java.Interface[annotationsAndModifiers]
		with change.affectedEObject.isEJBBuisnessInterface
	call {
		val Repository repo = EJBJava2PcmHelper.findRepository(correspondenceModel)
		createOperationInterface(repo, change.affectedEObject as NamedElement)
	}
}

routine: createOperationInterface(pcm.Repository repo, java.NamedElement namedElement) {
	effect { 
		create element pcm.OperationInterface as operationInterface
		add correspondence between operationInterface and namedElement
		update element operationInterface {
			operationInterface.entityName = namedElement.name;
			repo.interfaces__Repository.add(operationInterface);		
		}
	}
}

// ###################################################
// ################ create OperationRequiredRole from field################
response: CreateAnnotationForField {
	after list entry inserted java.Field[annotationsAndModifiers]
		with change.affectedEObject.hasEJBAnnotation
	call createdAnnotationForField(change.affectedEObject)
}
		
routine: createdAnnotationForField(java.Field annotatedField) {
	match {
		retrieve required element pcm.BasicComponent as basicComponent corresponding to annotatedField.containingConcreteClassifier
		//retrieve required element: pcm.OperationInterface as opInterface corresponding to change.affectedEObject 
	}
	effect {
		call {
			val interfaceName = getClassifier(annotatedField.typeReference).name
			val opInterface = basicComponent.repository__RepositoryComponent.interfaces__Repository.filter(typeof(OperationInterface)).findFirst[it.entityName.equals(interfaceName)]
			createOperationRequiredRole(basicComponent, opInterface, annotatedField)
		}
	}
}

response: CreateField {
	after list entry inserted java.Class[members]
		with change.newValue.hasEJBAnnotation
	call createdField(change.newValue as Field)
}

routine: createdField(java.Field field) {
	match {
		retrieve required element pcm.BasicComponent as basicComponent corresponding to field
		//retrieve required element: pcm.OperationInterface as opInterface corresponding to change.newValue
	}
	effect {
		call {
			val interfaceName = getClassifier(field.typeReference).name
			val opInterface = basicComponent.repository__RepositoryComponent.interfaces__Repository.filter(typeof(OperationInterface)).findFirst[it.entityName.equals(interfaceName)]
			createOperationRequiredRole(basicComponent, opInterface, field)
		}
	}
}


routine: createOperationRequiredRole(pcm.BasicComponent basicComponent, pcm.OperationInterface opInterface, java.Field field) {
	effect { 
		create element pcm.OperationRequiredRole as orr
		add correspondence between orr and field 
		update element orr  {
			orr.requiringEntity_RequiredRole = basicComponent
			orr.requiredInterface__OperationRequiredRole = opInterface
			orr.entityName = basicComponent.entityName + "_requires_" + opInterface.entityName	
		}
	}
}

// ###################################################
// ################ create OperationProvidedRole from implements################
response: CreateImplements {
	after list entry inserted java.Class[implements]
	call createdImplements(change.affectedEObject, change.newValue)
}

routine: createdImplements(java.Class clazz, java.TypeReference implementz) {
	match {
		retrieve required element pcm.BasicComponent as basicComponent corresponding to clazz
		//retrieve required element: pcm.OperationInterface as opInterface corresponding to getClassifier(change.newValue) 
	}
	effect {
		create element pcm.OperationProvidedRole as opr
		//add correspondence: opr, change.newValue
		update element opr {
	    	val opInterface = basicComponent.repository__RepositoryComponent.interfaces__Repository.filter(typeof(OperationInterface)).
	    			findFirst[it.entityName.equals(getClassifier(implementz).name)]
	    	if (null != opInterface){
				opr.providedInterface__OperationProvidedRole = opInterface
				opr.providingEntity_ProvidedRole = basicComponent
				opr.entityName = basicComponent.entityName + "_provides_" + opInterface.entityName
				correspondenceModel.createAndAddCorrespondence(Collections.singletonList(opr), Collections.singletonList(implementz))
			}
		}
	}
}

// ###################################################
// ################ create Signatures for interface methods################

response: CreateInterfaceMethod {
	after list entry inserted java.Interface[members]
		with change.newValue instanceof InterfaceMethod && change.affectedEObject.isEJBBuisnessInterface
	call createdInterfaceMethod(change.affectedEObject, change.newValue as InterfaceMethod)
}

routine: createdInterfaceMethod(java.Interface interf, java.InterfaceMethod method) {
	match {
		retrieve required element pcm.OperationInterface as opInterface corresponding to interf
	}
	effect {
		call createOperationSignature(method, opInterface)
	}
}

routine: createOperationSignature(java.InterfaceMethod interfaceMethod, pcm.OperationInterface opInterface) {
	effect {
		create element pcm.OperationSignature as opSignature
		add correspondence between opSignature and interfaceMethod
		call {
			opSignature.entityName = interfaceMethod.name
			opInterface.signatures__OperationInterface.add(opSignature)
			interfaceMethod.parameters.forEach[createPCMParameter(opSignature)]
			interfaceMethod.typeReference.createPCMReturnType(opSignature, interfaceMethod)
		}
	}
}

// #######################################################################
// ################ create Parameter for  parameter################		
response: CreateParameterInInterfaceMethod {
	after list entry inserted java.InterfaceMethod[parameters]
	call createdParameterInInterfaceMethod(change.affectedEObject, change.newValue)
}

routine: createdParameterInInterfaceMethod(java.InterfaceMethod method, java.Parameter parameter) {
	match {
		retrieve required element pcm.OperationSignature as opSignature corresponding to method
	}
	effect {
		call createPCMParameter(parameter, opSignature)
	}
}

routine: createPCMParameter(java.Parameter jaMoPPParam, pcm.OperationSignature opSignature) {
	effect {
		create element pcm.Parameter as pcmParameter
		//add correspondence: pcmParameter, jaMoPPParam
		update element pcmParameter {
			pcmParameter.entityName = jaMoPPParam.name
			pcmParameter.parameterName = jaMoPPParam.name
			pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.getCorrespondingPCMDataTypeForTypeReference(jaMoPPParam.typeReference, 
				correspondenceModel, userInteracting, opSignature.interface__OperationSignature.repository__Interface, jaMoPPParam.arrayDimension)
			opSignature.parameters__OperationSignature.add(pcmParameter)
			//add correspondence here, because otherwise TUID calculation may be fail since type and name are null
			correspondenceModel.createAndAddCorrespondence(Collections.singletonList(pcmParameter), Collections.singletonList(jaMoPPParam))
		}
	}
}
	
// #######################################################################
// ################ create ReturnType for return type ################
response: ReturnTypeCreated {
	after value replaced java.InterfaceMethod[typeReference]
	call createdReturnType(change.affectedEObject, change.newValue)
}

routine: createdReturnType(java.InterfaceMethod method, java.TypeReference type) {
	match {
		retrieve required element pcm.OperationSignature as opSignature corresponding to method
	}
	effect {
		call createPCMReturnType(type, opSignature, method)
	}
}

routine: createPCMReturnType(java.TypeReference returnType, pcm.OperationSignature opSignature, java.Method javaMethod) {
	effect {
		call {
			val pcmDataType = TypeReferenceCorrespondenceHelper.getCorrespondingPCMDataTypeForTypeReference(returnType, correspondenceModel, userInteracting, 
					opSignature.interface__OperationSignature.repository__Interface, javaMethod.arrayDimension
			)
			opSignature.returnType__OperationSignature = pcmDataType
		}
	}
}

// #######################################################################
// ################ create InnerDeclaration for field in datatype class################
response: CreateFieldInDatatypeClass {
	after list entry inserted java.Class[members]
		with change.newValue instanceof Field
	call createdFieldInDatatypeClass(change.affectedEObject, change.newValue as Field)
}

routine: createdFieldInDatatypeClass(java.Class clazz, java.Field field) {
	match { 
		retrieve required element pcm.CompositeDataType as compositeDataType corresponding to clazz
	}
	effect {
		create element pcm.InnerDeclaration as innerDec
		add correspondence between innerDec and field
		update element innerDec {
			innerDec.datatype_InnerDeclaration = TypeReferenceCorrespondenceHelper.
					getCorrespondingPCMDataTypeForTypeReference(field.typeReference, correspondenceModel,
						userInteracting, compositeDataType.repository__DataType, field.arrayDimension)
			innerDec.entityName = field.name
			compositeDataType.innerDeclaration_CompositeDataType.add(innerDec)
		}
	}
}

// #############################################################################################
// ################ create SEFF for class method that overrides interface method################

response: CreateClassMethodInEJBClass {
	after list entry inserted java.Class[members]
		with change.newValue instanceof ClassMethod && change.affectedEObject.isEJBClass &&
	   		EJBJava2PcmHelper.overridesInterfaceMethod(change.newValue as ClassMethod, change.affectedEObject)
	call createdClassMethodInEJBClass(change.affectedEObject, change.newValue as ClassMethod)
}

routine: createdClassMethodInEJBClass(java.Class clazz, java.ClassMethod classMethod) {
	match {
		retrieve required element pcm.BasicComponent as basicComponent corresponding to clazz
	}
	effect { 
		call {
			val method = getOoverridenInterfaceMethod(classMethod, clazz)
			val correspondingEObjects = CorrespondenceModelUtil.getCorrespondingEObjectsByType(correspondenceModel, method, OperationSignature)
			var OperationSignature opSignature = null
			if(!correspondingEObjects.nullOrEmpty){
				opSignature = correspondingEObjects.get(0)			
			}
			createSEFFForClassMethod(basicComponent, opSignature, classMethod)
		}
	}
}

routine: createSEFFForClassMethod(pcm.BasicComponent basicComponent, pcm.OperationSignature opSignature, java.ClassMethod classMethod) {
	effect {
		create element pcm.ResourceDemandingSEFF as seff
		add correspondence between seff and classMethod
		update element seff {
			seff.describedService__SEFF = opSignature
			basicComponent.serviceEffectSpecifications__BasicComponent.add(seff)
		}	
	}
}
