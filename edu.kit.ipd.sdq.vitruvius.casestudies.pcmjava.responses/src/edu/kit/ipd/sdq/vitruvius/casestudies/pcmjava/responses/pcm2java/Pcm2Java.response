import org.eclipse.emf.ecore.util.EcoreUtil
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import org.palladiosimulator.pcm.repository.InnerDeclaration
import com.google.common.collect.Sets
import org.emftext.language.java.statements.ExpressionStatement
import org.emftext.language.java.expressions.AssignmentExpression
import org.emftext.language.java.references.SelfReference
import org.emftext.language.java.references.IdentifierReference
import org.emftext.language.java.statements.Statement
import java.util.Collection
import java.util.Set
import java.util.HashSet
import java.util.ArrayList
import java.util.LinkedList
import java.util.Vector
import java.util.Stack
import java.util.List
import edu.kit.ipd.sdq.vitruvius.framework.contracts.datatypes.UserInteractionType
import org.emftext.language.java.generics.GenericsFactory
import static extension edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.responses.pcm2java.Pcm2JavaHelper.*
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.emftext.language.java.types.TypeReference
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.emftext.language.java.types.PrimitiveType
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.members.Field

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

responses from metamodel pcm to metamodel java
called pcm2java

// ###################################################
// ################ PACKAGE RESPONSES ################


response: CreatePackagesForRepository
trigger: insert root pcm.Repository
execute: {
	val repository = change.newValue;
	callCreateJavaPackage(repository, null, repository.entityName, "repository_root");
	callCreateRepositorySubPackages(repository);
}

effect: CreateRepositorySubPackages
input: pcm.Repository as repository
retrieve element: java.Package as repositoryPackage corresponding to repository
execute: {
	callCreateJavaPackage(repository, repositoryPackage, "datatypes", "datatypes");
	callCreateJavaPackage(repository, repositoryPackage, "contracts", "contracts");
}

response: RenamedRepositoryPackages
trigger: replace value pcm.Repository[entityName]
retrieve element: java.Package as rootPackage corresponding to change.newAffectedEObject
	tagged with "repository_root"
	move containing model to project-relative location: buildJavaFilePath(rootPackage)
execute: {
	val repository = change.newAffectedEObject as Repository;
	rootPackage.name = change.newValue;
	callRenameJavaPackage(repository, rootPackage, "contracts", "contracts");
	callRenameJavaPackage(repository, rootPackage, "datatypes", "datatypes");	
	for (component : repository.components__Repository.filter(BasicComponent)) {
		callRenameComponentPackageAndClass(component);
	}
	for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
		callRenameInterface(interface);
	}
	for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
		callRenameCompositeDataType(dataType);
	}
	for (dataType : repository.dataTypes__Repository.filter(CollectionDataType)) {
		callRenameCollectionDataType(dataType);
	}
}



// ################################################################################
// ############################# COMPOSED STRUCTURES ##############################

response: CreatedSystem
trigger: insert root pcm.System
execute: {
	val system = change.newValue;
	callCreateJavaPackage(system, null, system.entityName, "root_system");
	callCreateImplementationForSystem(system);
}

effect: CreateImplementationForSystem
input: pcm.System as system
retrieve element: java.Package as systemPackage corresponding to system
execute: callCreateJavaClass(system, systemPackage, system.entityName + "Impl")

response: ChangedSystemName
trigger: replace value pcm.System[entityName]
retrieve element: java.Package as systemPackage corresponding to change.newAffectedEObject
execute: {
	val system = change.newAffectedEObject as org.palladiosimulator.pcm.system.System;
	callRenameJavaPackage(system, null, system.entityName, null);
	callRenameJavaClassifier(system, systemPackage, system.entityName + "Impl");
}

response: AddedAssemblyContextToComposedStructure
trigger: insert in list pcm.ComposedStructure[assemblyContexts__ComposedStructure]
retrieve element: java.Class as compositeComponentJavaClass corresponding to change.newAffectedEObject
execute: callAddAssemblyContextToComposedStructure(compositeComponentJavaClass, change.newValue)

effect: AddAssemblyContextToComposedStructure
input: java.Class as compositeComponentClass, pcm.AssemblyContext as assemblyContext
retrieve element: java.Class as encapsulatedComponentJavaClass corresponding to assemblyContext.encapsulatedComponent__AssemblyContext
create element: java.Field as assemblyContextField corresponding to assemblyContext
create element: java.NewConstructorCall as newConstructorCall corresponding to assemblyContext
create element: java.ClassifierImport as contextClassImport corresponding to assemblyContext
create element: java.Constructor as constructor corresponding to assemblyContext
execute: {
	val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
	createPrivateField(assemblyContextField, typeRef, assemblyContext.entityName);
	compositeComponentClass.members += assemblyContextField;
	addConstructorToClass(constructor, compositeComponentClass)
	addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentClass, encapsulatedComponentJavaClass)
	createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
}

// #####################################################
// ################ COMPONENT RESPONSES ################

response: CreateComponent
trigger: insert in list pcm.Repository[components__Repository]
retrieve element: java.Package as repositoryPackage corresponding to change.newValue.repository__RepositoryComponent
	with change.newValue.repository__RepositoryComponent.entityName.equals(repositoryPackage.name)
execute: {
	val component = change.newValue;
	callCreateJavaPackage(component, repositoryPackage, component.entityName, null);
	callCreateImplementationForComponent(component);
}

effect: CreateImplementationForComponent
input: pcm.RepositoryComponent as component
retrieve element: java.Package as componentPackage corresponding to component
execute: callCreateJavaClass(component, componentPackage, component.entityName + "Impl")

response: RenameComponent
trigger: replace value pcm.RepositoryComponent[entityName]
execute: {
	val component = change.newAffectedEObject as RepositoryComponent;
	callRenameComponentPackageAndClass(component);
}

effect: RenameComponentPackageAndClass
input: pcm.RepositoryComponent as component
retrieve element: java.Package as repositoryPackage corresponding to component.repository__RepositoryComponent
	with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
execute: {
	callRenameJavaPackage(component, repositoryPackage, component.entityName, null);
	callRenameComponentClass(component);
}

effect: RenameComponentClass
input: pcm.RepositoryComponent as component
retrieve element: java.Package as componentPackage corresponding to component
execute: callRenameJavaClassifier(component, componentPackage, component.entityName + "Impl")

response: DeleteComponentClass
trigger: remove from list pcm.Repository[components__Repository]
execute: callDeleteJavaClassifier(change.oldValue)

response: DeletePackageForBasicComponent
trigger: remove from list pcm.Repository[components__Repository]
execute: callDeleteJavaPackage(change.oldValue, change.oldValue.entityName, "")


// #####################################################
// ################ INTERFACE RESPONSES ################

response: CreateInterface
trigger: insert in list pcm.Repository[interfaces__Repository]
retrieve element: java.Package as contractsPackage corresponding to change.newAffectedEObject
	with contractsPackage.name == "contracts"
execute: {
	val interf = change.newValue;
	callCreateJavaInterface(interf, contractsPackage, interf.entityName);
}

response: RenamedInterface
trigger: replace value pcm.Interface[entityName]
execute: callRenameInterface(change.newAffectedEObject as OperationInterface)

effect: RenameInterface
input: pcm.OperationInterface as interf
retrieve element: java.Package as contractsPackage corresponding to interf.repository__Interface
	with contractsPackage.name == "contracts"
execute: callRenameJavaClassifier(interf, contractsPackage, interf.entityName)


// ######################################################
// ################ DATA TYPES RESPONSES ################

response: CreatedCompositeDataType
trigger: insert in list pcm.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CompositeDataType
retrieve element: java.Package as datatypesPackage corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
execute: {
	val compositeDataType = change.newValue as CompositeDataType;
	callCreateJavaClass(compositeDataType, datatypesPackage, compositeDataType.entityName);
}

response: RenamedCompositeDataType
trigger: replace value pcm.CompositeDataType[entityName]
execute: callRenameCompositeDataType(change.newAffectedEObject as CompositeDataType)

effect: RenameCompositeDataType
input: pcm.CompositeDataType as compositeDataType
retrieve element: java.Package as datatypesPackage corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
execute: callRenameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)

response: RemovedCompositeDataType
trigger: remove from list pcm.Repository[dataTypes__Repository]
precondition: change.oldValue instanceof CompositeDataType
execute: callDeleteJavaClassifier(change.oldValue as CompositeDataType)

response: CreatedCollectionDataType
trigger: insert in list pcm.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CollectionDataType
retrieve element: java.Class as innerTypeClass corresponding to (change.newValue as CollectionDataType).innerType_CollectionDataType
	on fail do nothing and continue effect
retrieve element: java.Package as datatypesPackage corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
execute: {
	// create correct (and in case of primitive types wrapped) type reference for the inner type
	val dataType = change.newValue as CollectionDataType;
	val innerTypeRef = createTypeReference(dataType.innerType_CollectionDataType, innerTypeClass);
	var innerTypeClassOrWrapper = innerTypeRef;
	if (innerTypeRef instanceof PrimitiveType) {
		innerTypeClassOrWrapper = getWrapperTypeReferenceForPrimitiveType(innerTypeRef);
	}
	
	// Let user select the class to map the collection type to
	var Set<Class<? extends Collection>> collectionDataTypes = new HashSet
	collectionDataTypes += #[ArrayList, LinkedList, Vector, Stack, HashSet]
	val List<String> collectionDataTypeNames = new ArrayList<String>(collectionDataTypes.size)
	for (collectionDataType : collectionDataTypes) {
		collectionDataTypeNames.add(collectionDataType.name)
	}
	val String selectTypeMsg = "Please select type (or interface) that should be used for the type"
	val int selectedType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectTypeMsg,
		collectionDataTypeNames)
	val Class<? extends Collection> selectedClass = collectionDataTypes.get(selectedType)
	
	callCreateJavaClass(dataType, datatypesPackage, dataType.entityName);
	callAddSuperTypeToDataType(dataType, innerTypeClassOrWrapper, selectedClass.name);
}

effect: AddSuperTypeToDataType
input: pcm.DataType as dataType, java.TypeReference as innerTypeReference, String as superTypeQualifiedName
retrieve element: java.Class as dataTypeImplementation corresponding to dataType
retrieve element: java.CompilationUnit as dataTypeImplementationCU corresponding to dataType
create element: java.NamespaceClassifierReference as namespaceClassifier corresponding to dataType
execute: {
	val collectionTypeClassImport = getJavaClassImport(superTypeQualifiedName);
	dataTypeImplementationCU.imports += collectionTypeClassImport;
	createNamespaceClassifierReference(namespaceClassifier, collectionTypeClassImport.classifier);
	val qualifiedTypeArgument = GenericsFactory.eINSTANCE.createQualifiedTypeArgument();
	qualifiedTypeArgument.typeReference = innerTypeReference;
	namespaceClassifier.classifierReferences.get(0).typeArguments += qualifiedTypeArgument;
	dataTypeImplementation.extends = namespaceClassifier;
}

response: RenamedCollectionDataType
trigger: replace value pcm.CollectionDataType[entityName]
execute: callRenameCollectionDataType(change.newAffectedEObject as CollectionDataType)

effect: RenameCollectionDataType
input: pcm.CollectionDataType as collectionDataType
retrieve element: java.Package as datatypesPackage corresponding to collectionDataType.repository__DataType with datatypesPackage.name == "datatypes"
execute: callRenameJavaClassifier(collectionDataType, datatypesPackage, collectionDataType.entityName)

response: RemovedCollectionDataType
trigger: remove from list pcm.Repository[dataTypes__Repository]
precondition: change.oldValue instanceof CollectionDataType
execute: callDeleteJavaClassifier(change.oldValue as CollectionDataType)


// ################ DATA TYPES - INNER DECLARATION RESPONSES ################

response: AddedInnerDeclarationToCompositeDataType
trigger: insert in list pcm.CompositeDataType[innerDeclaration_CompositeDataType]
retrieve element: java.Class as nonPrimitiveInnerDataTypeClass corresponding to change.newValue.datatype_InnerDeclaration
	on fail do nothing and continue effect
execute: {
	val innerDataTypeReference = createTypeReference(change.newValue.datatype_InnerDeclaration, nonPrimitiveInnerDataTypeClass);
	val compositeDataType = change.newAffectedEObject as CompositeDataType;
	val innerDeclaration = change.newValue;
	callAddInnerDeclarationToCompositeDataType(compositeDataType, innerDeclaration, innerDataTypeReference);
}

effect: AddInnerDeclarationToCompositeDataType
input: pcm.CompositeDataType as compositeDataType, pcm.InnerDeclaration as innerDeclaration, java.TypeReference as dataTypeReference
retrieve element: java.Class as dataTypeClass corresponding to compositeDataType
create element: java.Field as innerDataTypeField corresponding to innerDeclaration
create element: java.ClassMethod as getterMethod corresponding to innerDeclaration tag with "getter"
create element: java.ClassMethod as setterMethod corresponding to innerDeclaration tag with "setter"
execute: {
	createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: ChangedNameOfInnerDeclaration
trigger: replace value pcm.InnerDeclaration[entityName]
execute: callChangeNameOfInnerDeclaration(change.newAffectedEObject as InnerDeclaration)

effect: ChangeNameOfInnerDeclaration
input: pcm.InnerDeclaration as innerDeclaration
retrieve element: java.Field as compositeTypeField corresponding to innerDeclaration
retrieve element: java.ClassMethod as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
retrieve element: java.ClassMethod as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
execute: {
	val newName = innerDeclaration.entityName;
	compositeTypeField.name = newName;
	compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.name = "set" + newName.toFirstUpper;
	}
}

response: ChangeTypeOfInnerDeclaration
trigger: replace value pcm.InnerDeclaration[datatype_InnerDeclaration]
retrieve element: java.Class as newJavaDataType corresponding to change.newValue
	on fail do nothing and continue effect
execute: {
	val innerDeclaration = change.newAffectedEObject as InnerDeclaration;
	val newDataTypeReference = createTypeReference(change.newValue, newJavaDataType);
	callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
}

effect: ChangeInnerDeclarationType
input: pcm.InnerDeclaration as innerDeclaration, java.TypeReference as newTypeReference
retrieve element: java.Field as compositeTypeField corresponding to innerDeclaration
retrieve element: java.Method as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
retrieve element: java.Method as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
execute: {
	compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newTypeReference)
	}
}


// ######################################################
// ################ JAVA PACKAGE EFFECTS ################

effect: CreateJavaPackage
input: EObject as sourceElementMappedToPackage, java.Package as parentPackage, String as packageName, String as newTag
create element: java.Package as javaPackage corresponding to sourceElementMappedToPackage
	tag with newTag persist as root at project-relative location: buildJavaFilePath(javaPackage)
execute: {
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}

effect: RenameJavaPackage
input: pcm.NamedElement as sourceElementMappedToPackage, java.Package as parentPackage, String as packageName, String as expectedTag
retrieve element: java.Package as javaPackage corresponding to sourceElementMappedToPackage
	tagged with expectedTag	move containing model to project-relative location: buildJavaFilePath(javaPackage)
execute: {
	javaPackage.namespaces.clear();
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}

effect: DeleteJavaPackage
input: pcm.NamedElement as sourceElementMappedToPackage, String as packageName, String as expectedTag
delete element: java.Package as javaPackage corresponding to sourceElementMappedToPackage tagged with expectedTag


// ######################################################
// ################ JAVA CLASS EFFECTS ##################

effect: CreateJavaClass
input: pcm.NamedElement as sourceElementMappedToClass, java.Package as containingPackage, String as className
create element: java.Class as javaClass corresponding to sourceElementMappedToClass
execute: {
	javaClass.name = className;
	javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	callCreateCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage);
}

effect: CreateJavaInterface
input: pcm.NamedElement as sourceElementMappedToClass, java.Package as containingPackage, String as className
create element: java.Interface as javaInterface corresponding to sourceElementMappedToClass
execute: {
	javaInterface.name = className;
	javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	callCreateCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage);
}

effect: CreateCompilationUnit
input: pcm.NamedElement as sourceElementMappedToClass, java.ConcreteClassifier as classifier, java.Package as containingPackage
create element: java.CompilationUnit as compilationUnit corresponding to sourceElementMappedToClass
	persist as root at project-relative location: buildJavaFilePath(compilationUnit)
execute: {
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
	compilationUnit.name = classifier.name;
	compilationUnit.classifiers.add(classifier);
}

effect: RenameJavaClassifier
input: pcm.NamedElement as classSourceElement, java.Package as containingPackage, String as className
retrieve element: java.CompilationUnit as compilationUnit corresponding to classSourceElement
	move containing model to project-relative location: buildJavaFilePath(compilationUnit)
retrieve element: java.ConcreteClassifier as javaClassifier corresponding to classSourceElement
execute: {
	javaClassifier.name = className;
	compilationUnit.name = className;
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
}

effect: DeleteJavaClassifier
input: pcm.NamedElement as sourceElement
delete element: java.ConcreteClassifier as javaClassifier corresponding to sourceElement
delete element: java.CompilationUnit as compilationUnit corresponding to sourceElement


// ####################################################
// ################ PROVIDED ROLES ####################

response: AddedProvidedRoleInterfaceProvidingEntity
trigger: insert in list pcm.InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
precondition: change.newValue instanceof OperationProvidedRole
execute: callAddProvidedRole(change.newValue as OperationProvidedRole)

effect: AddProvidedRole
input: pcm.OperationProvidedRole as providedRole
retrieve element: java.Interface as operationProvidingInterface corresponding to providedRole.providedInterface__OperationProvidedRole
retrieve element: java.Class as javaClass corresponding to providedRole.providingEntity_ProvidedRole
create element: java.ClassifierImport as interfaceImport corresponding to providedRole
create element: java.NamespaceClassifierReference as namespaceClassifierReference corresponding to providedRole
execute: {
	createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
	javaClass.implements.add(namespaceClassifierReference)
	addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
}

response: ChangedProvidedInterfaceOfProvidedRole
trigger: replace value pcm.OperationProvidedRole[providedInterface__OperationProvidedRole]
execute: {
	val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: ChangedProvidingEntityOfProvidedRole
trigger: replace value pcm.OperationProvidedRole[providingEntity_ProvidedRole]
execute: {
	val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
	// TODO HK Reenable with the new change MM when we can remove the provided role because the TUID 
	// of the containing component will get updated then and so the provided role correspondences can be resolved
	// callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: RemovedProvidedRoleFromSystem
trigger: remove from list pcm.System[providedRoles_InterfaceProvidingEntity]
execute: callRemoveProvidedRole(change.oldValue)

response: RemovedProvidedRoleFromComponent
trigger: remove from list pcm.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
execute: callRemoveProvidedRole(change.oldValue)

// TODO HK Remove optional with the new change MM and correct TUID update. If the providingEntity is changed
// and thus remove is called, the correspondences cannot be resolved because of faulty correspondences 
effect: RemoveProvidedRole
input: pcm.ProvidedRole as providedRole
delete element: java.ClassifierImport as requiredInterfaceImport corresponding to providedRole
	on fail show default user dialog and continue effect
delete element: java.NamespaceClassifierReference as namespaceClassifierReference corresponding to providedRole
	on fail show user dialog with message "Due to old TUIDs remove cannot be performed" and continue effect


// ####################################################
// ################ REQUIRED ROLES ####################

// TODO HK Check again with new Change MM. When replacing the requiringEntity, the oldValue cannot be retrieved in the old 
// changes. So the requiredRole cannot be reinitialized correctly.

// TODO HK implement ctor statement as correspondence (dynamic in explicit effect for each ctor) to remove them easily
// Use as example for responses best practices chapter
// TODO HK Implement rename correctly when having all four correspondences correctly 
response: AddRequiredRoleToInterfaceRequiringEntity
trigger: insert in list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
precondition: change.newValue instanceof OperationRequiredRole
execute: callAddRequiredRole(change.newValue as OperationRequiredRole)

effect: AddRequiredRole
input: pcm.OperationRequiredRole as requiredRole
retrieve element: java.Interface as requiredInterface corresponding to requiredRole.requiredInterface__OperationRequiredRole
retrieve element: java.Class as javaClass corresponding to requiredRole.requiringEntity_RequiredRole
create element: java.ClassifierImport as requiredInterfaceImport corresponding to requiredRole
create element: java.Field as requiredInterfaceField corresponding to requiredRole
execute: {
	val typeRef = createNamespaceClassifierReference(requiredInterface);
	addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
	val requiredRoleName = requiredRole.entityName;
	createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
	javaClass.members += requiredInterfaceField;
	if (javaClass.members.filter(typeof(Constructor)).nullOrEmpty) {
		addConstructorToClass(javaClass)
	}
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		callAddParameterAndAssignmentToConstructor(requiredRole, ctor, typeRef, requiredInterfaceField, requiredRoleName);
	}
}

effect: AddParameterAndAssignmentToConstructor
input: pcm.NamedElement as parameterCorrespondenceSource, java.Constructor as constructor, java.NamespaceClassifierReference as typeReference, java.Field as fieldToBeAssigned, String as parameterName
create element: java.OrdinaryParameter as newParameter corresponding to parameterCorrespondenceSource
execute: {
	newParameter.name = parameterName;
	newParameter.typeReference = EcoreUtil.copy(typeReference);
	constructor.parameters.add(newParameter)
	val asssignment = createAssignmentFromParameterToField(fieldToBeAssigned, newParameter);
	constructor.statements.add(asssignment)
}


response: RemoveRequiredRoleFromInterfaceRequiringEntity
trigger: remove from list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
precondition: change.oldValue instanceof OperationRequiredRole
execute: {
	callRemoveRequiredRole(change.oldValue, change.oldAffectedEObject as RepositoryComponent);
}

// TODO HK Remove the optionals and the null check in the execute block. 
// They are just there because after a rename they can potentially not be resolved
// but correspondences shall be removed
effect: RemoveRequiredRole
input: pcm.RequiredRole as requiredRole, pcm.InterfaceRequiringEntity as requiringEntity
delete element: java.ClassifierImport as requiredInterfaceImport corresponding to requiredRole
	on fail do nothing and continue effect
delete element: java.Field as requiredInterfaceField corresponding to requiredRole
	on fail do nothing and continue effect
retrieve element: java.Class as javaClass corresponding to requiringEntity
	on fail do nothing and continue effect
execute: {
	if (javaClass == null) {
		return
	}
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		callRemoveCorrespondingParameterFromConstructor(ctor, requiredRole);
		var Statement statementToRemove = null;
		for (statement : ctor.statements) {
			if (statement instanceof ExpressionStatement) {
				val assignmentExpression = statement.expression
				if (assignmentExpression instanceof AssignmentExpression) {
					val selfReference = assignmentExpression.child;
					if (selfReference instanceof SelfReference) {
						val fieldReference = selfReference.next;
						if (fieldReference instanceof IdentifierReference) {
							val field = fieldReference.target;
							if (field instanceof Field) {
								if (field.name.equals(requiredRole.entityName)) {
									statementToRemove = statement;
								}
							}
						}
						
					}
				
				}
			}
		}
//		var Parameter parameterToRemove = null;
//		for (parameter : ctor.parameters) {
//			if (parameter.name.equals(requiredRole.entityName)) {
//				parameterToRemove = parameter;
//			}
//		}
		if (statementToRemove != null) {
			ctor.statements.remove(statementToRemove);
		}
//		if (parameterToRemove != null) {
//			ctor.parameters.remove(parameterToRemove);
//		}
	}
}

effect: RemoveCorrespondingParameterFromConstructor
input: java.Constructor as ctor, pcm.NamedElement as correspondenceSource
delete element: java.OrdinaryParameter as param corresponding to correspondenceSource
	with ctor.parameters.contains(param)

effect: ReinitializeOperationRequiredRole
input: pcm.OperationRequiredRole as requiredRole
execute: {
	callRemoveRequiredRole(requiredRole, requiredRole.requiringEntity_RequiredRole);
	callAddRequiredRole(requiredRole);
}

response: RenameOperationRequiredRole
trigger: replace value pcm.OperationRequiredRole[entityName]
execute: callReinitializeOperationRequiredRole(change.newAffectedEObject as OperationRequiredRole)

response: ChangeOperationRequiredRoleEntity
trigger: replace value pcm.OperationRequiredRole[requiringEntity_RequiredRole]
execute: {
	val requiredRole = change.newAffectedEObject as OperationRequiredRole;
	callRemoveRequiredRole(requiredRole, change.oldValue);
	callAddRequiredRole(requiredRole);
}

response: ChangeOperationRequiredRoleInterface
trigger: replace value pcm.OperationRequiredRole[requiredInterface__OperationRequiredRole]
execute: callReinitializeOperationRequiredRole(change.newAffectedEObject as OperationRequiredRole)


// ##########################################################
// ################ OPERATION SIGNATURES ####################

// TODO HK Implement changing the signature interface. All components with their SEFFs have to be updated.
// Use more reasonable correspondences than Michael
response: AddOperationSignature
trigger: insert in list pcm.OperationInterface[signatures__OperationInterface]
retrieve element: java.Interface as javaInterface corresponding to change.newAffectedEObject
create element: java.InterfaceMethod as interfaceMethod corresponding to change.newValue
execute: {
	interfaceMethod.name = change.newValue.entityName;
	callChangeInterfaceMethodReturnType(interfaceMethod, change.newValue.returnType__OperationSignature);
	javaInterface.members += interfaceMethod;
}

response: RenameOperationSignature
trigger: replace value pcm.OperationSignature[entityName]
retrieve element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
execute: {
	val operationSignature = change.newAffectedEObject as OperationSignature;
	val operationInterface = operationSignature.interface__OperationSignature;
	interfaceMethod.name = change.newValue;
	// get implementing components
	val implementingComponents = Sets.newHashSet
	operationInterface.repository__Interface.components__Repository.forEach [ comp |
		val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
		opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
			implementingComponents.add(opProRole.providingEntity_ProvidedRole)
		]
	]
	val basicComponents = implementingComponents.filter(BasicComponent)
	basicComponents.forEach[
		it.serviceEffectSpecifications__BasicComponent.forEach[
			callUpdateSEFFImplementingMethodName(it)
		]
	]
}

response: ChangeOperationSignatureReturnType
trigger: replace value pcm.OperationSignature[returnType__OperationSignature]
retrieve element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
execute: callChangeInterfaceMethodReturnType(interfaceMethod, (change.newAffectedEObject as OperationSignature).returnType__OperationSignature)

effect: ChangeInterfaceMethodReturnType
input: java.InterfaceMethod as interfaceMethod, pcm.DataType as returnType
retrieve element: java.Class as returnTypeClass corresponding to returnType
	on fail do nothing and continue effect
execute: {
	val returnTypeReference = createTypeReference(returnType, returnTypeClass);
	interfaceMethod.typeReference = returnTypeReference;
}

response: DeleteOperationSignature
trigger: remove from list pcm.OperationInterface[signatures__OperationInterface]
delete element: java.InterfaceMethod as interfaceMethod corresponding to change.oldValue


// ################################################################################
// ################################## PARAMETERS ##################################

response: CreatedParameter
trigger: insert in list pcm.OperationSignature[parameters__OperationSignature]
retrieve element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
create element: java.OrdinaryParameter as javaParameter corresponding to change.newValue
execute: {
	javaParameter.name = change.newValue.parameterName;
	callChangeParameterType(javaParameter, change.newValue.dataType__Parameter);
	interfaceMethod.parameters += javaParameter;
}

response: ChangedParameterName
trigger: replace value pcm.Parameter[parameterName]
retrieve element: java.OrdinaryParameter as javaParameter corresponding to change.newAffectedEObject
execute: {
	javaParameter.name = change.newValue;
}

response: ChangedParameterType
trigger: replace value pcm.Parameter[dataType__Parameter]
// retrieve the interface method to update the TUID according to the new parameter type
retrieve element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject.eContainer
retrieve element: java.OrdinaryParameter as javaParameter corresponding to change.newAffectedEObject
execute: callChangeParameterType(javaParameter, change.newValue)

effect: ChangeParameterType
input: java.OrdinaryParameter as javaParameter, pcm.DataType as parameterType
retrieve element: java.Class as javaParameterTypeClass corresponding to parameterType
	on fail do nothing and continue effect
execute: {
	val parameterTypeReference = createTypeReference(parameterType, javaParameterTypeClass);
	javaParameter.typeReference = parameterTypeReference;
}

response: RemovedParameter
trigger: remove from list pcm.OperationSignature[parameters__OperationSignature]
// retrieve the interface method to update the TUID according to the removed parameter type
retrieve element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
delete element: java.OrdinaryParameter as javaParameter corresponding to change.oldValue


// ################################################################################
// ##################### RESOURCE DEMANDING INTERNAL BEHAVIOR #####################

response: CreatedResourceDemandingInternalBehavior
trigger: insert in list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
retrieve element: java.Class as componentClass corresponding to change.newAffectedEObject
create element: java.ClassMethod as javaMethod corresponding to change.newValue
execute: {
	javaMethod.name = change.newValue.entityName;
	javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid;
	componentClass.members += javaMethod;
}

response: RenameResourceDemandingInternalBehavior
trigger: replace value pcm.ResourceDemandingInternalBehaviour[entityName]
retrieve element: java.ClassMethod as javaMethod corresponding to change.newAffectedEObject
execute: {
	javaMethod.name = change.newValue;
}

response: RemovedResourceDemandingInternalBehavior
trigger: remove from list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
delete element: java.ClassMethod as javaMethod corresponding to change.oldValue




// ################################################################################
// #################################### SEFFS #####################################

response: CreatedSEFF
trigger: insert in list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
execute: callCreateSEFF(change.newValue)

effect: CreateSEFF
input: pcm.ServiceEffectSpecification as seff
retrieve element: java.Class as componentClass corresponding to seff.basicComponent_ServiceEffectSpecification
	on fail show user dialog with message "Could not find a corresponding class for the SEFF's component. No corresponding method for the SEFF created." 
		and abort effect
retrieve element: java.InterfaceMethod as interfaceMethod corresponding to seff.describedService__SEFF
	on fail do nothing and abort effect
create element: java.ClassMethod as classMethod corresponding to seff
execute: {
	val signature = seff.describedService__SEFF
	val sigIsOpSig = signature != null && signature instanceof OperationSignature
	if (!sigIsOpSig) {
		return;
	}
	initializeClassMethod(classMethod, interfaceMethod, true);
	var correspondingClassMethod = componentClass.findMethodInClass(classMethod)
	if (null == correspondingClassMethod) {
		componentClass.members.add(classMethod)
		correspondingClassMethod = classMethod
	} else {
		correspondingClassMethod.name = interfaceMethod.name
	}
}

response: ChangeOperationSignatureOfSeff
trigger: replace value pcm.ResourceDemandingSEFF[describedService__SEFF]
delete element: java.ClassMethod as oldClassMethod corresponding to change.newAffectedEObject
execute: callCreateSEFF(change.newAffectedEObject as ResourceDemandingSEFF)

effect: UpdateSEFFImplementingMethodName
input: pcm.ServiceEffectSpecification as seff
retrieve element: java.ClassMethod as classMethod corresponding to seff
execute: {
	classMethod.name = seff.describedService__SEFF.entityName;
}

response: RemovedSeff
trigger: remove from list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
delete element: java.ClassMethod as classMethod corresponding to change.oldValue



