import org.eclipse.emf.ecore.util.EcoreUtil
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import org.palladiosimulator.pcm.repository.InnerDeclaration
import com.google.common.collect.Sets
import org.emftext.language.java.statements.ExpressionStatement
import org.emftext.language.java.expressions.AssignmentExpression
import org.emftext.language.java.references.SelfReference
import org.emftext.language.java.references.IdentifierReference
import org.emftext.language.java.statements.Statement
import java.util.Collection
import java.util.Set
import java.util.HashSet
import java.util.ArrayList
import java.util.LinkedList
import java.util.Vector
import java.util.Stack
import java.util.List
import edu.kit.ipd.sdq.vitruvius.framework.contracts.datatypes.UserInteractionType
import org.emftext.language.java.generics.GenericsFactory
import static extension edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.responses.pcm2java.Pcm2JavaHelper.*
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.emftext.language.java.types.TypeReference
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.emftext.language.java.types.PrimitiveType
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.members.Field

import "http://www.emftext.org/java" as java using simple names
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm using simple names

responses from metamodel pcm to metamodel java
called pcm2java

// ###################################################
// ################ PACKAGE RESPONSES ################


response: CreatePackagesForRepository
trigger: insert root pcm.Repository
effect:
execute: {
	val repository = change.newValue;
	callCreateJavaPackage(repository, null, repository.entityName, "repository_root");
	callCreateRepositorySubPackages(repository);
}

routine: CreateRepositorySubPackages
input: pcm.Repository as repository
match:
	retrieve required element: java.Package as repositoryPackage corresponding to repository
effect:
	execute: {
		callCreateJavaPackage(repository, repositoryPackage, "datatypes", "datatypes");
		callCreateJavaPackage(repository, repositoryPackage, "contracts", "contracts");
	}

response: RenamedRepositoryPackages
trigger: replace value pcm.Repository[entityName]
match:
	retrieve required element: java.Package as rootPackage corresponding to change.newAffectedEObject
		tagged with "repository_root"
effect: 
	execute: {
		val repository = change.newAffectedEObject as Repository;
		rootPackage.name = change.newValue;
		callRenameJavaPackage(repository, rootPackage, "contracts", "contracts");
		callRenameJavaPackage(repository, rootPackage, "datatypes", "datatypes");	
		for (component : repository.components__Repository.filter(BasicComponent)) {
			callRenameComponentPackageAndClass(component);
		}
		for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
			callRenameInterface(interface);
		}
		for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
			callRenameCompositeDataType(dataType);
		}
		for (dataType : repository.dataTypes__Repository.filter(CollectionDataType)) {
			callRenameCollectionDataType(dataType);
		}
		persistProjectRelative(change.newAffectedEObject, rootPackage, buildJavaFilePath(rootPackage));
	}



// ################################################################################
// ############################# COMPOSED STRUCTURES ##############################

response: CreatedSystem
trigger: insert root pcm.System
effect: execute: {
	val system = change.newValue;
	callCreateJavaPackage(system, null, system.entityName, "root_system");
	callCreateImplementationForSystem(system);
}

routine: CreateImplementationForSystem
input: pcm.System as system
match:
	retrieve required element: java.Package as systemPackage corresponding to system
effect: 
	execute: callCreateJavaClass(system, systemPackage, system.entityName + "Impl")

response: ChangedSystemName
trigger: replace value pcm.System[entityName]
match:
	retrieve required element: java.Package as systemPackage corresponding to change.newAffectedEObject
effect: 
	execute: {
		val system = change.newAffectedEObject as org.palladiosimulator.pcm.system.System;
		callRenameJavaPackage(system, null, system.entityName, null);
		callRenameJavaClassifier(system, systemPackage, system.entityName + "Impl");
	}

response: AddedAssemblyContextToComposedStructure
trigger: insert in list pcm.ComposedStructure[assemblyContexts__ComposedStructure]
match:
	retrieve required element: java.Class as compositeComponentJavaClass corresponding to change.newAffectedEObject
effect: 
	execute: callAddAssemblyContextToComposedStructure(compositeComponentJavaClass, change.newValue)

routine: AddAssemblyContextToComposedStructure
input: java.Class as compositeComponentClass, pcm.AssemblyContext as assemblyContext
match:
	retrieve required element: java.Class as encapsulatedComponentJavaClass corresponding to assemblyContext.encapsulatedComponent__AssemblyContext
effect: 
	create element: java.Field as assemblyContextField
	create element: java.NewConstructorCall as newConstructorCall
	create element: java.ClassifierImport as contextClassImport
	create element: java.Constructor as constructor
	add correspondence: assemblyContextField, assemblyContext
	add correspondence: newConstructorCall, assemblyContext
	add correspondence: contextClassImport, assemblyContext
	add correspondence: constructor, assemblyContext
	execute: {
		val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
		createPrivateField(assemblyContextField, typeRef, assemblyContext.entityName);
		compositeComponentClass.members += assemblyContextField;
		addConstructorToClass(constructor, compositeComponentClass)
		addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentClass, encapsulatedComponentJavaClass)
		createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
	}

// #####################################################
// ################ COMPONENT RESPONSES ################

response: CreateComponent
trigger: insert in list pcm.Repository[components__Repository]
match:
	retrieve required element: java.Package as repositoryPackage corresponding to change.newValue.repository__RepositoryComponent
		tagged with "repository_root"
effect: 
	execute: {
		val component = change.newValue;
		callCreateJavaPackage(component, repositoryPackage, component.entityName, null);
		callCreateImplementationForComponent(component);
	}

routine: CreateImplementationForComponent
input: pcm.RepositoryComponent as component
match:
	retrieve required element: java.Package as componentPackage corresponding to component
effect: 
	execute: callCreateJavaClass(component, componentPackage, component.entityName + "Impl")

response: RenameComponent
trigger: replace value pcm.RepositoryComponent[entityName]
effect: 
	execute: {
		val component = change.newAffectedEObject as RepositoryComponent;
		callRenameComponentPackageAndClass(component);
	}

routine: RenameComponentPackageAndClass
input: pcm.RepositoryComponent as component
match:
	retrieve required element: java.Package as repositoryPackage corresponding to component.repository__RepositoryComponent
		with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
effect: 
	execute: {
		callRenameJavaPackage(component, repositoryPackage, component.entityName, null);
		callRenameComponentClass(component);
	}

routine: RenameComponentClass
input: pcm.RepositoryComponent as component
match:
	retrieve required element: java.Package as componentPackage corresponding to component
effect: 
	execute: callRenameJavaClassifier(component, componentPackage, component.entityName + "Impl")

response: DeleteComponentClass
trigger: remove from list pcm.Repository[components__Repository]
effect: 
	execute: callDeleteJavaClassifier(change.oldValue)

response: DeletePackageForBasicComponent
trigger: remove from list pcm.Repository[components__Repository]
effect: 
	execute: callDeleteJavaPackage(change.oldValue, change.oldValue.entityName, "")


// #####################################################
// ################ INTERFACE RESPONSES ################

response: CreateInterface
trigger: insert in list pcm.Repository[interfaces__Repository]
match:
	retrieve required element: java.Package as contractsPackage corresponding to change.newAffectedEObject
		with contractsPackage.name == "contracts"
effect: 
	execute: {
		val interf = change.newValue;
		callCreateJavaInterface(interf, contractsPackage, interf.entityName);
	}

response: RenamedInterface
trigger: replace value pcm.Interface[entityName]
effect: 
	execute: callRenameInterface(change.newAffectedEObject as OperationInterface)

routine: RenameInterface
input: pcm.OperationInterface as interf
match:
	retrieve required element: java.Package as contractsPackage corresponding to interf.repository__Interface
		with contractsPackage.name == "contracts"
effect: 
	execute: callRenameJavaClassifier(interf, contractsPackage, interf.entityName)


// ######################################################
// ################ DATA TYPES RESPONSES ################

response: CreatedCompositeDataType
trigger: insert in list pcm.Repository[dataTypes__Repository]
	check: change.newValue instanceof CompositeDataType
match:
	retrieve required element: java.Package as datatypesPackage corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
effect: 
	execute: {
		val compositeDataType = change.newValue as CompositeDataType;
		callCreateJavaClass(compositeDataType, datatypesPackage, compositeDataType.entityName);
	}

response: RenamedCompositeDataType
trigger: replace value pcm.CompositeDataType[entityName]
effect: 
	execute: callRenameCompositeDataType(change.newAffectedEObject as CompositeDataType)

routine: RenameCompositeDataType
input: pcm.CompositeDataType as compositeDataType
match:
	retrieve required element: java.Package as datatypesPackage corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
effect: 
	execute: callRenameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)

response: RemovedCompositeDataType
trigger: remove from list pcm.Repository[dataTypes__Repository]
	check: change.oldValue instanceof CompositeDataType
effect: 
	execute: callDeleteJavaClassifier(change.oldValue as CompositeDataType)

response: CreatedCollectionDataType
trigger: insert in list pcm.Repository[dataTypes__Repository]
	check: change.newValue instanceof CollectionDataType
match:
	retrieve optional element: java.Class as innerTypeClass corresponding to (change.newValue as CollectionDataType).innerType_CollectionDataType
	retrieve required element: java.Package as datatypesPackage corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
effect:
	execute: {
		// create correct (and in case of primitive types wrapped) type reference for the inner type
		val dataType = change.newValue as CollectionDataType;
		val innerTypeRef = createTypeReference(dataType.innerType_CollectionDataType, innerTypeClass);
		var innerTypeClassOrWrapper = innerTypeRef;
		if (innerTypeRef instanceof PrimitiveType) {
			innerTypeClassOrWrapper = getWrapperTypeReferenceForPrimitiveType(innerTypeRef);
		}
		
		// Let user select the class to map the collection type to
		var Set<Class<? extends Collection>> collectionDataTypes = new HashSet
		collectionDataTypes += #[ArrayList, LinkedList, Vector, Stack, HashSet]
		val List<String> collectionDataTypeNames = new ArrayList<String>(collectionDataTypes.size)
		for (collectionDataType : collectionDataTypes) {
			collectionDataTypeNames.add(collectionDataType.name)
		}
		val String selectTypeMsg = "Please select type (or interface) that should be used for the type"
		val int selectedType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectTypeMsg,
			collectionDataTypeNames)
		val Class<? extends Collection> selectedClass = collectionDataTypes.get(selectedType)
	
		callCreateJavaClass(dataType, datatypesPackage, dataType.entityName);
		callAddSuperTypeToDataType(dataType, innerTypeClassOrWrapper, selectedClass.name);
	}

routine: AddSuperTypeToDataType
input: pcm.DataType as dataType, java.TypeReference as innerTypeReference, String as superTypeQualifiedName
match:
	retrieve required element: java.Class as dataTypeImplementation corresponding to dataType
	retrieve required element: java.CompilationUnit as dataTypeImplementationCU corresponding to dataType
effect: 
	create element: java.NamespaceClassifierReference as namespaceClassifier
	add correspondence: namespaceClassifier, dataType
	execute: {
		val collectionTypeClassImport = getJavaClassImport(superTypeQualifiedName);
		dataTypeImplementationCU.imports += collectionTypeClassImport;
		createNamespaceClassifierReference(namespaceClassifier, collectionTypeClassImport.classifier);
		val qualifiedTypeArgument = GenericsFactory.eINSTANCE.createQualifiedTypeArgument();
		qualifiedTypeArgument.typeReference = innerTypeReference;
		namespaceClassifier.classifierReferences.get(0).typeArguments += qualifiedTypeArgument;
		dataTypeImplementation.extends = namespaceClassifier;
	}

response: RenamedCollectionDataType
trigger: replace value pcm.CollectionDataType[entityName]
effect: 
	execute: callRenameCollectionDataType(change.newAffectedEObject as CollectionDataType)

routine: RenameCollectionDataType
input: pcm.CollectionDataType as collectionDataType
match:
	retrieve required element: java.Package as datatypesPackage corresponding to collectionDataType.repository__DataType with datatypesPackage.name == "datatypes"
effect: 
	execute: callRenameJavaClassifier(collectionDataType, datatypesPackage, collectionDataType.entityName)

response: RemovedCollectionDataType
trigger: remove from list pcm.Repository[dataTypes__Repository]
	check: change.oldValue instanceof CollectionDataType
effect: 
	execute: callDeleteJavaClassifier(change.oldValue as CollectionDataType)


// ################ DATA TYPES - INNER DECLARATION RESPONSES ################

response: AddedInnerDeclarationToCompositeDataType
trigger: insert in list pcm.CompositeDataType[innerDeclaration_CompositeDataType]
match:
	retrieve optional element: java.Class as nonPrimitiveInnerDataTypeClass corresponding to change.newValue.datatype_InnerDeclaration
effect: 
	execute: {
		val innerDataTypeReference = createTypeReference(change.newValue.datatype_InnerDeclaration, nonPrimitiveInnerDataTypeClass);
		val compositeDataType = change.newAffectedEObject as CompositeDataType;
		val innerDeclaration = change.newValue;
		callAddInnerDeclarationToCompositeDataType(compositeDataType, innerDeclaration, innerDataTypeReference);
	}

routine: AddInnerDeclarationToCompositeDataType
input: pcm.CompositeDataType as compositeDataType, pcm.InnerDeclaration as innerDeclaration, java.TypeReference as dataTypeReference
match:
	retrieve required element: java.Class as dataTypeClass corresponding to compositeDataType
effect: 
	create element: java.Field as innerDataTypeField
	create element: java.ClassMethod as getterMethod
	create element: java.ClassMethod as setterMethod
	add correspondence: innerDataTypeField, innerDeclaration
	add correspondence: getterMethod, innerDeclaration tag with "getter"
	add correspondence: setterMethod, innerDeclaration tag with "setter"
	execute: {
		createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);
		createSetter(innerDataTypeField, setterMethod);	
		createGetter(innerDataTypeField, getterMethod);
		dataTypeClass.members += innerDataTypeField;
		dataTypeClass.members += getterMethod;
		dataTypeClass.members += setterMethod;
		sortMembers(dataTypeClass.members);
	}

response: ChangedNameOfInnerDeclaration
trigger: replace value pcm.InnerDeclaration[entityName]
effect: 
	execute: callChangeNameOfInnerDeclaration(change.newAffectedEObject as InnerDeclaration)

routine: ChangeNameOfInnerDeclaration
input: pcm.InnerDeclaration as innerDeclaration
match:
	retrieve required element: java.Field as compositeTypeField corresponding to innerDeclaration
	retrieve required element: java.ClassMethod as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
	retrieve required element: java.ClassMethod as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
effect: 
	execute: {
		val newName = innerDeclaration.entityName;
		compositeTypeField.name = newName;
		compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
		if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
			val parameter = compositeTypeSetterMethod.parameters.get(0)
			parameter.name = "set" + newName.toFirstUpper;
		}
	}

response: ChangeTypeOfInnerDeclaration
trigger: replace value pcm.InnerDeclaration[datatype_InnerDeclaration]
match:
	retrieve optional element: java.Class as newJavaDataType corresponding to change.newValue
effect: 
	execute: {
		val innerDeclaration = change.newAffectedEObject as InnerDeclaration;
		val newDataTypeReference = createTypeReference(change.newValue, newJavaDataType);
		callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
	}

routine: ChangeInnerDeclarationType
input: pcm.InnerDeclaration as innerDeclaration, java.TypeReference as newTypeReference
match:
	retrieve required element: java.Field as compositeTypeField corresponding to innerDeclaration
	retrieve required element: java.Method as compositeTypeGetterMethod corresponding to innerDeclaration tagged with "getter"
	retrieve required element: java.Method as compositeTypeSetterMethod corresponding to innerDeclaration tagged with "setter"
effect: 
	execute: {
		compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
		compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
		if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
			val parameter = compositeTypeSetterMethod.parameters.get(0)
			parameter.typeReference = EcoreUtil.copy(newTypeReference)
		}
	}


// ######################################################
// ################ JAVA PACKAGE EFFECTS ################

routine: CreateJavaPackage
input: EObject as sourceElementMappedToPackage, java.Package as parentPackage, String as packageName, String as newTag
match:
	require absence of element: java.Package corresponding to sourceElementMappedToPackage tagged with newTag
effect: 
	create element: java.Package as javaPackage
	add correspondence: javaPackage, sourceElementMappedToPackage
		tag with newTag //persist as root at project-relative location: buildJavaFilePath(javaPackage)
	execute: {
		if (parentPackage != null) {
			javaPackage.namespaces += parentPackage.namespaces;
			javaPackage.namespaces += parentPackage.name; 
		}
		javaPackage.name = packageName;
		persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
	}

routine: RenameJavaPackage
input: pcm.NamedElement as sourceElementMappedToPackage, java.Package as parentPackage, String as packageName, String as expectedTag
match:
	retrieve required element: java.Package as javaPackage corresponding to sourceElementMappedToPackage
		tagged with expectedTag	//move containing model to project-relative location: buildJavaFilePath(javaPackage)
effect: 
	execute: {
		javaPackage.namespaces.clear();
		if (parentPackage != null) {
			javaPackage.namespaces += parentPackage.namespaces;
			javaPackage.namespaces += parentPackage.name; 
		}
		javaPackage.name = packageName;
		persistProjectRelative(sourceElementMappedToPackage, javaPackage, buildJavaFilePath(javaPackage));
	}

routine: DeleteJavaPackage
input: pcm.NamedElement as sourceElementMappedToPackage, String as packageName, String as expectedTag
match:
	retrieve required element: java.Package as javaPackage corresponding to sourceElementMappedToPackage tagged with expectedTag
effect: 
	delete element: javaPackage


// ######################################################
// ################ JAVA CLASS EFFECTS ##################

routine: CreateJavaClass
input: pcm.NamedElement as sourceElementMappedToClass, java.Package as containingPackage, String as className
effect: 
	create element: java.Class as javaClass
	add correspondence: javaClass, sourceElementMappedToClass
	execute: {
		javaClass.name = className;
		javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		callCreateCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage);
	}

routine: CreateJavaInterface
input: pcm.NamedElement as sourceElementMappedToClass, java.Package as containingPackage, String as className
effect: 
	create element: java.Interface as javaInterface
	add correspondence: javaInterface, sourceElementMappedToClass
	execute: {
		javaInterface.name = className;
		javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		callCreateCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage);
	}

routine: CreateCompilationUnit
input: pcm.NamedElement as sourceElementMappedToClass, java.ConcreteClassifier as classifier, java.Package as containingPackage
effect: 
	create element:  java.CompilationUnit as compilationUnit
	add correspondence: compilationUnit, sourceElementMappedToClass
		//persist as root at project-relative location: buildJavaFilePath(compilationUnit)
	execute: {
		compilationUnit.namespaces += containingPackage.namespaces;
		compilationUnit.namespaces += containingPackage.name;
		compilationUnit.name = classifier.name;
		compilationUnit.classifiers.add(classifier);
		persistProjectRelative(sourceElementMappedToClass, compilationUnit, buildJavaFilePath(compilationUnit));
	}

routine: RenameJavaClassifier
input: pcm.NamedElement as classSourceElement, java.Package as containingPackage, String as className
match:
	retrieve required element: java.CompilationUnit as compilationUnit corresponding to classSourceElement
		//move containing model to project-relative location: buildJavaFilePath(compilationUnit)
	retrieve required element: java.ConcreteClassifier as javaClassifier corresponding to classSourceElement
effect: 
	execute: {
		javaClassifier.name = className;
		compilationUnit.name = className;
		compilationUnit.namespaces.clear;
		compilationUnit.namespaces += containingPackage.namespaces;
		compilationUnit.namespaces += containingPackage.name;
		persistProjectRelative(classSourceElement, compilationUnit, buildJavaFilePath(compilationUnit));
	}

routine: DeleteJavaClassifier
input: pcm.NamedElement as sourceElement
match:
	retrieve required element: java.ConcreteClassifier as javaClassifier corresponding to sourceElement
	retrieve required element: java.CompilationUnit as compilationUnit corresponding to sourceElement
effect: 
	delete element: javaClassifier
	delete element: compilationUnit


// ####################################################
// ################ PROVIDED ROLES ####################

response: AddedProvidedRoleInterfaceProvidingEntity
trigger: insert in list pcm.InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	check: change.newValue instanceof OperationProvidedRole
effect: execute: callAddProvidedRole(change.newValue as OperationProvidedRole)

routine: AddProvidedRole
input: pcm.OperationProvidedRole as providedRole
match:
	retrieve required element: java.Interface as operationProvidingInterface corresponding to providedRole.providedInterface__OperationProvidedRole
	retrieve required element: java.Class as javaClass corresponding to providedRole.providingEntity_ProvidedRole
effect: 
	create element: java.ClassifierImport as interfaceImport
	create element: java.NamespaceClassifierReference as namespaceClassifierReference
	add correspondence: interfaceImport, providedRole
	add correspondence: namespaceClassifierReference,  providedRole
	execute: {
		createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
		javaClass.implements.add(namespaceClassifierReference)
		addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
	}

response: ChangedProvidedInterfaceOfProvidedRole
trigger: replace value pcm.OperationProvidedRole[providedInterface__OperationProvidedRole]
effect: 
	execute: {
		val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
		callRemoveProvidedRole(operationProvidedRole);
		callAddProvidedRole(operationProvidedRole);
	}

response: ChangedProvidingEntityOfProvidedRole
trigger: replace value pcm.OperationProvidedRole[providingEntity_ProvidedRole]
effect: 
	execute: {
		val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;	
		// TODO HK Reenable with the new change MM when we can remove the provided role because the TUID 
		// of the containing component will get updated then and so the provided role correspondences can be resolved
		// callRemoveProvidedRole(operationProvidedRole);
		callAddProvidedRole(operationProvidedRole);
	}

response: RemovedProvidedRoleFromSystem
trigger: remove from list pcm.System[providedRoles_InterfaceProvidingEntity]
effect: 
	execute: callRemoveProvidedRole(change.oldValue)

response: RemovedProvidedRoleFromComponent
trigger: remove from list pcm.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
effect: 
	execute: callRemoveProvidedRole(change.oldValue)

// TODO HK Remove optional with the new change MM and correct TUID update. If the providingEntity is changed
// and thus remove is called, the correspondences cannot be resolved because of faulty correspondences 
routine: RemoveProvidedRole
input: pcm.ProvidedRole as providedRole
match:
	retrieve optional element: java.ClassifierImport as requiredInterfaceImport corresponding to providedRole
	retrieve optional element: java.NamespaceClassifierReference as namespaceClassifierReference corresponding to providedRole
effect: 
	delete element: requiredInterfaceImport
	delete element: namespaceClassifierReference

// ####################################################
// ################ REQUIRED ROLES ####################

// TODO HK Check again with new Change MM. When replacing the requiringEntity, the oldValue cannot be retrieved in the old 
// changes. So the requiredRole cannot be reinitialized correctly.

// TODO HK implement ctor statement as correspondence (dynamic in explicit effect for each ctor) to remove them easily
// Use as example for responses best practices chapter
// TODO HK Implement rename correctly when having all four correspondences correctly 
response: AddRequiredRoleToInterfaceRequiringEntity
trigger: insert in list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	check: change.newValue instanceof OperationRequiredRole
effect: 
	execute: callAddRequiredRole(change.newValue as OperationRequiredRole)

routine: AddRequiredRole
input: pcm.OperationRequiredRole as requiredRole
match:
	retrieve required element: java.Interface as requiredInterface corresponding to requiredRole.requiredInterface__OperationRequiredRole
	retrieve required element: java.Class as javaClass corresponding to requiredRole.requiringEntity_RequiredRole
effect: 
	create element: java.ClassifierImport as requiredInterfaceImport
	create element: java.Field as requiredInterfaceField
	add correspondence: requiredInterfaceImport, requiredRole
	add correspondence: requiredInterfaceField, requiredRole
	execute: {
		val typeRef = createNamespaceClassifierReference(requiredInterface);
		addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
		val requiredRoleName = requiredRole.entityName;
		createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
		javaClass.members += requiredInterfaceField;
		if (javaClass.members.filter(typeof(Constructor)).nullOrEmpty) {
			addConstructorToClass(javaClass)
		}
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			callAddParameterAndAssignmentToConstructor(requiredRole, ctor, typeRef, requiredInterfaceField, requiredRoleName);
		}
	}

routine: AddParameterAndAssignmentToConstructor
input: pcm.NamedElement as parameterCorrespondenceSource, java.Constructor as constructor, java.NamespaceClassifierReference as typeReference, java.Field as fieldToBeAssigned, String as parameterName
effect: 
	create element: java.OrdinaryParameter as newParameter
	add correspondence: newParameter, parameterCorrespondenceSource
	execute: {
		newParameter.name = parameterName;
		newParameter.typeReference = EcoreUtil.copy(typeReference);
		constructor.parameters.add(newParameter)
		val asssignment = createAssignmentFromParameterToField(fieldToBeAssigned, newParameter);
		constructor.statements.add(asssignment)
	}


response: RemoveRequiredRoleFromInterfaceRequiringEntity
trigger: remove from list pcm.InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	check: change.oldValue instanceof OperationRequiredRole
effect: 
	execute: {
		callRemoveRequiredRole(change.oldValue, change.oldAffectedEObject as RepositoryComponent);
	}

// TODO HK Remove the optionals and the null check in the execute block. 
// They are just there because after a rename they can potentially not be resolved
// but correspondences shall be removed
routine: RemoveRequiredRole
input: pcm.RequiredRole as requiredRole, pcm.InterfaceRequiringEntity as requiringEntity
match:
	retrieve optional element: java.ClassifierImport as requiredInterfaceImport corresponding to requiredRole
	retrieve optional element: java.Field as requiredInterfaceField corresponding to requiredRole
	retrieve optional element: java.Class as javaClass corresponding to requiringEntity
effect: 
	delete element: requiredInterfaceImport
	delete element: requiredInterfaceField
	execute: {
		if (javaClass == null) {
			return
		}
		for (ctor : javaClass.members.filter(typeof(Constructor))) {
			callRemoveCorrespondingParameterFromConstructor(ctor, requiredRole);
			var Statement statementToRemove = null;
			for (statement : ctor.statements) {
				if (statement instanceof ExpressionStatement) {
					val assignmentExpression = statement.expression
					if (assignmentExpression instanceof AssignmentExpression) {
						val selfReference = assignmentExpression.child;
						if (selfReference instanceof SelfReference) {
							val fieldReference = selfReference.next;
							if (fieldReference instanceof IdentifierReference) {
								val field = fieldReference.target;
								if (field instanceof Field) {
									if (field.name.equals(requiredRole.entityName)) {
										statementToRemove = statement;
									}
								}
							}
							
						}
					}
				}
			}
//			var Parameter parameterToRemove = null;
//			for (parameter : ctor.parameters) {
//				if (parameter.name.equals(requiredRole.entityName)) {
//					parameterToRemove = parameter;
//				}
//			}
			if (statementToRemove != null) {
				ctor.statements.remove(statementToRemove);
			}
//			if (parameterToRemove != null) {
//				ctor.parameters.remove(parameterToRemove);
//			}
		}
	}

routine: RemoveCorrespondingParameterFromConstructor
input: java.Constructor as ctor, pcm.NamedElement as correspondenceSource
match:
	retrieve required element: java.OrdinaryParameter as param corresponding to correspondenceSource
		with ctor.parameters.contains(param)
effect: 
	delete element: param

routine: ReinitializeOperationRequiredRole
input: pcm.OperationRequiredRole as requiredRole
effect: 
	execute: {
		callRemoveRequiredRole(requiredRole, requiredRole.requiringEntity_RequiredRole);
		callAddRequiredRole(requiredRole);
	}

response: RenameOperationRequiredRole
trigger: replace value pcm.OperationRequiredRole[entityName]
effect: 
	execute: callReinitializeOperationRequiredRole(change.newAffectedEObject as OperationRequiredRole)

response: ChangeOperationRequiredRoleEntity
trigger: replace value pcm.OperationRequiredRole[requiringEntity_RequiredRole]
effect: 
	execute: {
		val requiredRole = change.newAffectedEObject as OperationRequiredRole;
		callRemoveRequiredRole(requiredRole, change.oldValue);
		callAddRequiredRole(requiredRole);
	}

response: ChangeOperationRequiredRoleInterface
trigger: replace value pcm.OperationRequiredRole[requiredInterface__OperationRequiredRole]
effect: 
	execute: callReinitializeOperationRequiredRole(change.newAffectedEObject as OperationRequiredRole)


// ##########################################################
// ################ OPERATION SIGNATURES ####################

// TODO HK Implement changing the signature interface. All components with their SEFFs have to be updated.
// Use more reasonable correspondences than Michael
response: AddOperationSignature
trigger: insert in list pcm.OperationInterface[signatures__OperationInterface]
match:
	retrieve required element: java.Interface as javaInterface corresponding to change.newAffectedEObject
effect: 
	create element: java.InterfaceMethod as interfaceMethod
	add correspondence: interfaceMethod, change.newValue
	execute: {
		interfaceMethod.name = change.newValue.entityName;
		callChangeInterfaceMethodReturnType(interfaceMethod, change.newValue.returnType__OperationSignature);
		javaInterface.members += interfaceMethod;
	}

response: RenameOperationSignature
trigger: replace value pcm.OperationSignature[entityName]
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
effect: execute: {
	val operationSignature = change.newAffectedEObject as OperationSignature;
	val operationInterface = operationSignature.interface__OperationSignature;
	interfaceMethod.name = change.newValue;
	// get implementing components
	val implementingComponents = Sets.newHashSet
	operationInterface.repository__Interface.components__Repository.forEach [ comp |
		val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
		opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
			implementingComponents.add(opProRole.providingEntity_ProvidedRole)
		]
	]
	val basicComponents = implementingComponents.filter(BasicComponent)
	basicComponents.forEach[
		it.serviceEffectSpecifications__BasicComponent.forEach[
			callUpdateSEFFImplementingMethodName(it)
		]
	]
}

response: ChangeOperationSignatureReturnType
trigger: replace value pcm.OperationSignature[returnType__OperationSignature]
match: 
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
effect: 
	execute: callChangeInterfaceMethodReturnType(interfaceMethod, (change.newAffectedEObject as OperationSignature).returnType__OperationSignature)

routine: ChangeInterfaceMethodReturnType
input: java.InterfaceMethod as interfaceMethod, pcm.DataType as returnType
match: 
	retrieve optional element: java.Class as returnTypeClass corresponding to returnType
effect: 
	execute: {
		val returnTypeReference = createTypeReference(returnType, returnTypeClass);
		interfaceMethod.typeReference = returnTypeReference;
	}

response: DeleteOperationSignature
trigger: remove from list pcm.OperationInterface[signatures__OperationInterface]
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.oldValue
effect: 
	delete element: interfaceMethod

// ################################################################################
// ################################## PARAMETERS ##################################

response: CreatedParameter
trigger: insert in list pcm.OperationSignature[parameters__OperationSignature]
match:
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
effect: 
	create element: java.OrdinaryParameter as javaParameter
	add correspondence: javaParameter, change.newValue
	execute: {
		javaParameter.name = change.newValue.parameterName;
		callChangeParameterType(javaParameter, change.newValue.dataType__Parameter);
		interfaceMethod.parameters += javaParameter;
	}

response: ChangedParameterName
trigger: replace value pcm.Parameter[parameterName]
match:
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to change.newAffectedEObject
effect: 
	execute: {
		javaParameter.name = change.newValue;
	}

response: ChangedParameterType
trigger: replace value pcm.Parameter[dataType__Parameter]
match:
	// retrieve the interface method to update the TUID according to the new parameter type
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject.eContainer
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to change.newAffectedEObject
effect: 
	execute: callChangeParameterType(javaParameter, change.newValue)

routine: ChangeParameterType
input: java.OrdinaryParameter as javaParameter, pcm.DataType as parameterType
match:
	retrieve optional element: java.Class as javaParameterTypeClass corresponding to parameterType
effect: 
	execute: {
		val parameterTypeReference = createTypeReference(parameterType, javaParameterTypeClass);
		javaParameter.typeReference = parameterTypeReference;
	}

response: RemovedParameter
trigger: remove from list pcm.OperationSignature[parameters__OperationSignature]
match:
	// retrieve the interface method to update the TUID according to the removed parameter type
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to change.newAffectedEObject
	retrieve required element: java.OrdinaryParameter as javaParameter corresponding to change.oldValue
effect: 
	delete element: javaParameter


// ################################################################################
// ##################### RESOURCE DEMANDING INTERNAL BEHAVIOR #####################

response: CreatedResourceDemandingInternalBehavior
trigger: insert in list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
match:
	retrieve required element: java.Class as componentClass corresponding to change.newAffectedEObject
effect: 
	create element: java.ClassMethod as javaMethod
	add correspondence: javaMethod, change.newValue
	execute: {
		javaMethod.name = change.newValue.entityName;
		javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid;
		componentClass.members += javaMethod;
	}

response: RenameResourceDemandingInternalBehavior
trigger: replace value pcm.ResourceDemandingInternalBehaviour[entityName]
match:
	retrieve required element: java.ClassMethod as javaMethod corresponding to change.newAffectedEObject
effect: 
	execute: {
		javaMethod.name = change.newValue;
	}

response: RemovedResourceDemandingInternalBehavior
trigger: remove from list pcm.BasicComponent[resourceDemandingInternalBehaviours__BasicComponent]
match:
	retrieve required element: java.ClassMethod as javaMethod corresponding to change.oldValue
effect: 
	delete element: javaMethod


// ################################################################################
// #################################### SEFFS #####################################

response: CreatedSEFF
trigger: insert in list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
effect: execute: callCreateSEFF(change.newValue)

routine: CreateSEFF
input: pcm.ServiceEffectSpecification as seff
match:
	retrieve required element: java.Class as componentClass corresponding to seff.basicComponent_ServiceEffectSpecification
	retrieve required element: java.InterfaceMethod as interfaceMethod corresponding to seff.describedService__SEFF
	check: seff.describedService__SEFF instanceof OperationSignature
effect: 
	create element: java.ClassMethod as classMethod
	add correspondence: classMethod, seff
	execute: {
		initializeClassMethod(classMethod, interfaceMethod, true);
		var correspondingClassMethod = componentClass.findMethodInClass(classMethod)
		if (null == correspondingClassMethod) {
			componentClass.members.add(classMethod)
			correspondingClassMethod = classMethod
		} else {
			correspondingClassMethod.name = interfaceMethod.name
		}
	}

response: ChangeOperationSignatureOfSeff
trigger: replace value pcm.ResourceDemandingSEFF[describedService__SEFF]
match:
	retrieve required element: java.ClassMethod as oldClassMethod corresponding to change.newAffectedEObject
effect: 
	delete element: oldClassMethod
	//remove correspondence: oldClassMethod, change.newAffectedEObject
	execute: callCreateSEFF(change.newAffectedEObject as ResourceDemandingSEFF)

routine: UpdateSEFFImplementingMethodName
input: pcm.ServiceEffectSpecification as seff
match:
	retrieve required element: java.ClassMethod as classMethod corresponding to seff
effect: 
	execute: {
		classMethod.name = seff.describedService__SEFF.entityName;
	}

response: RemovedSeff
trigger: remove from list pcm.BasicComponent[serviceEffectSpecifications__BasicComponent]
match:
	retrieve required element: java.ClassMethod as classMethod corresponding to change.oldValue
effect: 
	delete element: classMethod



