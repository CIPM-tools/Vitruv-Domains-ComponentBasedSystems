import "http://edu.kit.ipd.sdq.mdsd.addresses" as ad
import "http://edu.kit.ipd.sdq.mdsd.recipients" as re

mappings: aXr_all_or_nothing for Addresses and Recipients

mapping AdRootXReRoot {
  map (ad::Addresses aRoot)
  and (re::Recipients rRoot)
}

mapping AddressXRecipientLocationCity 
  depends on (AdRootXReRoot rootXroot) {
    map (ad::Address a) 
      with { 
	a in rootXroot:aRoot.addresses
	a.number > 0
	a.zipCode != null
	a.number > callSomeNonPureMethod()
    }
    and (re::Recipient r, re::Location l, re:City c) 
      with { 
      	r in rootXroot:rRoot.recipients
	r.business == true
	r.locatedAt == l
	l.number > 0
	r.locatedIn == c
	c.zipCode != null
	check {
	}
	enforce {
	}
    }
    such that {
      a.number = l.number
      a.street = l.street
      a.zipCode = c.zipCode
    }
}


// correspondences are not misused for candidates or dependencies between mappings
// condition code is printed without changes to halves and instances and can easily be changed or extended there
// single sided conditions: halves
// bidirectionalizable conditions: instances
// calls to checks and all management of candidates and instancesare not shown in reactions but hidden in generic mapping code
// calls to enforcements are shown in reactions



//neu aufbauen aus resourcen
//enforcen nicht direkt printen sondern für jeden Operator eine Klasse haben und deren enforce-Methode aufrufen
//testen ob zweimal enforced wird
//2phasig indem die Ergebnisse erst ganz am Ende in den Cache eingehängt werden?
//execute statt call verwenden?
//
//update zum enforcen damit nur reactions->platform und nicht reactions->platform->xtendGen->reactions
//auch zum checken routine?
//attributeReference statt XExpressions etc.