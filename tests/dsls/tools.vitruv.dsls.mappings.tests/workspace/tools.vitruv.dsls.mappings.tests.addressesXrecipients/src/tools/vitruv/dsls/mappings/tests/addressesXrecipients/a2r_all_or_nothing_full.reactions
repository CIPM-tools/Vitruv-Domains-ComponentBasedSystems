import static extension tools.vitruv.dsls.mappings.tests.addressesXrecipients.mappings.AdRootXReRootMapping.*
import static extension tools.vitruv.dsls.mappings.tests.addressesXrecipients.mappings.AddressXRecipientLocationCityMapping.*

import "http://edu.kit.ipd.sdq.mdsd.addresses" as ad
import "http://edu.kit.ipd.sdq.mdsd.recipients" as re

reactions: ad2re 
in reaction to changes in Addresses
execute actions in Recipients

/******************************************************
********** BEGIN GLOBAL REACTION AND ROUTINE **********
*******************************************************/
reaction AnyChange {
	after any change
	call {
		ensureAllMappings()
	}
}

routine ensureAllMappings() {
	action {
		call {
			ensureAdRootXReRootMapping()
			ensureAddressXRecipientLocationCityMapping()
		}
	}
}

/******************************************************
********** BEGIN AdRootXReRoot MAPPING **********
*******************************************************/
routine ensureAdRootXReRootMapping() {
	action {
		call {
			deleteAdRootXReRootMappingInstances()
			createAdRootXReRootMappingInstances()
			updateAdRootXReRootMappingInstances()
		}
	}
}

/********** BEGIN AdRootXReRoot DELETE AND CREATE ROUTINES **********/
routine deleteAdRootXReRootMappingInstances() {
	action {
		call {
			val instances = adRootXReRootMapping.getLeftInstances()
			for (aRoot : instances) {
				deleteAdRootXReRootMappingInstance(aRoot)
			}
		}
	}
}

routine deleteAdRootXReRootMappingInstance(ad::Addresses aRoot) {
	match {
		check adRootXReRootConditions.checkLeftPreconditions(aRoot)
		val rRoot = retrieve re::Recipients corresponding to aRoot
			tagged with "AdRootXReRoot"
	}
	action {
		remove correspondence between aRoot and rRoot
		delete rRoot
		call {
			adRootXReRootMapping.removeLeftInstance(aRoot)
		}
	}
}

routine createAdRootXReRootMappingInstances() {
	action {
		call {
			val candidates = adRootXReRootMapping.getLeftCandidates()
			for (aRoot : candidates) {
				createAdRootXReRootMappingInstance(aRoot)
			}
		}
	}
}

routine createAdRootXReRootMappingInstance(ad::Addresses aRoot) {
	match {
		check adRootXReRootConditions.checkLeftPreconditions(aRoot)
	}
	action {
		val rRoot = create re::Recipients
		add correspondence between aRoot and rRoot
		call {
			adRootXReRootMapping.addLeftInstance(aRoot)
			persistProjectRelative(aRoot, rRoot, aRoot.eResource.URI.lastSegment);
		}
	}
}

/********** BEGIN AdRootXReRootMapping UPDATE ROUTINES **********/
routine updateAdRootXReRootMappingInstances() {
	action {
		call {
			val instances = adRootXReRootMapping.getLeftInstances()
			for (aRoot : instances) {
				updateAdRootXReRootMappingInstance(aRoot)
			}
		}
	}
}

routine updateAdRootXReRootMappingInstance(ad::Addresses aRoot) {
	match {
		val rRoot = retrieve re::Recipients corresponding to aRoot
			tagged with "AdRootXReRootMapping"
	}
	action {
		call {
			adRootXReRootConditions.enforceRigthPostconditions(rRoot)
			adRootXReRootConditions.enforceFromLeft2Right(aRoot, rRoot)
		}
	}
}

/******************************************************
********** BEGIN AddressXRecipientLocationCity MAPPING **********
*******************************************************/
routine ensureAddressXRecipientLocationCityMapping() {
	action {
		call {
			deleteAddressXRecipientLocationCityMappingInstances()
			createAddressXRecipientLocationCityMappingInstances()
			updateAddressXRecipientLocationCityMappingInstances()
		}
	}
}

/********** BEGIN AddressXRecipientLocationCity DELETE AND CREATE ROUTINES **********/
routine deleteAddressXRecipientLocationCityMappingInstances() {
	action {
		call {
			val instances = addressXRecipientLocationCityMapping.getLeftInstances()
			for (a : instances) {
				deleteAddressXRecipientLocationCityMappingInstance(a)
			}
		}
	}
}

routine deleteAddressXRecipientLocationCityMappingInstance(ad::Address a) {
	match {
		check addressXRecipientLocationCityConditions.checkLeftPreconditions(a)
		val r = retrieve re::Recipient corresponding to a
			tagged with "AddressXRecipientLocationCity"
		val l = retrieve re::Location corresponding to a
			tagged with "AddressXRecipientLocationCity"
		val c = retrieve re::City corresponding to a
			tagged with "AddressXRecipientLocationCity"
	}
	action {
		remove correspondence between a and r
		remove correspondence between a and l
		remove correspondence between a and c
		delete r
		delete l
		delete c
		call {
			addressXRecipientLocationCityMapping.removeLeftInstance(a)
		}
	}
}

routine createAddressXRecipientLocationCityMappingInstances() {
	action {
		call {
			val candidates = addressXRecipientLocationCityMapping.getLeftCandidates()
			for (a : candidates) {
				createAddressXRecipientLocationCityMappingInstance(a)
			}
		}
	}
}

routine createAddressXRecipientLocationCityMappingInstance(ad::Address a) {
	match {
		check addressXRecipientLocationCityConditions.checkLeftPreconditions(a)
	}
	action {
		val r = create re::Recipient
		val l = create re::Location
		val c = create re::City
		add correspondence between a and r
		add correspondence between a and l
		add correspondence between a and c
		call {
			addressXRecipientLocationCityMapping.addLeftInstance(a)
		}
	}
}

/********** BEGIN AddressXRecipientLocationCity UPDATE ROUTINES **********/
routine updateAddressXRecipientLocationCityMappingInstances() {
	action {
		call {
			val instances = addressXRecipientLocationCityMapping.getLeftInstances()
			for (a : instances) {
				updateAddressXRecipientLocationCityMappingInstance(a)
			}
		}
	}
}

routine updateAddressXRecipientLocationCityMappingInstance(ad::Address a) {
	match {
		val r = retrieve re::Recipient corresponding to a
			tagged with "AddressXRecipientLocationCity"
		val l = retrieve re::Location corresponding to a
			tagged with "AddressXRecipientLocationCity"
		val c = retrieve re::City corresponding to a
			tagged with "AddressXRecipientLocationCity"
	}
	action {
		call {
			addressXRecipientLocationCityConditions.enforceRigthPostconditions(r, l, c)
			addressXRecipientLocationCityConditions.enforceFromLeft2Right(a, r, l, c)
		}
	}
}

/******************************************************
 ********** BEGIN CREATE REACTIONS **********
 ******************************************************/
reaction AddressesCreated {
	after element ad::Addresses created
	call {
		adRootXReRootMapping.addAddresses(affectedEObject)
	}
}

reaction AddressCreated {
	after element ad::Address created
	call {
		addressXRecipientLocationCityMapping.addAddress(affectedEObject)
	}
}

/******************************************************
 ********** BEGIN DELETE REACTIONS **********
 ******************************************************/
reaction AddressesDeleted {
	after element ad::Addresses deleted
	call {
		adRootXReRootMapping.removeAddresses(affectedEObject)
	}
}

reaction AddressDeleted {
	after element ad::Address deleted
	call {
		addressXRecipientLocationCityMapping.removeAddress(affectedEObject)
	}
}