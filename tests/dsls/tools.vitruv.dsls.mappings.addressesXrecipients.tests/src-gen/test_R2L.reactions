import edu.kit.ipd.sdq.metamodels.recipients.Recipients
import edu.kit.ipd.sdq.metamodels.addresses.Addresses
import java.util.Optional
import org.eclipse.xtext.xbase.lib.ObjectExtensions
import org.eclipse.xtext.xbase.lib.BooleanExtensions

import "edu.kit.ipd.sdq.metamodels.recipients" as recipients
import "edu.kit.ipd.sdq.metamodels.addresses" as addresses
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

reactions: test_R2L in reaction to changes in Recipients
execute actions in Addresses

reaction OnAdRootXReRootRecipientsInsertedAsRoot {
	after element recipients::Recipients created
	call adRootXReRoot_ElementCreatedCheck(affectedEObject)
}

reaction OnAdRootXReRootRecipientsDeleted {
	after element recipients::Recipients deleted
	call adRootXReRoot_ElementDeletedCheck(affectedEObject)
}

routine adRootXReRoot_BidirectionalUpdate(recipients::Recipients rRoot_) {
	action {
		execute {
			return
		}
	}
}

routine adRootXReRoot_CreateMapping(recipients::Recipients rRoot_) {
	match {
		require absence of addresses::Addresses corresponding to rRoot_ tagged with "test_map_Addresses_and_Recipients_correspondence_Addresses:aRoot_with_Recipients:rRoot"
	}
	action {
		val aRoot_ = create addresses::Addresses
		add correspondence between aRoot_ and rRoot_ tagged with "test_map_Addresses_and_Recipients_correspondence_Addresses:aRoot_with_Recipients:rRoot"
		call adRootXReRoot_BidirectionalUpdate(rRoot_)
	}
}

routine adRootXReRoot_DeleteMapping(addresses::Addresses aRoot_) {
	action {
		delete aRoot_
	}
}

routine adRootXReRoot_BidirectionalCheck(ecore::EObject affectedEObject, plain String as routineName) {
	action {
		call {
			if ( affectedEObject instanceof Recipients ) { var Recipients rRoot_ = affectedEObject { } }
		}
	}
}

routine adRootXReRoot_ElementCreatedCheck(ecore::EObject affectedEObject) {
	action {
		call {
			if ( affectedEObject instanceof Recipients ) { var Recipients rRoot_ = affectedEObject adRootXReRoot_CreateMapping ( rRoot_ ) }
		}
	}
}

routine adRootXReRoot_ElementDeletedCheck(ecore::EObject affectedEObject) {
	match {
		val aRoot_correspondingTo_rRoot = retrieve optional addresses::Addresses corresponding to affectedEObject tagged with "test_map_Addresses_and_Recipients_correspondence_Addresses:aRoot_with_Recipients:rRoot"
	}
	action {
		call {
			var Addresses aRoot_
			if ( aRoot_correspondingTo_rRoot . isPresent ( ) ) aRoot_ = aRoot_correspondingTo_rRoot . get ( )
			if ( aRoot_ !== null ) adRootXReRoot_DeleteMapping ( aRoot_ )
		}
	}
}

routine adRootXReRoot_ElementUpdatedCheck(ecore::EObject affectedEObject) {
	action {
		call {
			if ( affectedEObject instanceof Recipients ) { var Recipients rRoot_ = affectedEObject adRootXReRoot_CreateMapping ( rRoot_ ) }
			adRootXReRoot_ElementDeletedCheck(affectedEObject)
		}
	}
}