import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.tests.pcmjava.PCMJavaHelper.*;
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeComponent
import org.emftext.language.java.types.TypeReference
import org.eclipse.emf.ecore.util.EcoreUtil
import edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.transformations.pcm2java.PCM2JaMoPPUtils
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.repository.PrimitiveDataType
import org.emftext.language.java.classifiers.ConcreteClassifier
import org.palladiosimulator.pcm.repository.OperationInterface
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.emftext.language.java.modifiers.ModifiersFactory

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//
//response: CreatePackageForRepository
//trigger: insert root pcm.repository.Repository
//update instances of java
//execute: {
//	val newRepository = change.newValue;
//	callCreatePackage(newRepository);
//}
//
//response: CreatePackageForComponent
//trigger: insert in list pcm.repository.Repository[components__Repository]
//update instances of java
//execute: {
//	val component = change.newValue;
//	callCreatePackage(component);
//}

//response: CreatePackageForComponent
//trigger: insert in list pcm.repository.Repository[components__Repository]
//create element: javaPackage of type java.containers.Package corresponding to change.newValue
//	persist as root at project-relative location: javaProjectSrc + javaPackage.namespacesAsString.replace(".", "/") + javaPackage.name.toFirstLower + "/" + packageInfoClassName
//execute: {
//	val repository = change.newAffectedEObject as Repository;
//	javaPackage.namespaces += repository.entityName;
//	javaPackage.name = change.newValue.entityName.toFirstLower;
//}


effect: CreatePackage
model input: pcm.core.entity.NamedElement as packageCorrespondenceSource, java.containers.Package as parentPackage
java input: String as packageName
create element: javaPackage of type java.containers.Package corresponding to packageCorrespondenceSource
	persist as root at project-relative location: buildJavaFilePath(javaPackage)
execute: {
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}


response: CreatePackagesForRepository
trigger: insert root pcm.repository.Repository
update instances of java
execute: {
	val repository = change.newValue;
	callCreatePackage(repository, null, repository.entityName);
	callCreateRepositorySubPackages(repository);
}

effect: CreateRepositorySubPackages
model input: pcm.repository.Repository as repository
retrieve element: repositoryPackage of type java.containers.Package corresponding to repository
execute: {
	callCreatePackage(repository, repositoryPackage, "datatypes");
	callCreatePackage(repository, repositoryPackage, "contracts");
}

//effect: CreateRepositoryPackage
//model input: pcm.repository.Repository as repository
//create element: javaPackage of type java.containers.Package corresponding to repository
//	persist as root at project-relative location: buildJavaFilePath(javaPackage)
//execute: {
//	javaPackage.name = repository.entityName;
//}

//effect: CreateContractsPackage
//model input: pcm.repository.Repository as repository
//create element: javaPackage of type java.containers.Package corresponding to repository
//	persist as root at project-relative location: buildJavaFilePath(javaPackage)
//execute: {
//	javaPackage.namespaces += repository.entityName;
//	javaPackage.name = "contracts"
//}

/* TODO HK: Add move of components somehow. E.g. separate effects from trigger code */
//response: RenameRepositoryPackages
//trigger: replace value pcm.repository.Repository[entityName]
//retrieve element: rootPackage of type java.containers.Package corresponding to change.newAffectedEObject
//	with rootPackage.name != "contracts" && rootPackage.name != "datatypes" // TODO HK: Check for change.oldValue currently not possible
//	move containing model to project-relative location: repositoryToPackageInfo.getPathInProject(change.newAffectedEObject as Repository)
//retrieve element: contractsPackage of type java.containers.Package corresponding to change.newAffectedEObject
//	with contractsPackage.name == "contracts"
//	move containing model to project-relative location: repositoryToContractsPackageInfo.getPathInProject(change.newAffectedEObject as Repository)
//retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject
//	with datatypesPackage.name == "datatypes"
//	move containing model to project-relative location: repositoryToDatatypesPackageInfo.getPathInProject(change.newAffectedEObject as Repository)
//execute: {
//	val repository = change.newAffectedEObject as Repository;
//	rootPackage.name = change.newValue;
//	contractsPackage.namespaces.clear();
//	contractsPackage.namespaces += repository.entityName;
//	datatypesPackage.namespaces.clear();
//	datatypesPackage.namespaces += repository.entityName;
//}

//response: RenamePackageForBasicComponent
//trigger: replace value pcm.repository.BasicComponent[entityName]
//retrieve element: javaPackage of type java.containers.Package corresponding to change.newAffectedEObject
//	move containing model to project-relative location: componentToPackageInfo.getPathInProject(change.newAffectedEObject as BasicComponent)
//execute: {
//	javaPackage.namespaces.clear();
//	javaPackage.namespaces += repositoryToPackageInfo.getPackageName(change.newAffectedEObject.eContainer() as Repository);
//	javaPackage.name = change.newValue
//}
//
//response: RenameClassForBasicComponent
//trigger: replace value pcm.repository.BasicComponent[entityName]
//retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newAffectedEObject
//	move containing model to project-relative location: componentToClass.getPathInProject(change.newAffectedEObject as BasicComponent)
//retrieve element: javaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
//execute: {
//	val component = change.newAffectedEObject as BasicComponent;
//	javaClass.name = componentToClass.getClassName(component);
//	compilationUnit.name = componentToClass.getClassName(component);
//	compilationUnit.namespaces.clear;
//	compilationUnit.namespaces += componentToClass.getPackageName(component);
//}

response: RenameRepositoryPackages
trigger: replace value pcm.repository.Repository[entityName]
retrieve element: rootPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with rootPackage.name != "contracts" && rootPackage.name != "datatypes" // TODO HK: Check for change.oldValue currently not possible
	move containing model to project-relative location: buildJavaFilePath(rootPackage)
retrieve element: contractsPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with contractsPackage.name == "contracts"
	move containing model to project-relative location: buildJavaFilePath(contractsPackage)
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with datatypesPackage.name == "datatypes"
	move containing model to project-relative location: buildJavaFilePath(datatypesPackage)
execute: {
	val repository = change.newAffectedEObject as Repository;
	rootPackage.name = change.newValue;
	contractsPackage.namespaces.clear();
	contractsPackage.namespaces += repository.entityName;
	datatypesPackage.namespaces.clear();
	datatypesPackage.namespaces += repository.entityName;
	
	for (component : repository.components__Repository.filter(BasicComponent)) {
		callRenameBasicComponentPackageAndClass(component);
	}
}

//response: RenamePackageForBasicComponent
//trigger: replace value pcm.repository.BasicComponent[entityName]
//retrieve element: javaPackage of type java.containers.Package corresponding to change.newAffectedEObject
//	move containing model to project-relative location: componentToPackageInfo.getPathInProject(change.newAffectedEObject as BasicComponent)
//execute: {
//	javaPackage.namespaces.clear();
//	javaPackage.namespaces += repositoryToPackageInfo.getPackageName(change.newAffectedEObject.eContainer() as Repository);
//	javaPackage.name = change.newValue
//}

//response: RenameClassForBasicComponent
//trigger: replace value pcm.repository.BasicComponent[entityName]
//retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newAffectedEObject
//	move containing model to project-relative location: componentToClass.getPathInProject(change.newAffectedEObject as BasicComponent)
//retrieve element: javaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
//execute: {
//	val component = change.newAffectedEObject as BasicComponent;
//	javaClass.name = componentToClass.getClassName(component);
//	compilationUnit.name = componentToClass.getClassName(component);
//	compilationUnit.namespaces.clear;
//	compilationUnit.namespaces += componentToClass.getPackageName(component);
//}

response: RenameClassForBasicComponent
trigger: replace value pcm.repository.BasicComponent[entityName]
update instances of java
execute: {
	val component = change.newAffectedEObject as BasicComponent;
	callRenameBasicComponentPackageAndClass(component);
}

effect: RenameBasicComponentPackageAndClass
model input: pcm.repository.BasicComponent as component
retrieve element: repositoryPackage of type java.containers.Package corresponding to component.repository__RepositoryComponent
	with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
execute: {
	callRenameBasicComponentPackage(component, repositoryPackage);
	callRenameBasicComponentClass(component);
}

effect: RenameBasicComponentPackage
model input: pcm.repository.BasicComponent as component, java.containers.Package as repositoryPackage  
retrieve element: componentPackage of type java.containers.Package corresponding to component
	move containing model to project-relative location: buildJavaFilePath(componentPackage)
execute: {
	componentPackage.namespaces.clear();
	componentPackage.namespaces += repositoryPackage.namespaces;
	componentPackage.namespaces += repositoryPackage.name;
	componentPackage.name = component.entityName;
}

effect: RenameBasicComponentClass
model input: pcm.repository.BasicComponent as component
retrieve element: componentPackage of type java.containers.Package corresponding to component
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to component
	move containing model to project-relative location: buildJavaFilePath(compilationUnit)
retrieve element: javaClass of type java.classifiers.Class corresponding to component
execute: {
	val componentImplementationName = component.entityName + "Impl";
	javaClass.name = componentImplementationName;
	compilationUnit.name = componentImplementationName;
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += componentPackage.namespaces;
	compilationUnit.namespaces += componentPackage.name;
}



//response: CreateDatatypesPackageForRepository
//trigger: insert root pcm.repository.Repository
//create element: javaPackage of type java.containers.Package corresponding to change.newValue
//persist as root at project-relative location: repositoryToDatatypesPackageInfo.getPathInProject(change.newValue)
//execute: {
//	javaPackage.namespaces += change.newValue.entityName;
//	javaPackage.name = "datatypes"
//}

response: CreateInterfaceForInterface
trigger: insert in list pcm.repository.Repository[interfaces__Repository]
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: interfaceToInterface.getPathInProject(change.newValue)
create element: javaInterface of type java.classifiers.Interface corresponding to change.newValue
retrieve element: contractsPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with contractsPackage.name == "contracts"
execute: {
	compilationUnit.namespaces += contractsPackage.namespaces;
	compilationUnit.namespaces += contractsPackage.name;
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaInterface, interfaceToInterface.getClassName(change.newValue));
}

response: RenameInterfaceForInterface
trigger: replace value pcm.repository.Interface[entityName]
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newAffectedEObject
	move containing model to project-relative location: interfaceToInterface.getPathInProject(change.newAffectedEObject as OperationInterface)
retrieve element: javaInterface of type java.classifiers.Interface corresponding to change.newAffectedEObject
retrieve element: contractsPackage of type java.containers.Package corresponding to (change.newAffectedEObject as OperationInterface).repository__Interface
	with contractsPackage.name == "contracts"
execute: {
	val interf = change.newAffectedEObject as OperationInterface;
	javaInterface.name = interf.entityName;
	compilationUnit.name = interf.entityName;
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += contractsPackage.namespaces;
	compilationUnit.namespaces += contractsPackage.name;
}

//response: CreateClassForBasicComponent
//trigger: insert in list pcm.repository.Repository[components__Repository]
//precondition: change.newValue instanceof BasicComponent
//retrieve element: componentPackage of type java.containers.Package corresponding to change.newValue
//create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
//	persist as root at project-relative location: buildJavaFilePath(compilationUnit.name, compilationUnit.namespaces)
//create element: javaClass of type java.classifiers.Class corresponding to change.newValue
//execute: {
//	//val repository = change.newAffectedEObject as Repository;
//	val component = change.newValue;
//	compilationUnit.namespaces += componentPackage.namespaces;
//	compilationUnit.namespaces += componentPackage.name;
//	val componentImplementationName = component.entityName + "Impl";
//	compilationUnit.name = componentImplementationName;
//	javaClass.name = componentImplementationName;
//	javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
//	compilationUnit.classifiers.add(javaClass);
//}

response: CreatePackageAndImplementationForComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
retrieve element: repositoryPackage of type java.containers.Package corresponding to change.newValue.repository__RepositoryComponent
	with change.newValue.repository__RepositoryComponent.entityName.equals(repositoryPackage.name)
execute: {
	val component = change.newValue;
	callCreatePackage(component, repositoryPackage, component.entityName);
	callCreateImplememetationForComponent(component);
}

effect: CreateImplememetationForComponent
model input: pcm.repository.RepositoryComponent as component
retrieve element: componentPackage of type java.containers.Package corresponding to component
execute: {
	callCreateClass(component, componentPackage);
}
//
//response: CreateClassForBasicComponent
//trigger: insert in list pcm.repository.Repository[components__Repository]
//precondition: change.newValue instanceof BasicComponent
//retrieve element: componentPackage of type java.containers.Package corresponding to change.newValue
//execute: {
//	val component = change.newValue;
//	callCreateClass(component, componentPackage);
//}

//response: CreateCompositeDataType
//trigger: insert in list pcm.repository.Repository[dataTypes__Repository]
//precondition: change.newValue instanceof CompositeDataType
//retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
//create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
//	persist as root at project-relative location: buildJavaFilePath(compilationUnit.name, compilationUnit.namespaces)
//create element: javaClass of type java.classifiers.Class corresponding to change.newValue
//execute: {
//	val dataType = change.newValue as CompositeDataType;
//	compilationUnit.namespaces += datatypesPackage.namespaces;
//	compilationUnit.namespaces += datatypesPackage.name;
//	val dataTypeImplementationName = dataType.entityName;
//	compilationUnit.name = dataTypeImplementationName;
//	javaClass.name = dataTypeImplementationName;
//	javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
//	compilationUnit.classifiers.add(javaClass);
//}

response: CreateCompositeDataType
trigger: insert in list pcm.repository.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CompositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
execute: {
	val compositeDataType = change.newValue as CompositeDataType;
	callCreateClass(compositeDataType, datatypesPackage);
}

effect: CreateClass
model input: pcm.core.entity.NamedElement as sourceElement, java.containers.Package as containingPackage
create element: compilationUnit of type java.containers.CompilationUnit corresponding to sourceElement
	persist as root at project-relative location: buildJavaFilePath(compilationUnit)
create element: javaClass of type java.classifiers.Class corresponding to sourceElement
execute: {
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
	val componentImplementationName = if (sourceElement instanceof RepositoryComponent) {
		sourceElement.entityName + "Impl";
	} else {
		sourceElement.entityName;
	}
	compilationUnit.name = componentImplementationName;
	javaClass.name = componentImplementationName;
	javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	compilationUnit.classifiers.add(javaClass);
}


response: DeleteClassForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
delete element: compilationUnit of type java.containers.CompilationUnit corresponding to change.oldValue
delete element: javaClass of type java.classifiers.Class corresponding to change.oldValue

response: DeletePackageForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
delete element: javaPackage of type java.containers.Package corresponding to change.oldValue





response: CreateClassForCompositeComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
precondition: change.newValue instanceof CompositeComponent
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: componentToClass.getPathInProject(change.newValue)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	compilationUnit.namespaces += componentToClass.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, componentToClass.getClassName(change.newValue));
}

response: AddAssemblyContextInCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[assemblyContexts__ComposedStructure]
retrieve element: compositeComponentJavaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: encapsulatedComponentJavaClass of type java.classifiers.Class corresponding to change.newValue.encapsulatedComponent__AssemblyContext
create element: assemblyContextField of type java.members.Field corresponding to change.newValue
create element: newConstructorCall of type java.instantiations.NewConstructorCall corresponding to change.newValue
create element: contextClassImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: constructor of type java.members.Constructor corresponding to change.newValue
execute: {
	val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
	val newAssemblyContext = change.newValue;
	createPrivateField(assemblyContextField, typeRef, newAssemblyContext.entityName);
	compositeComponentJavaClass.members += assemblyContextField;
	addConstructorToClass(constructor, compositeComponentJavaClass)
	addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
	createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
}

response: AddProvidedRoleToCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[providedRoles_InterfaceProvidingEntity]
precondition: change.newValue instanceof OperationProvidedRole
retrieve element: operationProvidingInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationProvidedRole).providedInterface__OperationProvidedRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.providingEntity_ProvidedRole
create element: interfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to change.newValue
execute: {
	createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
	javaClass.implements.add(namespaceClassifierReference)
	addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
}

response: AddRequiredRoleToCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[requiredRoles_InterfaceRequiringEntity]
precondition: change.newValue instanceof OperationRequiredRole
retrieve element: requiredInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationRequiredRole).requiredInterface__OperationRequiredRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.requiringEntity_RequiredRole
create element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: requiredInterfaceField of type java.members.Field corresponding to change.newValue 
execute: {
	val typeRef = createNamespaceClassifierReference(requiredInterface);
	addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
	val requiredRoleName = change.newValue.entityName;
	createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
	javaClass.members += requiredInterfaceField;
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		val newParam = PCM2JaMoPPUtils.createOrdinaryParameter(EcoreUtil.copy(typeRef), requiredRoleName)
		ctor.parameters.add(newParam)
		val asssignment = PCM2JaMoPPUtils.createAssignmentFromParameterToField(requiredInterfaceField, newParam);
		ctor.statements.add(asssignment)
	}
}



response: RenameCompositeDataType
trigger: replace value pcm.repository.CompositeDataType[entityName]
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newAffectedEObject
	move containing model to project-relative location: dataTypeToClass.getPathInProject(change.newAffectedEObject as CompositeDataType)
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
execute: {
	val compositeDataType = change.newAffectedEObject as CompositeDataType;
	javaClass.name = dataTypeToClass.getClassName(compositeDataType);
	compilationUnit.name = dataTypeToClass.getClassName(compositeDataType);
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += dataTypeToClass.getPackageName(compositeDataType);
}

/* TODO HK: Combine with primitive type response using new language construct */
response: AddCompositeDataTypeToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
precondition: !(change.newValue.datatype_InnerDeclaration instanceof PrimitiveDataType)
retrieve element: dataTypeClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: nonPrimitiveInnerDataTypeClass of type java.classifiers.Class corresponding to change.newValue.datatype_InnerDeclaration
create element: innerDataTypeField of type java.members.Field corresponding to change.newValue
create element: getterMethod of type java.members.ClassMethod corresponding to change.newValue
create element: setterMethod of type java.members.ClassMethod corresponding to change.newValue
execute: {
	val typeRef = createNamespaceClassifierReference(nonPrimitiveInnerDataTypeClass);
	createPrivateField(innerDataTypeField, EcoreUtil.copy(typeRef), change.newValue.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: AddPrimitiveDataTypeToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
precondition: change.newValue.datatype_InnerDeclaration instanceof PrimitiveDataType
retrieve element: dataTypeClass of type java.classifiers.Class corresponding to change.newAffectedEObject
create element: innerDataTypeField of type java.members.Field corresponding to change.newValue
create element: getterMethod of type java.members.ClassMethod corresponding to change.newValue
create element: setterMethod of type java.members.ClassMethod corresponding to change.newValue
execute: {
	val typeRef = EcoreUtil.copy(claimJaMoPPTypeForPrimitiveDataType(change.newValue.datatype_InnerDeclaration as PrimitiveDataType)) as TypeReference;
	createPrivateField(innerDataTypeField, EcoreUtil.copy(typeRef), change.newValue.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: ChangeNameOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[entityName]
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	val newName = change.newValue;
	compositeTypeField.name = newName;
	compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.name = "set" + newName.toFirstUpper;
	}
}

response: ChangeTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
precondition: !(change.newValue instanceof PrimitiveDataType)
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
retrieve element: newJavaDataType of type java.classifiers.Class corresponding to change.newValue
execute: {
	val newDataTypeReference = createNamespaceClassifierReference(newJavaDataType);
	compositeTypeField.typeReference = EcoreUtil.copy(newDataTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newDataTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newDataTypeReference)
	}
}

response: ChangePrimitiveTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
precondition: change.newValue instanceof PrimitiveDataType
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	val newDataType = EcoreUtil.copy(claimJaMoPPTypeForPrimitiveDataType(change.newValue as PrimitiveDataType));
	val TypeReference newDataTypeReference = if (newDataType instanceof ConcreteClassifier) {
			createNamespaceClassifierReference(newDataType);
		} else if (newDataType instanceof TypeReference) {
			newDataType;
		};
	compositeTypeField.typeReference = EcoreUtil.copy(newDataTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newDataTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newDataTypeReference)
	}
}
