import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.tests.pcmjava.PCMJavaHelper.*;
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.emftext.language.java.types.TypeReference
import org.eclipse.emf.ecore.util.EcoreUtil
import edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.transformations.pcm2java.PCM2JaMoPPUtils
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.repository.PrimitiveDataType
import org.emftext.language.java.classifiers.ConcreteClassifier
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import org.palladiosimulator.pcm.repository.InnerDeclaration
import org.emftext.language.java.types.TypesFactory
import org.palladiosimulator.pcm.repository.OperationSignature
import com.google.common.collect.Sets
import org.palladiosimulator.pcm.repository.RepositoryComponent
import org.emftext.language.java.statements.ExpressionStatement
import org.emftext.language.java.expressions.AssignmentExpression
import org.emftext.language.java.references.SelfReference
import org.emftext.language.java.references.IdentifierReference
import org.emftext.language.java.members.Field
import org.emftext.language.java.statements.Statement
import org.emftext.language.java.parameters.Parameter
import org.palladiosimulator.pcm.repository.RequiredRoleContainerMock
import org.palladiosimulator.pcm.core.entity.InterfaceRequiringEntity
import org.palladiosimulator.pcm.repository.RequiredRole
import org.emftext.language.java.types.Type

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm


// ###################################################
// ################ PACKAGE RESPONSES ################

response: CreatePackagesForRepository
trigger: insert root pcm.repository.Repository
update instances of java
execute: {
	val repository = change.newValue;
	callCreateJavaPackage(repository, null, repository.entityName);
	callCreateRepositorySubPackages(repository);
}

effect: CreateRepositorySubPackages
model input: pcm.repository.Repository as repository
retrieve element: repositoryPackage of type java.containers.Package corresponding to repository
execute: {
	callCreateJavaPackage(repository, repositoryPackage, "datatypes");
	callCreateJavaPackage(repository, repositoryPackage, "contracts");
}

response: RenameRepositoryPackages
trigger: replace value pcm.repository.Repository[entityName]
retrieve element: rootPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with rootPackage.name != "contracts" && rootPackage.name != "datatypes" // TODO HK: Check for change.oldValue currently not possible
	move containing model to project-relative location: buildJavaFilePath(rootPackage)
execute: {
	val repository = change.newAffectedEObject as Repository;
	rootPackage.name = change.newValue;
	callRenameJavaPackage(repository, rootPackage, "contracts");
	callRenameJavaPackage(repository, rootPackage, "datatypes");	
	for (component : repository.components__Repository.filter(BasicComponent)) {
		callRenameComponentPackageAndClass(component);
	}
	for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
		callRenameInterface(interface);
	}
	// TODO HK: Other data types are missing
	for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
		callRenameCompositeDataType(dataType);
	}
}


// #####################################################
// ################ COMPONENT RESPONSES ################

response: CreateComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
retrieve element: repositoryPackage of type java.containers.Package corresponding to change.newValue.repository__RepositoryComponent
	with change.newValue.repository__RepositoryComponent.entityName.equals(repositoryPackage.name)
execute: {
	val component = change.newValue;
	callCreateJavaPackage(component, repositoryPackage, component.entityName);
	callCreateImplementationForComponent(component);
}

effect: CreateImplementationForComponent
model input: pcm.repository.RepositoryComponent as component
retrieve element: componentPackage of type java.containers.Package corresponding to component
execute: callCreateJavaClass(component, componentPackage, component.entityName + "Impl")

response: RenameComponent
trigger: replace value pcm.repository.RepositoryComponent[entityName]
update instances of java
execute: {
	val component = change.newAffectedEObject as RepositoryComponent;
	callRenameComponentPackageAndClass(component);
}

effect: RenameComponentPackageAndClass
model input: pcm.repository.RepositoryComponent as component
retrieve element: repositoryPackage of type java.containers.Package corresponding to component.repository__RepositoryComponent
	with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
execute: {
	callRenameJavaPackage(component, repositoryPackage, component.entityName);
	callRenameComponentClass(component);
}

effect: RenameComponentClass
model input: pcm.repository.RepositoryComponent as component
retrieve element: componentPackage of type java.containers.Package corresponding to component
execute: callRenameJavaClassifier(component, componentPackage, component.entityName + "Impl")

response: DeleteComponentClass
trigger: remove from list pcm.repository.Repository[components__Repository]
update instances of java
execute: callDeleteJavaClassifier(change.oldValue)

response: DeletePackageForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
update instances of java
execute: callDeleteJavaPackage(change.oldValue, change.oldValue.entityName)


// #####################################################
// ################ INTERFACE RESPONSES ################

response: CreateInterface
trigger: insert in list pcm.repository.Repository[interfaces__Repository]
retrieve element: contractsPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with contractsPackage.name == "contracts"
execute: {
	val interf = change.newValue;
	callCreateJavaInterface(interf, contractsPackage, interf.entityName);
}

response: RenamedInterface
trigger: replace value pcm.repository.Interface[entityName]
update instances of java
execute: callRenameInterface(change.newAffectedEObject as OperationInterface)

effect: RenameInterface
model input: pcm.repository.OperationInterface as interf
retrieve element: contractsPackage of type java.containers.Package corresponding to interf.repository__Interface
	with contractsPackage.name == "contracts"
execute: callRenameJavaClassifier(interf, contractsPackage, interf.entityName)


// ######################################################
// ################ DATA TYPES RESPONSES ################

response: CreatedCompositeDataType
trigger: insert in list pcm.repository.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CompositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
execute: {
	val compositeDataType = change.newValue as CompositeDataType;
	callCreateJavaClass(compositeDataType, datatypesPackage, compositeDataType.entityName);
}

response: RenamedCompositeDataType
trigger: replace value pcm.repository.CompositeDataType[entityName]
update instances of java
execute: callRenameCompositeDataType(change.newAffectedEObject as CompositeDataType)

effect: RenameCompositeDataType
model input: pcm.repository.CompositeDataType as compositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
execute: callRenameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)

response: RemovedCompositeDataType
trigger: remove from list pcm.repository.Repository[dataTypes__Repository]
precondition: change.oldValue instanceof CompositeDataType
update instances of java
execute: callDeleteJavaClassifier(change.oldValue as CompositeDataType)

// ################ DATA TYPES - INNER DECLARATION RESPONSES ################

response: AddedInnerDeclarationToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
retrieve element: nonPrimitiveInnerDataTypeClass of type java.classifiers.Class corresponding to change.newValue.datatype_InnerDeclaration optional
execute: {
	val innerDataTypeReference = createTypeReference(change.newValue.datatype_InnerDeclaration, nonPrimitiveInnerDataTypeClass);
	val compositeDataType = change.newAffectedEObject as CompositeDataType;
	val innerDeclaration = change.newValue;
	callAddInnerDeclarationToCompositeDataType(compositeDataType, innerDeclaration, innerDataTypeReference);
}

effect: AddInnerDeclarationToCompositeDataType
model input: pcm.repository.CompositeDataType as compositeDataType, pcm.repository.InnerDeclaration as innerDeclaration, java.types.TypeReference as dataTypeReference
retrieve element: dataTypeClass of type java.classifiers.Class corresponding to compositeDataType
create element: innerDataTypeField of type java.members.Field corresponding to innerDeclaration
create element: getterMethod of type java.members.ClassMethod corresponding to innerDeclaration
create element: setterMethod of type java.members.ClassMethod corresponding to innerDeclaration
execute: {
	createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: ChangeNameOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[entityName]
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.ClassMethod corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.ClassMethod corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	val newName = change.newValue;
	compositeTypeField.name = newName;
	compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.name = "set" + newName.toFirstUpper;
	}
}

response: ChangeTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
retrieve element: newJavaDataType of type java.classifiers.Class corresponding to change.newValue optional
execute: {
	val innerDeclaration = change.newAffectedEObject as InnerDeclaration;
	val newDataTypeReference = createTypeReference(change.newValue, newJavaDataType);
	callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
}

effect: ChangeInnerDeclarationType
model input: pcm.repository.InnerDeclaration as innerDeclaration, java.types.TypeReference as newTypeReference
retrieve element: compositeTypeField of type java.members.Field corresponding to innerDeclaration
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to innerDeclaration
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to innerDeclaration
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newTypeReference)
	}
}


// ######################################################
// ################ JAVA PACKAGE EFFECTS ################

effect: CreateJavaPackage
model input: pcm.core.entity.NamedElement as sourceElementMappedToPackage, java.containers.Package as parentPackage
java input: String as packageName
create element: javaPackage of type java.containers.Package corresponding to sourceElementMappedToPackage
	persist as root at project-relative location: buildJavaFilePath(javaPackage)
execute: {
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}

effect: RenameJavaPackage
model input: pcm.core.entity.NamedElement as sourceElementMappedToPackage, java.containers.Package as parentPackage
java input: String as packageName
retrieve element: javaPackage of type java.containers.Package corresponding to sourceElementMappedToPackage
	move containing model to project-relative location: buildJavaFilePath(javaPackage)
execute: {
	javaPackage.namespaces.clear();
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}

effect: DeleteJavaPackage
model input: pcm.core.entity.NamedElement as sourceElementMappedToPackage
java input: String as packageName
delete element: javaPackage of type java.containers.Package corresponding to sourceElementMappedToPackage
	with javaPackage.name.equals(packageName)


// ######################################################
// ################ JAVA CLASS EFFECTS ##################

effect: CreateJavaClass
model input: pcm.core.entity.NamedElement as sourceElementMappedToClass, java.containers.Package as containingPackage
java input: String as className
create element: javaClass of type java.classifiers.Class corresponding to sourceElementMappedToClass
execute: {
	javaClass.name = className;
	javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	callCreateCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage);
}

effect: CreateJavaInterface
model input: pcm.core.entity.NamedElement as sourceElementMappedToClass, java.containers.Package as containingPackage
java input: String as className
create element: javaInterface of type java.classifiers.Interface corresponding to sourceElementMappedToClass
execute: {
	javaInterface.name = className;
	javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	callCreateCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage);
}

effect: CreateCompilationUnit
model input: pcm.core.entity.NamedElement as sourceElementMappedToClass, java.classifiers.ConcreteClassifier as classifier, java.containers.Package as containingPackage
create element: compilationUnit of type java.containers.CompilationUnit corresponding to sourceElementMappedToClass
	persist as root at project-relative location: buildJavaFilePath(compilationUnit)
execute: {
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
	compilationUnit.name = classifier.name;
	compilationUnit.classifiers.add(classifier);
}

effect: RenameJavaClassifier
model input: pcm.core.entity.NamedElement as classSourceElement, java.containers.Package as containingPackage
java input: String as className
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to classSourceElement
	move containing model to project-relative location: buildJavaFilePath(compilationUnit)
retrieve element: javaClassifier of type java.classifiers.ConcreteClassifier corresponding to classSourceElement
execute: {
	javaClassifier.name = className;
	compilationUnit.name = className;
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
}

effect: DeleteJavaClassifier
model input: pcm.core.entity.NamedElement as sourceElement
delete element: javaClassifier of type java.classifiers.ConcreteClassifier corresponding to sourceElement
delete element: compilationUnit of type java.containers.CompilationUnit corresponding to sourceElement



response: AddAssemblyContextInCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[assemblyContexts__ComposedStructure]
retrieve element: compositeComponentJavaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: encapsulatedComponentJavaClass of type java.classifiers.Class corresponding to change.newValue.encapsulatedComponent__AssemblyContext
create element: assemblyContextField of type java.members.Field corresponding to change.newValue
create element: newConstructorCall of type java.instantiations.NewConstructorCall corresponding to change.newValue
create element: contextClassImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: constructor of type java.members.Constructor corresponding to change.newValue
execute: {
	val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
	val newAssemblyContext = change.newValue;
	createPrivateField(assemblyContextField, typeRef, newAssemblyContext.entityName);
	compositeComponentJavaClass.members += assemblyContextField;
	addConstructorToClass(constructor, compositeComponentJavaClass)
	addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
	createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
}


// ####################################################
// ################ PROVIDED ROLES ####################

response: AddedProvidedRoleToComponent
trigger: insert in list pcm.repository.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
precondition: change.newValue instanceof OperationProvidedRole
update instances of java
execute: callAddProvidedRole(change.newValue as OperationProvidedRole)

effect: AddProvidedRole
model input: pcm.repository.OperationProvidedRole as providedRole
retrieve element: operationProvidingInterface of type java.classifiers.Interface corresponding to providedRole.providedInterface__OperationProvidedRole
retrieve element: javaClass of type java.classifiers.Class corresponding to providedRole.providingEntity_ProvidedRole
create element: interfaceImport of type java.imports.ClassifierImport corresponding to providedRole
create element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to providedRole
execute: {
	createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
	javaClass.implements.add(namespaceClassifierReference)
	addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
}

response: ChangedProvidedInterfaceOfProvidedRole
trigger: replace value pcm.repository.OperationProvidedRole[providedInterface__OperationProvidedRole]
update instances of java
execute: {
	val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: ChangedProvidingEntityOfProvidedRole
trigger: replace value pcm.repository.OperationProvidedRole[providingEntity_ProvidedRole]
update instances of java
execute: {
	val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: RemovedProvidedRoleFromComponent
trigger: remove from list pcm.repository.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
update instances of java
execute: callRemoveProvidedRole(change.oldValue)

effect: RemoveProvidedRole
model input: pcm.repository.ProvidedRole as providedRole
delete element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to providedRole
delete element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to providedRole


// ####################################################
// ################ REQUIRED ROLES ####################

// TODO HK Check again with new Change MM. When replacing the requiringEntity, the oldValue cannot be retrieved in the old 
// changes. So the requiredRole cannot be reinitialized correctly.

// TODO HK implement ctor statement as correspondence (dynamic in explicit effect for each ctor) to remove them easily
// Use as example for responses best practices chapter
// TODO HK Implement rename correctly when having all four correspondences correctly 
response: AddRequiredRoleToComponent
trigger: insert in list pcm.repository.RepositoryComponent[requiredRoles_InterfaceRequiringEntity]
precondition: change.newValue instanceof OperationRequiredRole
update instances of java
execute: callAddRequiredRole(change.newValue as OperationRequiredRole)

effect: AddRequiredRole
model input: pcm.repository.OperationRequiredRole as requiredRole
retrieve element: requiredInterface of type java.classifiers.Interface corresponding to requiredRole.requiredInterface__OperationRequiredRole
retrieve element: javaClass of type java.classifiers.Class corresponding to requiredRole.requiringEntity_RequiredRole
create element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to requiredRole
create element: requiredInterfaceField of type java.members.Field corresponding to requiredRole
execute: {
	val typeRef = createNamespaceClassifierReference(requiredInterface);
	addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
	val requiredRoleName = requiredRole.entityName;
	createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
	javaClass.members += requiredInterfaceField;
	if (javaClass.members.filter(typeof(Constructor)).nullOrEmpty) {
		PCM2JaMoPPUtils.addConstructorToClass(javaClass)
	}
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		val newParam = PCM2JaMoPPUtils.createOrdinaryParameter(EcoreUtil.copy(typeRef), requiredRoleName)
		ctor.parameters.add(newParam)
		val asssignment = PCM2JaMoPPUtils.createAssignmentFromParameterToField(requiredInterfaceField, newParam);
		ctor.statements.add(asssignment)
	}
}

response: RemoveRequiredRoleFromComponent
trigger: remove from list pcm.repository.RepositoryComponent[requiredRoles_InterfaceRequiringEntity]
precondition: change.oldValue instanceof OperationRequiredRole
update instances of java
execute: {
	callRemoveRequiredRole(change.oldValue, change.oldAffectedEObject as RepositoryComponent);
}

effect: RemoveRequiredRole
model input: pcm.repository.RequiredRole as requiredRole, pcm.core.entity.InterfaceRequiringEntity as requiringEntity
delete element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to requiredRole
delete element: requiredInterfaceField of type java.members.Field corresponding to requiredRole
retrieve element: javaClass of type java.classifiers.Class corresponding to requiringEntity
execute: {
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		var Statement statementToRemove = null;
		for (statement : ctor.statements) {
			if (statement instanceof ExpressionStatement) {
				val assignmentExpression = statement.expression
				if (assignmentExpression instanceof AssignmentExpression) {
					val selfReference = assignmentExpression.child;
					if (selfReference instanceof SelfReference) {
						val fieldReference = selfReference.next;
						if (fieldReference instanceof IdentifierReference) {
							val field = fieldReference.target;
							if (field instanceof Field) {
								if (field.name.equals(requiredRole.entityName)) {
									statementToRemove = statement;
								}
							}
						}
						
					}
				
				}
			}
		}
		var Parameter parameterToRemove = null;
		for (parameter : ctor.parameters) {
			if (parameter.name.equals(requiredRole.entityName)) {
				parameterToRemove = parameter;
			}
		}
		if (statementToRemove != null) {
			ctor.statements.remove(statementToRemove);
		}
		if (parameterToRemove != null) {
			ctor.parameters.remove(parameterToRemove);
		}
	}
}

effect: ReinitializeOperationRequiredRole
model input: pcm.repository.OperationRequiredRole as requiredRole
update instances of java
execute: {
	callRemoveRequiredRole(requiredRole, requiredRole.requiringEntity_RequiredRole);
	callAddRequiredRole(requiredRole);
}

response: RenameOperationRequiredRole
trigger: replace value pcm.repository.OperationRequiredRole[entityName]
update instances of java
execute: callReinitializeOperationRequiredRole(change.newAffectedEObject as OperationRequiredRole)

response: ChangeOperationRequiredRoleEntity
trigger: replace value pcm.repository.OperationRequiredRole[requiringEntity_RequiredRole]
update instances of java
execute: {
	val requiredRole = change.newAffectedEObject as OperationRequiredRole;
	callRemoveRequiredRole(requiredRole, change.oldValue);
	callAddRequiredRole(requiredRole);
}

response: ChangeOperationRequiredRoleInterface
trigger: replace value pcm.repository.OperationRequiredRole[requiredInterface__OperationRequiredRole]
update instances of java
execute: callReinitializeOperationRequiredRole(change.newAffectedEObject as OperationRequiredRole)


// ##########################################################
// ################ OPERATION SIGNATURES ####################

// TODO HK Implement changing the signature interface. All components with their SEFFs have to be updated.
// Use more reasonable correspondences than Michael
response: AddOperationSignature
trigger: insert in list pcm.repository.OperationInterface[signatures__OperationInterface]
retrieve element: javaInterface of type java.classifiers.Interface corresponding to change.newAffectedEObject
create element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newValue
execute: {
	interfaceMethod.name = change.newValue.entityName;
	callChangeInterfaceMethodReturnType(interfaceMethod, change.newValue.returnType__OperationSignature);
	javaInterface.members += interfaceMethod;
}

response: RenameOperationSignature
trigger: replace value pcm.repository.OperationSignature[entityName]
retrieve element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newAffectedEObject
execute: {
	val operationSignature = change.newAffectedEObject as OperationSignature;
	val operationInterface = operationSignature.interface__OperationSignature;
	interfaceMethod.name = change.newValue;
	// get implementing components
	val implementingComponents = Sets.newHashSet
	operationInterface.repository__Interface.components__Repository.forEach [ comp |
		val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
		opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
			implementingComponents.add(opProRole.providingEntity_ProvidedRole)
		]
	]
	val basicComponents = implementingComponents.filter(BasicComponent)
	
	// TODO HK Update name of methods of implementating components (SEFFs realizations)
//	basicComponents.forEach[
//		it.serviceEffectSpecifications__BasicComponent.forEach[
//			val correspondingClassMethods = blackboard.correspondenceInstance.getCorrespondingEObjectsByType(it, ClassMethod)
//			if(!correspondingClassMethods.nullOrEmpty){
//				correspondingClassMethods.forEach[
//					val oldTUID = blackboard.correspondenceInstance.calculateTUIDFromEObject(it)
//					it.name = newValue.toString
//					blackboard.correspondenceInstance.updateTUID(oldTUID, it)
//				]
//			}	
//		]
//	]
}

response: ChangeOperationSignatureReturnType
trigger: replace value pcm.repository.OperationSignature[returnType__OperationSignature]
retrieve element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newAffectedEObject
execute: callChangeInterfaceMethodReturnType(interfaceMethod, (change.newAffectedEObject as OperationSignature).returnType__OperationSignature)

effect: ChangeInterfaceMethodReturnType
model input: java.members.InterfaceMethod as interfaceMethod, pcm.repository.DataType as returnType
retrieve element: returnTypeClass of type java.classifiers.Class corresponding to returnType optional
execute: {
	val returnTypeReference = createTypeReference(returnType, returnTypeClass);
	interfaceMethod.typeReference = returnTypeReference;
}

response: DeleteOperationSignature
trigger: remove from list pcm.repository.OperationInterface[signatures__OperationInterface]
delete element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.oldValue



response: CreatedParameter
trigger: insert in list pcm.repository.OperationSignature[parameters__OperationSignature]
retrieve element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newAffectedEObject
create element: javaParameter of type java.parameters.OrdinaryParameter corresponding to change.newValue
execute: {
	javaParameter.name = change.newValue.parameterName;
	callChangeParameterType(javaParameter, change.newValue.dataType__Parameter);
	interfaceMethod.parameters += javaParameter;
}

response: ChangedParameterName
trigger: replace value pcm.repository.Parameter[parameterName]
retrieve element: javaParameter of type java.parameters.OrdinaryParameter corresponding to change.newAffectedEObject
execute: {
	javaParameter.name = change.newValue;
}

response: ChangedParameterType
trigger: replace value pcm.repository.Parameter[dataType__Parameter]
// retrieve the interface method to update the TUID according to the new parameter type
retrieve element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newAffectedEObject.eContainer
retrieve element: javaParameter of type java.parameters.OrdinaryParameter corresponding to change.newAffectedEObject
execute: callChangeParameterType(javaParameter, change.newValue)

effect: ChangeParameterType
model input: java.parameters.OrdinaryParameter as javaParameter, pcm.repository.DataType as parameterType
retrieve element: javaParameterTypeClass of type java.classifiers.Class corresponding to parameterType optional
execute: {
	val parameterTypeReference = createTypeReference(parameterType, javaParameterTypeClass);
	javaParameter.typeReference = parameterTypeReference;
}

response: RemovedParameter
trigger: remove from list pcm.repository.OperationSignature[parameters__OperationSignature]
// retrieve the interface method to update the TUID according to the removed parameter type
retrieve element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newAffectedEObject
delete element: javaParameter of type java.parameters.OrdinaryParameter corresponding to change.oldValue


