import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.tests.pcmjava.PCMJavaHelper.*;
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeComponent
import org.emftext.language.java.types.TypeReference
import org.eclipse.emf.ecore.util.EcoreUtil
import org.emftext.language.java.modifiers.ModifiersFactory
import edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.transformations.pcm2java.PCM2JaMoPPUtils
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.CompositeDataType

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm

response: CreatePackageForRepository
trigger: insert root pcm.repository.Repository
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: repositoryToPackageInfo.getPathInProject(change.newValue)
execute: {
	val newRepository = change.newValue;
	javaPackage.name = newRepository.entityName
}

response: CreateContractsPackageForRepository
trigger: insert root pcm.repository.Repository
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: repositoryToContractsPackageInfo.getPathInProject(change.newValue)
execute: {
	javaPackage.namespaces += repositoryToContractsPackageInfo.getPackageName(change.newValue).split("\\.");
	javaPackage.name = "contracts"
}

response: CreateDatatypesPackageForRepository
trigger: insert root pcm.repository.Repository
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: repositoryToDatatypesPackageInfo.getPathInProject(change.newValue)
execute: {
	javaPackage.namespaces += repositoryToDatatypesPackageInfo.getPackageName(change.newValue).split("\\.");
	javaPackage.name = "datatypes"
}

response: CreateClassForBasicComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
precondition: change.newValue instanceof BasicComponent
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: componentToClass.getPathInProject(change.newValue)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	compilationUnit.namespaces += componentToClass.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, componentToClass.getClassName(change.newValue));
}

response: CreatePackageForComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: componentToPackageInfo.getPathInProject(change.newValue)
execute: {
	javaPackage.namespaces += repositoryToPackageInfo.getPackageName(change.newAffectedEObject as Repository);
	javaPackage.name = change.newValue.entityName
}

response: CreateInterfaceForInterface
trigger: insert in list pcm.repository.Repository[interfaces__Repository]
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: interfaceToInterface.getPathInProject(change.newValue)
create element: javaInterface of type java.classifiers.Interface corresponding to change.newValue
execute: {
	compilationUnit.namespaces += interfaceToInterface.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaInterface, interfaceToInterface.getClassName(change.newValue));
}

response: DeleteClassForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
delete element: compilationUnit of type java.containers.CompilationUnit corresponding to change.oldValue
delete element: javaClass of type java.classifiers.Class corresponding to change.oldValue

response: DeletePackageForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
delete element: javaPackage of type java.containers.Package corresponding to change.oldValue


response: RenamePackageForBasicComponent
trigger: replace value pcm.repository.BasicComponent[entityName]
retrieve element: javaPackage of type java.containers.Package corresponding to change.newAffectedEObject
	move containing model to project-relative location: componentToPackageInfo.getPathInProject(change.newAffectedEObject as BasicComponent)
execute: {
	javaPackage.namespaces.clear();
	javaPackage.namespaces += repositoryToPackageInfo.getPackageName(change.newAffectedEObject.eContainer() as Repository);
	javaPackage.name = change.newValue
}


response: RenameClassForBasicComponent
trigger: replace value pcm.repository.BasicComponent[entityName]
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newAffectedEObject
	move containing model to project-relative location: componentToClass.getPathInProject(change.newAffectedEObject as BasicComponent)
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
execute: {
	val component = change.newAffectedEObject as BasicComponent;
	javaClass.name = componentToClass.getClassName(component);
	compilationUnit.name = componentToClass.getClassName(component);
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += componentToClass.getPackageName(component);
}


response: CreateClassForCompositeComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
precondition: change.newValue instanceof CompositeComponent
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: componentToClass.getPathInProject(change.newValue)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	compilationUnit.namespaces += componentToClass.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, componentToClass.getClassName(change.newValue));
}

response: AddAssemblyContextInCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[assemblyContexts__ComposedStructure]
retrieve element: compositeComponentJavaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: encapsulatedComponentJavaClass of type java.classifiers.Class corresponding to change.newValue.encapsulatedComponent__AssemblyContext
create element: assemblyContextField of type java.members.Field corresponding to change.newValue
create element: newConstructorCall of type java.instantiations.NewConstructorCall corresponding to change.newValue
create element: contextClassImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: constructor of type java.members.Constructor corresponding to change.newValue
execute: {
	val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
	val newAssemblyContext = change.newValue;
	createPrivateField(assemblyContextField, typeRef, newAssemblyContext.entityName);
	compositeComponentJavaClass.members += assemblyContextField;
	addConstructorToClass(constructor, compositeComponentJavaClass)
	addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
	createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
}

response: AddProvidedRoleToCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[providedRoles_InterfaceProvidingEntity]
precondition: change.newValue instanceof OperationProvidedRole
retrieve element: operationProvidingInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationProvidedRole).providedInterface__OperationProvidedRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.providingEntity_ProvidedRole
create element: interfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to change.newValue
execute: {
	createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
	javaClass.implements.add(namespaceClassifierReference)
	addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
}

response: AddRequiredRoleToCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[requiredRoles_InterfaceRequiringEntity]
precondition: change.newValue instanceof OperationRequiredRole
retrieve element: requiredInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationRequiredRole).requiredInterface__OperationRequiredRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.requiringEntity_RequiredRole
create element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: requiredInterfaceField of type java.members.Field corresponding to change.newValue 
execute: {
	val typeRef = createNamespaceClassifierReference(requiredInterface);
	addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
	val requiredRoleName = change.newValue.entityName;
	createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
	javaClass.members += requiredInterfaceField;
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		val newParam = PCM2JaMoPPUtils.createOrdinaryParameter(EcoreUtil.copy(typeRef), requiredRoleName)
		ctor.parameters.add(newParam)
		val asssignment = PCM2JaMoPPUtils.createAssignmentFromParameterToField(requiredInterfaceField, newParam);
		ctor.statements.add(asssignment)
	}
}

response: CreateCompositeDataType
trigger: insert in list pcm.repository.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CompositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: dataTypeToClass.getPathInProject(change.newValue as CompositeDataType)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	val dataType = change.newValue as CompositeDataType;
	compilationUnit.namespaces += dataTypeToClass.getPackageName(dataType);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, dataTypeToClass.getClassName(dataType));
	
}



