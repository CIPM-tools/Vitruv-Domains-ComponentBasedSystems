import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.tests.pcmjava.PCMJavaHelper.*;
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.emftext.language.java.types.TypeReference
import org.eclipse.emf.ecore.util.EcoreUtil
import edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.transformations.pcm2java.PCM2JaMoPPUtils
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.repository.PrimitiveDataType
import org.emftext.language.java.classifiers.ConcreteClassifier
import org.palladiosimulator.pcm.repository.OperationInterface
import org.emftext.language.java.modifiers.ModifiersFactory
import org.palladiosimulator.pcm.repository.InnerDeclaration
import org.emftext.language.java.types.TypesFactory
import org.palladiosimulator.pcm.repository.OperationSignature
import com.google.common.collect.Sets
import org.palladiosimulator.pcm.repository.RepositoryComponent

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm


// ###################################################
// ################ PACKAGE RESPONSES ################

response: CreatePackagesForRepository
trigger: insert root pcm.repository.Repository
update instances of java
execute: {
	val repository = change.newValue;
	callCreateJavaPackage(repository, null, repository.entityName);
	callCreateRepositorySubPackages(repository);
}

effect: CreateRepositorySubPackages
model input: pcm.repository.Repository as repository
retrieve element: repositoryPackage of type java.containers.Package corresponding to repository
execute: {
	callCreateJavaPackage(repository, repositoryPackage, "datatypes");
	callCreateJavaPackage(repository, repositoryPackage, "contracts");
}

response: RenameRepositoryPackages
trigger: replace value pcm.repository.Repository[entityName]
retrieve element: rootPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with rootPackage.name != "contracts" && rootPackage.name != "datatypes" // TODO HK: Check for change.oldValue currently not possible
	move containing model to project-relative location: buildJavaFilePath(rootPackage)
execute: {
	val repository = change.newAffectedEObject as Repository;
	rootPackage.name = change.newValue;
	callRenameJavaPackage(repository, rootPackage, "contracts");
	callRenameJavaPackage(repository, rootPackage, "datatypes");	
	for (component : repository.components__Repository.filter(BasicComponent)) {
		callRenameComponentPackageAndClass(component);
	}
	for (interface : repository.interfaces__Repository.filter(OperationInterface)) {
		callRenameInterface(interface);
	}
	// TODO HK: Other data types are missing
	for (dataType : repository.dataTypes__Repository.filter(CompositeDataType)) {
		callRenameCompositeDataType(dataType);
	}
}


// #####################################################
// ################ COMPONENT RESPONSES ################

response: CreateComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
retrieve element: repositoryPackage of type java.containers.Package corresponding to change.newValue.repository__RepositoryComponent
	with change.newValue.repository__RepositoryComponent.entityName.equals(repositoryPackage.name)
execute: {
	val component = change.newValue;
	callCreateJavaPackage(component, repositoryPackage, component.entityName);
	callCreateImplementationForComponent(component);
}

effect: CreateImplementationForComponent
model input: pcm.repository.RepositoryComponent as component
retrieve element: componentPackage of type java.containers.Package corresponding to component
execute: callCreateJavaClass(component, componentPackage, component.entityName + "Impl")

response: RenameComponent
trigger: replace value pcm.repository.RepositoryComponent[entityName]
update instances of java
execute: {
	val component = change.newAffectedEObject as RepositoryComponent;
	callRenameComponentPackageAndClass(component);
}

effect: RenameComponentPackageAndClass
model input: pcm.repository.RepositoryComponent as component
retrieve element: repositoryPackage of type java.containers.Package corresponding to component.repository__RepositoryComponent
	with repositoryPackage.name.equals(component.repository__RepositoryComponent.entityName)
execute: {
	callRenameJavaPackage(component, repositoryPackage, component.entityName);
	callRenameComponentClass(component);
}

effect: RenameComponentClass
model input: pcm.repository.RepositoryComponent as component
retrieve element: componentPackage of type java.containers.Package corresponding to component
execute: callRenameJavaClassifier(component, componentPackage, component.entityName + "Impl")

response: DeleteComponentClass
trigger: remove from list pcm.repository.Repository[components__Repository]
update instances of java
execute: callDeleteJavaClassifier(change.oldValue)

response: DeletePackageForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
update instances of java
execute: callDeleteJavaPackage(change.oldValue, change.oldValue.entityName)


// #####################################################
// ################ INTERFACE RESPONSES ################

response: CreateInterface
trigger: insert in list pcm.repository.Repository[interfaces__Repository]
retrieve element: contractsPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with contractsPackage.name == "contracts"
execute: {
	val interf = change.newValue;
	callCreateJavaInterface(interf, contractsPackage, interf.entityName);
}

response: RenamedInterface
trigger: replace value pcm.repository.Interface[entityName]
update instances of java
execute: callRenameInterface(change.newAffectedEObject as OperationInterface)

effect: RenameInterface
model input: pcm.repository.OperationInterface as interf
retrieve element: contractsPackage of type java.containers.Package corresponding to interf.repository__Interface
	with contractsPackage.name == "contracts"
execute: callRenameJavaClassifier(interf, contractsPackage, interf.entityName)


// ######################################################
// ################ DATA TYPES RESPONSES ################

response: CreateCompositeDataType
trigger: insert in list pcm.repository.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CompositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
execute: {
	val compositeDataType = change.newValue as CompositeDataType;
	callCreateJavaClass(compositeDataType, datatypesPackage, compositeDataType.entityName);
}

response: RenamedCompositeDataType
trigger: replace value pcm.repository.CompositeDataType[entityName]
update instances of java
execute: callRenameCompositeDataType(change.newAffectedEObject as CompositeDataType)

effect: RenameCompositeDataType
model input: pcm.repository.CompositeDataType as compositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to compositeDataType.repository__DataType with datatypesPackage.name == "datatypes"
execute: callRenameJavaClassifier(compositeDataType, datatypesPackage, compositeDataType.entityName)

response: AddCompositeDataTypeToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
precondition: !(change.newValue.datatype_InnerDeclaration instanceof PrimitiveDataType)
retrieve element: nonPrimitiveInnerDataTypeClass of type java.classifiers.Class corresponding to change.newValue.datatype_InnerDeclaration
execute: {
	val innerDataTypeReference = createNamespaceClassifierReference(nonPrimitiveInnerDataTypeClass);
	val compositeDataType = change.newAffectedEObject as CompositeDataType;
	val innerDeclaration = change.newValue;
	callAddDataTypeToCompositeDataType(compositeDataType, innerDeclaration, innerDataTypeReference);
}

response: AddPrimitiveDataTypeToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
precondition: change.newValue.datatype_InnerDeclaration instanceof PrimitiveDataType
update instances of java
execute: {
	val innerDataTypeReference = EcoreUtil.copy(claimJaMoPPTypeForPrimitiveDataType(change.newValue.datatype_InnerDeclaration as PrimitiveDataType)) as TypeReference;
	val compositeDataType = change.newAffectedEObject as CompositeDataType;
	val innerDeclaration = change.newValue;
	callAddDataTypeToCompositeDataType(compositeDataType, innerDeclaration, innerDataTypeReference);
}

effect: AddDataTypeToCompositeDataType
model input: pcm.repository.CompositeDataType as compositeDataType, pcm.repository.InnerDeclaration as innerDeclaration, java.types.TypeReference as dataTypeReference
retrieve element: dataTypeClass of type java.classifiers.Class corresponding to compositeDataType
create element: innerDataTypeField of type java.members.Field corresponding to innerDeclaration
create element: getterMethod of type java.members.ClassMethod corresponding to innerDeclaration
create element: setterMethod of type java.members.ClassMethod corresponding to innerDeclaration
execute: {
	createPrivateField(innerDataTypeField, EcoreUtil.copy(dataTypeReference), innerDeclaration.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: ChangeNameOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[entityName]
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	val newName = change.newValue;
	compositeTypeField.name = newName;
	compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.name = "set" + newName.toFirstUpper;
	}
}


response: ChangeTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
precondition: !(change.newValue instanceof PrimitiveDataType)
retrieve element: newJavaDataType of type java.classifiers.Class corresponding to change.newValue
execute: {
	val innerDeclaration = change.newAffectedEObject as InnerDeclaration;
	val newDataTypeReference = createNamespaceClassifierReference(newJavaDataType);
	callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
}

response: ChangePrimitiveTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
precondition: change.newValue instanceof PrimitiveDataType
update instances of java
execute: {
	val innerDeclaration = change.newAffectedEObject as InnerDeclaration;
	val newDataType = EcoreUtil.copy(claimJaMoPPTypeForPrimitiveDataType(change.newValue as PrimitiveDataType));
	val TypeReference newDataTypeReference = if (newDataType instanceof ConcreteClassifier) {
			createNamespaceClassifierReference(newDataType);
		} else if (newDataType instanceof TypeReference) {
			newDataType;
		};
	callChangeInnerDeclarationType(innerDeclaration, newDataTypeReference);
}

effect: ChangeInnerDeclarationType
model input: pcm.repository.InnerDeclaration as innerDeclaration, java.types.TypeReference as newTypeReference
retrieve element: compositeTypeField of type java.members.Field corresponding to innerDeclaration
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to innerDeclaration
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to innerDeclaration
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	compositeTypeField.typeReference = EcoreUtil.copy(newTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newTypeReference)
	}
}


// ######################################################
// ################ JAVA PACKAGE EFFECTS ################

effect: CreateJavaPackage
model input: pcm.core.entity.NamedElement as sourceElementMappedToPackage, java.containers.Package as parentPackage
java input: String as packageName
create element: javaPackage of type java.containers.Package corresponding to sourceElementMappedToPackage
	persist as root at project-relative location: buildJavaFilePath(javaPackage)
execute: {
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}

effect: RenameJavaPackage
model input: pcm.core.entity.NamedElement as sourceElementMappedToPackage, java.containers.Package as parentPackage
java input: String as packageName
retrieve element: javaPackage of type java.containers.Package corresponding to sourceElementMappedToPackage
	move containing model to project-relative location: buildJavaFilePath(javaPackage)
execute: {
	javaPackage.namespaces.clear();
	if (parentPackage != null) {
		javaPackage.namespaces += parentPackage.namespaces;
		javaPackage.namespaces += parentPackage.name; 
	}
	javaPackage.name = packageName;
}

effect: DeleteJavaPackage
model input: pcm.core.entity.NamedElement as sourceElementMappedToPackage
java input: String as packageName
delete element: javaPackage of type java.containers.Package corresponding to sourceElementMappedToPackage
	with javaPackage.name.equals(packageName)


// ######################################################
// ################ JAVA CLASS EFFECTS ##################

effect: CreateJavaClass
model input: pcm.core.entity.NamedElement as sourceElementMappedToClass, java.containers.Package as containingPackage
java input: String as className
create element: javaClass of type java.classifiers.Class corresponding to sourceElementMappedToClass
execute: {
	javaClass.name = className;
	javaClass.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	callCreateCompilationUnit(sourceElementMappedToClass, javaClass, containingPackage);
}

effect: CreateJavaInterface
model input: pcm.core.entity.NamedElement as sourceElementMappedToClass, java.containers.Package as containingPackage
java input: String as className
create element: javaInterface of type java.classifiers.Interface corresponding to sourceElementMappedToClass
execute: {
	javaInterface.name = className;
	javaInterface.addModifier(ModifiersFactory.eINSTANCE.createPublic());
	callCreateCompilationUnit(sourceElementMappedToClass, javaInterface, containingPackage);
}

effect: CreateCompilationUnit
model input: pcm.core.entity.NamedElement as sourceElementMappedToClass, java.classifiers.ConcreteClassifier as classifier, java.containers.Package as containingPackage
create element: compilationUnit of type java.containers.CompilationUnit corresponding to sourceElementMappedToClass
	persist as root at project-relative location: buildJavaFilePath(compilationUnit)
execute: {
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
	compilationUnit.name = classifier.name;
	compilationUnit.classifiers.add(classifier);
}

effect: RenameJavaClassifier
model input: pcm.core.entity.NamedElement as classSourceElement, java.containers.Package as containingPackage
java input: String as className
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to classSourceElement
	move containing model to project-relative location: buildJavaFilePath(compilationUnit)
retrieve element: javaClassifier of type java.classifiers.ConcreteClassifier corresponding to classSourceElement
execute: {
	javaClassifier.name = className;
	compilationUnit.name = className;
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += containingPackage.namespaces;
	compilationUnit.namespaces += containingPackage.name;
}

effect: DeleteJavaClassifier
model input: pcm.core.entity.NamedElement as sourceElement
delete element: javaClassifier of type java.classifiers.ConcreteClassifier corresponding to sourceElement
delete element: compilationUnit of type java.containers.CompilationUnit corresponding to sourceElement



response: AddAssemblyContextInCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[assemblyContexts__ComposedStructure]
retrieve element: compositeComponentJavaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: encapsulatedComponentJavaClass of type java.classifiers.Class corresponding to change.newValue.encapsulatedComponent__AssemblyContext
create element: assemblyContextField of type java.members.Field corresponding to change.newValue
create element: newConstructorCall of type java.instantiations.NewConstructorCall corresponding to change.newValue
create element: contextClassImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: constructor of type java.members.Constructor corresponding to change.newValue
execute: {
	val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
	val newAssemblyContext = change.newValue;
	createPrivateField(assemblyContextField, typeRef, newAssemblyContext.entityName);
	compositeComponentJavaClass.members += assemblyContextField;
	addConstructorToClass(constructor, compositeComponentJavaClass)
	addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
	createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
}


// ####################################################
// ################ PROVIDED ROLES ####################

response: AddedProvidedRoleToComponent
trigger: insert in list pcm.repository.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
precondition: change.newValue instanceof OperationProvidedRole
update instances of java
execute: callAddProvidedRole(change.newValue as OperationProvidedRole)

effect: AddProvidedRole
model input: pcm.repository.OperationProvidedRole as providedRole
retrieve element: operationProvidingInterface of type java.classifiers.Interface corresponding to providedRole.providedInterface__OperationProvidedRole
retrieve element: javaClass of type java.classifiers.Class corresponding to providedRole.providingEntity_ProvidedRole
create element: interfaceImport of type java.imports.ClassifierImport corresponding to providedRole
create element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to providedRole
execute: {
	createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
	javaClass.implements.add(namespaceClassifierReference)
	addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
}

response: ChangedProvidedInterfaceOfProvidedRole
trigger: replace value pcm.repository.OperationProvidedRole[providedInterface__OperationProvidedRole]
update instances of java
execute: {
	val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: ChangedProvidingEntityOfProvidedRole
trigger: replace value pcm.repository.OperationProvidedRole[providingEntity_ProvidedRole]
update instances of java
execute: {
	val operationProvidedRole = change.newAffectedEObject as OperationProvidedRole;
	callRemoveProvidedRole(operationProvidedRole);
	callAddProvidedRole(operationProvidedRole);
}

response: RemovedProvidedRoleFromComponent
trigger: remove from list pcm.repository.RepositoryComponent[providedRoles_InterfaceProvidingEntity]
update instances of java
execute: callRemoveProvidedRole(change.oldValue)

effect: RemoveProvidedRole
model input: pcm.repository.ProvidedRole as providedRole
delete element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to providedRole
delete element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to providedRole


// ####################################################
// ################ REQUIRED ROLES ####################


response: AddRequiredRoleToComponent
trigger: insert in list pcm.repository.RepositoryComponent[requiredRoles_InterfaceRequiringEntity]
precondition: change.newValue instanceof OperationRequiredRole
retrieve element: requiredInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationRequiredRole).requiredInterface__OperationRequiredRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.requiringEntity_RequiredRole
create element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: requiredInterfaceField of type java.members.Field corresponding to change.newValue 
execute: {
	val typeRef = createNamespaceClassifierReference(requiredInterface);
	addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
	val requiredRoleName = change.newValue.entityName;
	createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
	javaClass.members += requiredInterfaceField;
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		val newParam = PCM2JaMoPPUtils.createOrdinaryParameter(EcoreUtil.copy(typeRef), requiredRoleName)
		ctor.parameters.add(newParam)
		val asssignment = PCM2JaMoPPUtils.createAssignmentFromParameterToField(requiredInterfaceField, newParam);
		ctor.statements.add(asssignment)
	}
}


// #########################################################
// ################ OPERATION SIGNATURES####################

response: AddOperationSignature
trigger: insert in list pcm.repository.OperationInterface[signatures__OperationInterface]
retrieve element: javaInterface of type java.classifiers.Interface corresponding to change.newAffectedEObject
create element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newValue
execute: {
	interfaceMethod.name = change.newValue.entityName;
	interfaceMethod.typeReference = TypesFactory.eINSTANCE.createVoid();
	javaInterface.members += interfaceMethod;
}

response: RenameOperationSignature
trigger: replace value pcm.repository.OperationSignature[entityName]
retrieve element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.newAffectedEObject
execute: {
	val operationSignature = change.newAffectedEObject as OperationSignature;
	val operationInterface = operationSignature.interface__OperationSignature;
	interfaceMethod.name = change.newValue;
	// get implementing components
	val implementingComponents = Sets.newHashSet
	operationInterface.repository__Interface.components__Repository.forEach [ comp |
		val opProvRoles = comp.providedRoles_InterfaceProvidingEntity.filter(OperationProvidedRole)
		opProvRoles.filter[it.providedInterface__OperationProvidedRole.id == operationInterface.id].forEach [ opProRole |
			implementingComponents.add(opProRole.providingEntity_ProvidedRole)
		]
	]
	val basicComponents = implementingComponents.filter(BasicComponent)
	
	// TODO HK Update name of methods of implementating components (SEFFs realizations)
//	basicComponents.forEach[
//		it.serviceEffectSpecifications__BasicComponent.forEach[
//			val correspondingClassMethods = blackboard.correspondenceInstance.getCorrespondingEObjectsByType(it, ClassMethod)
//			if(!correspondingClassMethods.nullOrEmpty){
//				correspondingClassMethods.forEach[
//					val oldTUID = blackboard.correspondenceInstance.calculateTUIDFromEObject(it)
//					it.name = newValue.toString
//					blackboard.correspondenceInstance.updateTUID(oldTUID, it)
//				]
//			}	
//		]
//	]
}

response: DeleteOperationSignature
trigger: remove from list pcm.repository.OperationInterface[signatures__OperationInterface]
delete element: interfaceMethod of type java.members.InterfaceMethod corresponding to change.oldValue
