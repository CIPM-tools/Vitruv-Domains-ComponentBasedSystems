import static extension edu.kit.ipd.sdq.vitruvius.dsls.response.tests.pcmjava.PCMJavaHelper.*;
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeComponent
import org.emftext.language.java.types.TypeReference
import org.eclipse.emf.ecore.util.EcoreUtil
import edu.kit.ipd.sdq.vitruvius.casestudies.pcmjava.transformations.pcm2java.PCM2JaMoPPUtils
import org.emftext.language.java.members.Constructor
import org.palladiosimulator.pcm.repository.OperationProvidedRole
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.repository.PrimitiveDataType
import org.emftext.language.java.classifiers.ConcreteClassifier

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm

response: CreatePackageForRepository
trigger: insert root pcm.repository.Repository
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: repositoryToPackageInfo.getPathInProject(change.newValue)
execute: {
	val newRepository = change.newValue;
	javaPackage.name = newRepository.entityName
}

/* TODO HK: Add move of components somehow. E.g. separate effects from trigger code */
response: RenameRepositoryPackages
trigger: replace value pcm.repository.Repository[entityName]
retrieve element: rootPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with rootPackage.name != "contracts" && rootPackage.name != "datatypes" // TODO HK: Check for change.oldValue currently not possible
	move containing model to project-relative location: repositoryToPackageInfo.getPathInProject(change.newAffectedEObject as Repository)
retrieve element: contractsPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with contractsPackage.name == "contracts"
	move containing model to project-relative location: repositoryToContractsPackageInfo.getPathInProject(change.newAffectedEObject as Repository)
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject
	with datatypesPackage.name == "datatypes"
	move containing model to project-relative location: repositoryToDatatypesPackageInfo.getPathInProject(change.newAffectedEObject as Repository)
execute: {
	val repository = change.newAffectedEObject as Repository;
	rootPackage.name = change.newValue;
	contractsPackage.namespaces.clear();
	contractsPackage.namespaces += repositoryToContractsPackageInfo.getPackageName(repository).split("\\.");
	datatypesPackage.namespaces.clear();
	datatypesPackage.namespaces += repositoryToDatatypesPackageInfo.getPackageName(repository).split("\\.");
}

response: CreateContractsPackageForRepository
trigger: insert root pcm.repository.Repository
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: repositoryToContractsPackageInfo.getPathInProject(change.newValue)
execute: {
	javaPackage.namespaces += repositoryToContractsPackageInfo.getPackageName(change.newValue).split("\\.");
	javaPackage.name = "contracts"
}

response: CreateDatatypesPackageForRepository
trigger: insert root pcm.repository.Repository
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: repositoryToDatatypesPackageInfo.getPathInProject(change.newValue)
execute: {
	javaPackage.namespaces += repositoryToDatatypesPackageInfo.getPackageName(change.newValue).split("\\.");
	javaPackage.name = "datatypes"
}

response: CreateClassForBasicComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
precondition: change.newValue instanceof BasicComponent
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: componentToClass.getPathInProject(change.newValue)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	compilationUnit.namespaces += componentToClass.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, componentToClass.getClassName(change.newValue));
}

response: CreatePackageForComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
create element: javaPackage of type java.containers.Package corresponding to change.newValue
persist as root at project-relative location: componentToPackageInfo.getPathInProject(change.newValue)
execute: {
	javaPackage.namespaces += repositoryToPackageInfo.getPackageName(change.newAffectedEObject as Repository);
	javaPackage.name = change.newValue.entityName
}

response: CreateInterfaceForInterface
trigger: insert in list pcm.repository.Repository[interfaces__Repository]
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: interfaceToInterface.getPathInProject(change.newValue)
create element: javaInterface of type java.classifiers.Interface corresponding to change.newValue
execute: {
	compilationUnit.namespaces += interfaceToInterface.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaInterface, interfaceToInterface.getClassName(change.newValue));
}

response: DeleteClassForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
delete element: compilationUnit of type java.containers.CompilationUnit corresponding to change.oldValue
delete element: javaClass of type java.classifiers.Class corresponding to change.oldValue

response: DeletePackageForBasicComponent
trigger: remove from list pcm.repository.Repository[components__Repository]
delete element: javaPackage of type java.containers.Package corresponding to change.oldValue


response: RenamePackageForBasicComponent
trigger: replace value pcm.repository.BasicComponent[entityName]
retrieve element: javaPackage of type java.containers.Package corresponding to change.newAffectedEObject
	move containing model to project-relative location: componentToPackageInfo.getPathInProject(change.newAffectedEObject as BasicComponent)
execute: {
	javaPackage.namespaces.clear();
	javaPackage.namespaces += repositoryToPackageInfo.getPackageName(change.newAffectedEObject.eContainer() as Repository);
	javaPackage.name = change.newValue
}


response: RenameClassForBasicComponent
trigger: replace value pcm.repository.BasicComponent[entityName]
retrieve element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newAffectedEObject
	move containing model to project-relative location: componentToClass.getPathInProject(change.newAffectedEObject as BasicComponent)
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
execute: {
	val component = change.newAffectedEObject as BasicComponent;
	javaClass.name = componentToClass.getClassName(component);
	compilationUnit.name = componentToClass.getClassName(component);
	compilationUnit.namespaces.clear;
	compilationUnit.namespaces += componentToClass.getPackageName(component);
}


response: CreateClassForCompositeComponent
trigger: insert in list pcm.repository.Repository[components__Repository]
precondition: change.newValue instanceof CompositeComponent
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
persist as root at project-relative location: componentToClass.getPathInProject(change.newValue)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	compilationUnit.namespaces += componentToClass.getPackageName(change.newValue);
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, componentToClass.getClassName(change.newValue));
}

response: AddAssemblyContextInCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[assemblyContexts__ComposedStructure]
retrieve element: compositeComponentJavaClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: encapsulatedComponentJavaClass of type java.classifiers.Class corresponding to change.newValue.encapsulatedComponent__AssemblyContext
create element: assemblyContextField of type java.members.Field corresponding to change.newValue
create element: newConstructorCall of type java.instantiations.NewConstructorCall corresponding to change.newValue
create element: contextClassImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: constructor of type java.members.Constructor corresponding to change.newValue
execute: {
	val TypeReference typeRef = createNamespaceClassifierReference(encapsulatedComponentJavaClass);
	val newAssemblyContext = change.newValue;
	createPrivateField(assemblyContextField, typeRef, newAssemblyContext.entityName);
	compositeComponentJavaClass.members += assemblyContextField;
	addConstructorToClass(constructor, compositeComponentJavaClass)
	addImportToCompilationUnitOfClassifier(contextClassImport, compositeComponentJavaClass, encapsulatedComponentJavaClass)
	createNewForFieldInConstructor(newConstructorCall, constructor, assemblyContextField);
}

response: AddProvidedRoleToCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[providedRoles_InterfaceProvidingEntity]
precondition: change.newValue instanceof OperationProvidedRole
retrieve element: operationProvidingInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationProvidedRole).providedInterface__OperationProvidedRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.providingEntity_ProvidedRole
create element: interfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: namespaceClassifierReference of type java.types.NamespaceClassifierReference corresponding to change.newValue
execute: {
	createNamespaceClassifierReference(namespaceClassifierReference, operationProvidingInterface);
	javaClass.implements.add(namespaceClassifierReference)
	addImportToCompilationUnitOfClassifier(interfaceImport, javaClass, operationProvidingInterface);
}

response: AddRequiredRoleToCompositeComponent
trigger: insert in list pcm.repository.CompositeComponent[requiredRoles_InterfaceRequiringEntity]
precondition: change.newValue instanceof OperationRequiredRole
retrieve element: requiredInterface of type java.classifiers.Interface corresponding to (change.newValue as OperationRequiredRole).requiredInterface__OperationRequiredRole
retrieve element: javaClass of type java.classifiers.Class corresponding to change.newValue.requiringEntity_RequiredRole
create element: requiredInterfaceImport of type java.imports.ClassifierImport corresponding to change.newValue
create element: requiredInterfaceField of type java.members.Field corresponding to change.newValue 
execute: {
	val typeRef = createNamespaceClassifierReference(requiredInterface);
	addImportToCompilationUnitOfClassifier(requiredInterfaceImport, javaClass, requiredInterface);
	val requiredRoleName = change.newValue.entityName;
	createPrivateField(requiredInterfaceField, EcoreUtil.copy(typeRef), requiredRoleName);
	javaClass.members += requiredInterfaceField;
	for (ctor : javaClass.members.filter(typeof(Constructor))) {
		val newParam = PCM2JaMoPPUtils.createOrdinaryParameter(EcoreUtil.copy(typeRef), requiredRoleName)
		ctor.parameters.add(newParam)
		val asssignment = PCM2JaMoPPUtils.createAssignmentFromParameterToField(requiredInterfaceField, newParam);
		ctor.statements.add(asssignment)
	}
}

response: CreateCompositeDataType
trigger: insert in list pcm.repository.Repository[dataTypes__Repository]
precondition: change.newValue instanceof CompositeDataType
retrieve element: datatypesPackage of type java.containers.Package corresponding to change.newAffectedEObject with datatypesPackage.name == "datatypes"
create element: compilationUnit of type java.containers.CompilationUnit corresponding to change.newValue
	persist as root at project-relative location: dataTypeToClass.getPathInProject(change.newValue as CompositeDataType)
create element: javaClass of type java.classifiers.Class corresponding to change.newValue
execute: {
	val dataType = change.newValue as CompositeDataType;
	compilationUnit.namespaces += datatypesPackage.namespaces;
	compilationUnit.namespaces += datatypesPackage.name;
	initializeCompilationUnitAndJavaClassifier(compilationUnit, javaClass, dataTypeToClass.getClassName(dataType));	
}

/* TODO HK: Combine with primitive type response using new language construct */
response: AddCompositeDataTypeToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
precondition: !(change.newValue.datatype_InnerDeclaration instanceof PrimitiveDataType)
retrieve element: dataTypeClass of type java.classifiers.Class corresponding to change.newAffectedEObject
retrieve element: nonPrimitiveInnerDataTypeClass of type java.classifiers.Class corresponding to change.newValue.datatype_InnerDeclaration
create element: innerDataTypeField of type java.members.Field corresponding to change.newValue
create element: getterMethod of type java.members.ClassMethod corresponding to change.newValue
create element: setterMethod of type java.members.ClassMethod corresponding to change.newValue
execute: {
	val typeRef = createNamespaceClassifierReference(nonPrimitiveInnerDataTypeClass);
	createPrivateField(innerDataTypeField, EcoreUtil.copy(typeRef), change.newValue.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: AddPrimitiveDataTypeToCompositeDataType
trigger: insert in list pcm.repository.CompositeDataType[innerDeclaration_CompositeDataType]
precondition: change.newValue.datatype_InnerDeclaration instanceof PrimitiveDataType
retrieve element: dataTypeClass of type java.classifiers.Class corresponding to change.newAffectedEObject
create element: innerDataTypeField of type java.members.Field corresponding to change.newValue
create element: getterMethod of type java.members.ClassMethod corresponding to change.newValue
create element: setterMethod of type java.members.ClassMethod corresponding to change.newValue
execute: {
	val typeRef = EcoreUtil.copy(claimJaMoPPTypeForPrimitiveDataType(change.newValue.datatype_InnerDeclaration as PrimitiveDataType)) as TypeReference;
	createPrivateField(innerDataTypeField, EcoreUtil.copy(typeRef), change.newValue.entityName);
	createSetter(innerDataTypeField, setterMethod);	
	createGetter(innerDataTypeField, getterMethod);
	dataTypeClass.members += innerDataTypeField;
	dataTypeClass.members += getterMethod;
	dataTypeClass.members += setterMethod;
	sortMembers(dataTypeClass.members);
}

response: ChangeNameOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[entityName]
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	val newName = change.newValue;
	compositeTypeField.name = newName;
	compositeTypeGetterMethod.name = "get" + newName.toFirstUpper;
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.name = "set" + newName.toFirstUpper;
	}
}

response: ChangeTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
precondition: !(change.newValue instanceof PrimitiveDataType)
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
retrieve element: newJavaDataType of type java.classifiers.Class corresponding to change.newValue
execute: {
	val newDataTypeReference = createNamespaceClassifierReference(newJavaDataType);
	compositeTypeField.typeReference = EcoreUtil.copy(newDataTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newDataTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newDataTypeReference)
	}
}

response: ChangePrimitiveTypeOfInnerDeclaration
trigger: replace value pcm.repository.InnerDeclaration[datatype_InnerDeclaration]
precondition: change.newValue instanceof PrimitiveDataType
retrieve element: compositeTypeField of type java.members.Field corresponding to change.newAffectedEObject
retrieve element: compositeTypeGetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeGetterMethod.name.startsWith("get")
retrieve element: compositeTypeSetterMethod of type java.members.Method corresponding to change.newAffectedEObject
	with compositeTypeSetterMethod.name.startsWith("set")
execute: {
	val newDataType = EcoreUtil.copy(claimJaMoPPTypeForPrimitiveDataType(change.newValue as PrimitiveDataType));
	val TypeReference newDataTypeReference = if (newDataType instanceof ConcreteClassifier) {
			createNamespaceClassifierReference(newDataType);
		} else if (newDataType instanceof TypeReference) {
			newDataType;
		};
	compositeTypeField.typeReference = EcoreUtil.copy(newDataTypeReference);
	compositeTypeGetterMethod.typeReference = EcoreUtil.copy(newDataTypeReference);
	if (!compositeTypeSetterMethod.parameters.nullOrEmpty) {
		val parameter = compositeTypeSetterMethod.parameters.get(0)
		parameter.typeReference = EcoreUtil.copy(newDataTypeReference)
	}
}
