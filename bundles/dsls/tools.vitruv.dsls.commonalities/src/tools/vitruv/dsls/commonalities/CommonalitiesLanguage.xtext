grammar tools.vitruv.dsls.commonalities.CommonalitiesLanguage
	with org.eclipse.xtext.xbase.Xbase
	hidden(WS, ML_COMMENT, SL_COMMENT)

generate language "http://vitruv.tools/dsls/commonalities/language"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://vitruv.tools/dsls/commonalities/elements"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

CommonalityFile:
	concept=Concept
	commonality=Commonality
;

Domain:
	Concept
;

Concept:
	'concept' name=ID
;

Metaclass:
	Commonality
;

Commonality:
	'commonality' name=ID '{'
		participations+=Participation*
		(attributes+=CommonalityAttribute|references+=CommonalityReference)*
	'}'
;



/******************
 * Participations *
 ******************/

PackageLike:
	Participation
;

Participation:
	'with' (SimpleParticipation | TupleParticipation)
	('as' Aliasable)?
	('whereat' '{'
		(
			conditions+=ParticipationCondition
			(',' conditions+=ParticipationCondition)*
		)?
	'}')?
;

SimpleParticipation:
	participationClass=QualifiedParticipationClassDeclaration
;

TupleParticipation:
	domainName=DomainReference ':' '(' parts+=TupleParticipationPart (','
	parts+=TupleParticipationPart)* ')'
;

TupleParticipationPart:
	SimpleTupleParticipationPart | ParticipationRelation
;

SimpleTupleParticipationPart:
	participationClass=UnqualifiedParticipationClassDeclaration
;

ParticipationRelation:
	SimpleParticipationRelation | BracedParticipationRelation
;

SimpleParticipationRelation returns ParticipationRelation:
	leftClasses+=UnqualifiedParticipationClassDeclaration operator=[jvmTypes::JvmDeclaredType]
	rightClasses+=UnqualifiedParticipationClassDeclaration
;

BracedParticipationRelation returns ParticipationRelation:
	'(' leftClasses+=UnqualifiedParticipationClassDeclaration (',' leftClasses+=UnqualifiedParticipationClassDeclaration)*
	operator=[jvmTypes::JvmDeclaredType]
	rightClasses+=UnqualifiedParticipationClassDeclaration (',' rightClasses+=UnqualifiedParticipationClassDeclaration)*
	')'
;

fragment Aliasable:
	alias=STRING
;

ClassLike:
	ParticipationClass
;

ParticipationClass:
	QualifiedParticipationClassDeclaration | UnqualifiedParticipationClassDeclaration
;

QualifiedParticipationClassDeclaration returns ParticipationClass:
	superMetaclass=[Metaclass|QualifiedMetaclass] ('called' Aliasable)?
;

UnqualifiedParticipationClassDeclaration returns ParticipationClass:
	superMetaclass=[Metaclass|UnqualifiedMetaclass] ('called' Aliasable)?
;

ParticipationCondition:
	({BidirectionalParticipationCondition} | '->' {EnforcedParticipationCondition} | '<-' {CheckedParticipationCondition})
	leftOperand=ParticipationConditionLeftOperand operator=[jvmTypes::JvmDeclaredType|OpName]
	(
		(rightOperands+=ParticipationConditionRightOperand)
		| ('(' (rightOperands+=ParticipationConditionRightOperand (',' rightOperands+=ParticipationConditionRightOperand)*)? ')')
	)?
;

ParticipationConditionLeftOperand:
	participationClass=[ParticipationClass|UnqualifiedParticipationClass] ('.' attribute=[Attribute|UnqualifiedParticipationMember])?
;

ParticipationConditionRightOperand:
	ParticipationClassOperand | ParticipationAttributeOperand | LiteralOperand
;

ParticipationClassOperand:
	participationClass=[ParticipationClass|UnqualifiedParticipationClass]
;

ParticipationAttributeOperand:
	participationAttribute=UnqualifiedParticipationAttribute
;

LiteralOperand:
	expression=(XBooleanLiteral |
		XNumberLiteral |
		XNullLiteral |
		XStringLiteral)
;

// To correctly parse character combinations, we need to copy all tokens that
// already occurred in the parent grammars (i.e. Xbase)
// '->' and '<-': Ambiguous since the next participation condition may start with this as well
OpName:
	ID |
	( '+=' | '-=' | '*=' | '/=' | '%=' | '>=' | '<=' | '||' | '&&' | '==' | '!=' | '===' | '!=='
	| '=>' | '<>' | '?:' | '**' | '--' | '++' | '::'
	| '=' | '!' | '%' | '&' | '*' | '+' | '-' | '/' | '<' | '>' | '^' | '~' | '_' | ':' | '?')+
;

/**************
 * Attributes *
 **************/

Attribute:
	CommonalityAttribute | ParticipationAttribute
;

CommonalityAttribute:
	'has' name=ID '{'
		mappings+=CommonalityAttributeMapping*
	'}'
;

CommonalityAttributeMapping:
	('=' {AttributeEqualitySpecification} | '->' {AttributeSetSpecification} | '<-' {AttributeReadSpecification})
	attribute=QualifiedParticipationAttribute
;

ParticipationAttribute:
	QualifiedParticipationAttribute | UnqualifiedParticipationAttribute
;

QualifiedParticipationAttribute returns ParticipationAttribute:
	participationClass=[ParticipationClass|QualifiedParticipationClass] '.' attribute=[Attribute|UnqualifiedParticipationMember]
;

UnqualifiedParticipationAttribute returns ParticipationAttribute:
	participationClass=[ParticipationClass|UnqualifiedParticipationClass] '.' attribute=[Attribute|UnqualifiedParticipationMember]
;


/**************
 * References *
 **************/

Reference:
	CommonalityReference
;

CommonalityReference:
	'has' name=ID 'referencing' referenceType=[Commonality|QualifiedCommonality] '{'
		mappings+=CommonalityReferenceMapping*
	'}'
;

CommonalityReferenceMapping:
	('=' {ReferenceEqualitySpecification} | '->' {ReferenceSetSpecification} | '<-' {ReferenceReadSpecification})
	reference=QualifiedParticipationAttribute
	// TODO not used right now
	('via' referenceTargets+=[ParticipationClass|QualifiedParticipationClass] (',' referenceTargets+=[ParticipationClass|QualifiedParticipationClass])*)?
;

/******************
 * Datatype Rules *
 ******************/

fragment QualifiedClasslike:
	ID ':' ID;

QualifiedMetaclass:
	QualifiedClasslike
;

QualifiedCommonality:
	QualifiedClasslike
;

QualifiedParticipationClass:
	QualifiedClasslike
;

UnqualifiedParticipationClass:
	UnqualifiedMetaclass
;

DomainReference:
	ID
;

UnqualifiedMetaclass:
	ID
;

UnqualifiedParticipationMember:
	ID
;

/******************
 * Terminal Rules *
 ******************/

