/*
 * generated by Xtext 2.12.0
 */
package tools.vitruv.dsls.commonalities.validation

import java.util.regex.Pattern
import org.eclipse.xtext.validation.Check
import tools.vitruv.dsls.commonalities.language.Aliasable
import tools.vitruv.dsls.commonalities.language.CommonalityReferenceMapping
import tools.vitruv.dsls.commonalities.language.Participation
import tools.vitruv.dsls.commonalities.language.ParticipationClass
import tools.vitruv.dsls.commonalities.language.elements.Metaclass

import static tools.vitruv.dsls.commonalities.language.LanguagePackage.Literals.*

import static extension tools.vitruv.dsls.commonalities.language.extensions.CommonalitiesLanguageModelExtensions.*
import static extension tools.vitruv.dsls.commonalities.language.extensions.ParticipationContextHelper.*

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CommonalitiesLanguageValidator extends AbstractCommonalitiesLanguageValidator {

	// Note: This is a subset of the valid IDs
	static val ALIAS_REGEX = "^[a-zA-Z][a-zA-z0-9_]*$"
	static val ALIAS_PATTERN = Pattern.compile(ALIAS_REGEX)

	@Check
	def checkAlias(Aliasable aliasable) {
		val alias = aliasable.alias
		if (alias === null) return; // has no alias -> ignore
		if (!ALIAS_PATTERN.matcher(alias).matches) {
			error('''Invalid alias («alias»). Valid format: «ALIAS_REGEX»)''', ALIASABLE__ALIAS)
		}
	}

	@Check
	def checkParticipationClasses(Participation participation) {
		if (participation.classes.empty) {
			error('Participation is empty.', participation, null)
		} else if (participation.nonRootClasses.empty) {
			error('Participation has no non-root classes.', participation, null)
		}
		// TODO check for containment cycles
	}

	@Check
	def checkReferencedParticipation(CommonalityReferenceMapping mapping) {
		val referenceRightType = mapping.reference?.type
		if (referenceRightType === null) return;
		if (!(referenceRightType instanceof Metaclass)) {
			error('Reference mappings can only use EReferences.', COMMONALITY_REFERENCE_MAPPING__REFERENCE)
			return;
		}

		val referencedParticipations = mapping.referencedParticipations.toList
		if (referencedParticipations.size === 0) {
			error('''«mapping.referencedCommonality» has no participation of domain «
				mapping.participation.domainName».''', mapping, null)
			return;
		} else if (referencedParticipations.size > 1) {
			error('''Ambiguous reference mapping: «mapping.referencedCommonality» has more than one participation of «
				»domain «mapping.participation.domainName».''', mapping, null)
			return;
		}

		val referencedParticipation = referencedParticipations.head
		val nonRootBoundaryClasses = referencedParticipation.nonRootBoundaryClasses
		// assert: !nonRootBoundaryClasses.empty
		if (!nonRootBoundaryClasses.filter[!mapping.isAssignmentCompatible(it)].empty) {
			error('''The referenced classes of participation «referencedParticipation» in «
				mapping.referencedCommonality» are not assignment compatible with reference type «
				referenceRightType».''', COMMONALITY_REFERENCE_MAPPING__REFERENCE)
			return;
		}
	}

	def private static getReferencedParticipations(CommonalityReferenceMapping mapping) {
		val participationDomainName = mapping.participation.domainName
		val referencedCommonality = mapping.referencedCommonality
		return referencedCommonality.participations.filter [
			it.domainName == participationDomainName
		]
	}

	@Check
	def checkParticipationClassSuperclassIsNotAbstract(ParticipationClass participationClass) {
		if (participationClass.superMetaclass?.isAbstract) {
			error('''Abstract classes cannot be used as participations.''', PARTICIPATION_CLASS__SUPER_METACLASS)
		}
	}

	// TODO support multiple resource root containers?
	/**
	 * Participations can only contain a single Resource class.
	 * <p>
	 * If the participation has a Resource class, it is required to be the only
	 * root container class.
	 * <p>
	 * Note: If the participation does not specify any Resource root container,
	 * it either relies on external commonality reference mappings to specify a
	 * root container for it, or it is a commonality participation whose
	 * classes are implicitly contained inside the intermediate model's root.
	 * In these cases, the participation is allowed to have multiple root
	 * classes.
	 */
	@Check
	def checkParticipationHasSingleResourceRoot(Participation participation) {
		val resourceClasses = participation.resourceClasses.toSet
		if (resourceClasses.size > 1) {
			error('''Participations can only contain a single Resource class.''', participation, null)
		} else if (resourceClasses.size == 1 && resourceClasses != participation.rootContainerClasses) {
			error('''The Resource class has to be the (only) root class.''', participation, null)
		}
	}

	def private static getResourceClasses(Participation participation) {
		return participation.classes.filter[isForResource]
	}

	@Check
	def checkSingleton(Participation participation) {
		val numberOfSingletons = participation.singletonClasses.size
		if (numberOfSingletons == 0) return;

		if (numberOfSingletons > 1) {
			error('''Participations can only contain a single singleton class.''', participation, null)
		} else {
			if (!participation.hasResourceClass) {
				error('''Participations with a singleton class marked need to specify a Resource root.''', participation, null)
			}

			// Note: The singleton class also indicates the head of the participation's root. We therefore prohibit
			// specifying that any of the other classes be contained in one of the singleton's containers.
			val singletonClass = participation.singletonClass
			val singletonContainers = singletonClass.transitiveContainerClasses
			if (singletonContainers.exists[containedClasses.size > 1]) {
				error('''The containers of the singleton class need to form a containment chain (contain each at most«
					»one object).''', participation, null)
			}
		}
	}

	def private static getSingletonClasses(Participation participation) {
		return participation.classes.filter[isSingleton]
	}
}
