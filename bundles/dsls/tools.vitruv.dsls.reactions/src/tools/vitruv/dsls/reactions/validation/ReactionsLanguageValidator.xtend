/*
 * generated by Xtext 2.9.0
 */
package tools.vitruv.dsls.reactions.validation

import com.google.inject.Inject
import org.eclipse.xtext.validation.Check
import tools.vitruv.dsls.reactions.reactionsLanguage.ReactionsLanguagePackage
import java.util.HashMap
import tools.vitruv.dsls.reactions.reactionsLanguage.Routine
import tools.vitruv.dsls.reactions.reactionsLanguage.RetrieveModelElement
import tools.vitruv.dsls.reactions.reactionsLanguage.CreateModelElement
import tools.vitruv.dsls.reactions.reactionsLanguage.Reaction
import tools.vitruv.dsls.reactions.reactionsLanguage.ReactionsSegment
import static extension tools.vitruv.dsls.reactions.codegen.helper.ClassNamesGenerators.*
import static extension tools.vitruv.dsls.reactions.codegen.helper.RoutineCallMethodNames.*
import static tools.vitruv.dsls.reactions.codegen.helper.ReactionsLanguageConstants.*
import tools.vitruv.dsls.reactions.reactionsLanguage.ModelElementChange
import tools.vitruv.dsls.reactions.reactionsLanguage.ElementReferenceChangeType
import org.eclipse.emf.ecore.EClass
import tools.vitruv.dsls.reactions.reactionsLanguage.ElementCreationAndInsertionChangeType
import tools.vitruv.dsls.reactions.reactionsLanguage.ElementChangeType
import tools.vitruv.dsls.reactions.reactionsLanguage.ElementDeletionAndRemovalChangeType
import tools.vitruv.dsls.reactions.reactionsLanguage.ElementDeletionAndCreationAndReplacementChangeType
import tools.vitruv.dsls.reactions.scoping.RoutinesImportScopeHelper
import tools.vitruv.dsls.reactions.reactionsLanguage.ReactionsFile
import tools.vitruv.dsls.reactions.reactionsLanguage.RoutinesImport

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ReactionsLanguageValidator extends AbstractReactionsLanguageValidator {

	@Inject RoutinesImportScopeHelper routinesImportScopeHelper;

	@Check
	def checkReactionsFile(ReactionsFile reactionsFile) {
		// check for duplicate routines imports:
		val alreadyCheckedRoutinesImports = new HashMap<String, RoutinesImport>();
		for (routinesImport : reactionsFile.routinesImports) {
			val importedSegmentName = routinesImport.reactionsSegment.name;
			if (alreadyCheckedRoutinesImports.putIfAbsent(importedSegmentName, routinesImport) !== null) {
				val errorMessage = "Duplicate routines import: " + importedSegmentName;
				error(errorMessage, routinesImport, ReactionsLanguagePackage.Literals.ROUTINES_IMPORT__REACTIONS_SEGMENT);
				val duplicateRoutinesImport = alreadyCheckedRoutinesImports.get(importedSegmentName);
				error(errorMessage, duplicateRoutinesImport, ReactionsLanguagePackage.Literals.ROUTINES_IMPORT__REACTIONS_SEGMENT);
			}
		}

		// check for duplicate reactions segment names in same file:
		val alreadyCheckedSegments = new HashMap<String, ReactionsSegment>();
		for (reactionsSegment : reactionsFile.reactionsSegments) {
			val reactionsSegmentName = reactionsSegment.name;
			if (alreadyCheckedSegments.putIfAbsent(reactionsSegmentName, reactionsSegment) !== null) {
				val errorMessage = "Duplicate reactions segment name: " + reactionsSegmentName;
				error(errorMessage, reactionsSegment, ReactionsLanguagePackage.Literals.REACTIONS_SEGMENT__NAME);
				val duplicateNameSegment = alreadyCheckedSegments.get(reactionsSegmentName);
				error(errorMessage, duplicateNameSegment, ReactionsLanguagePackage.Literals.REACTIONS_SEGMENT__NAME);
			}
		}

		// check for duplicate reactions segment names globally:
		val resource = reactionsFile.eResource;
		val visibleReactionsSegments = routinesImportScopeHelper.getVisibleReactionsSegmentDescriptions(resource, false);
		for (reactionsSegment : reactionsFile.reactionsSegments) {
			val reactionsSegmentName = reactionsSegment.name;
			val duplicateNameSegment = visibleReactionsSegments.findFirst[name.toString.equals(reactionsSegmentName)];
			if (duplicateNameSegment !== null) {
				// path relative to current file:
				val pathToOtherSegment = duplicateNameSegment.EObjectURI.trimFragment.deresolve(resource.URI);
				warning(
					"Duplicate reactions segment name '" + reactionsSegmentName + "': Already defined in " + pathToOtherSegment,
					reactionsSegment,
					ReactionsLanguagePackage.Literals.REACTIONS_SEGMENT__NAME
				);
			}
		}
	}

	@Check
	def checkReactionsFile(ReactionsSegment reactionsSegment) {
		// check for duplicate reaction names in same segment:
		val alreadyCheckedReactions = new HashMap<String, Reaction>();
		for (reaction : reactionsSegment.reactions) {
			val reactionName = reaction.reactionClassNameGenerator.simpleName;
			if (alreadyCheckedReactions.putIfAbsent(reactionName, reaction) !== null) {
				val errorMessage = "Duplicate reaction name: " + reactionName;
				error(errorMessage, reaction, ReactionsLanguagePackage.Literals.REACTION__NAME);
				error(
					errorMessage,
					alreadyCheckedReactions.get(reactionName),
					ReactionsLanguagePackage.Literals.REACTION__NAME
				);
			}
		}

		// check for duplicate routine names in same segment:
		val alreadyCheckedRoutines = new HashMap<String, Routine>();
//		for (implicitRoutine : reactionSegment.reactions.map[routine]) {
//			alreadyCheckedEffects.put(implicitRoutine.routineClassNameGenerator.simpleName, implicitRoutine);
//		}
		for (routine : reactionsSegment.routines) {
			val routineName = routine.callMethodName
			if (alreadyCheckedRoutines.putIfAbsent(routineName, routine) !== null) {
				val errorMessage = "Duplicate routine name: " + routineName;
				error(errorMessage, routine, ReactionsLanguagePackage.Literals.ROUTINE__NAME);
				val duplicateNameRoutine = alreadyCheckedRoutines.get(routineName);
				error(errorMessage, duplicateNameRoutine, ReactionsLanguagePackage.Literals.ROUTINE__NAME);
			}
		}

		// check for duplicate routine names across imports:
		val alreadyCheckedImportedRoutines = new HashMap<String, Routine>();
		for (routinesImport : reactionsSegment.reactionsFile.routinesImports) {
			val importedReactionsSegment = routinesImport.reactionsSegment;
			for (importedRoutine : importedReactionsSegment.routines) {
				val importedRoutineName = routinesImport.getImportedCallMethodName(importedRoutine);

				// name clashes with local routines:
				if (alreadyCheckedRoutines.containsKey(importedRoutineName)) {
					val duplicateNameRoutine = alreadyCheckedRoutines.get(importedRoutineName);
					warning(
						"Duplicate routine name '" + importedRoutineName + "': Hides an imported routine from " + importedReactionsSegment.name,
						duplicateNameRoutine,
						ReactionsLanguagePackage.Literals.ROUTINE__NAME
					);
				}

				// name clashes with routines from other imports:
				val duplicateNameImportedRoutine = alreadyCheckedImportedRoutines.putIfAbsent(importedRoutineName, importedRoutine);
				if (duplicateNameImportedRoutine !== null) {
					warning(
						"Contains ambiguous routine name '" + importedRoutineName + "': Already defined in " 
							+ duplicateNameImportedRoutine.reactionsSegment.name,
						routinesImport,
						ReactionsLanguagePackage.Literals.ROUTINES_IMPORT__REACTIONS_SEGMENT
					);
				}
			}
		}
	}

	@Check
	def checkRetrieveElementName(RetrieveModelElement element) {
		if (!element.name.nullOrEmpty && element.name.startsWith("_")) {
			error("Element names must not start with an underscore.",
				ReactionsLanguagePackage.Literals.RETRIEVE_MODEL_ELEMENT__NAME);
		}
	}
	
		@Check
	def checkCreateElementName(CreateModelElement element) {
		if (!element.name.nullOrEmpty && element.name.startsWith("_")) {
			error("Element names must not start with an underscore.",
				ReactionsLanguagePackage.Literals.CREATE_MODEL_ELEMENT__NAME);
		}
	}

//	@Check
//	def checkEffects(Effect effect) {
//		if (effect.impact.codeBlock === null && !effect.impact..filter(CorrespondingModelElementCreate).nullOrEmpty) {
//			warning("Created elements must be initialized and inserted into the target model in the execute block.",
//				ReactionsLanguagePackage.Literals.EFFECT__CODE_BLOCK);
//		}
//	}
	
//	@Check
//	def checkEffectInput(RoutineInput effectInput) {
//		if (!effectInput.javaInputElements.empty) {
//			warning("Using plain Java elements is discouraged. Try to use model elements and make list inputs to single valued input of other effect that is called for each element.",
//				ReactionsLanguagePackage.Literals.ROUTINE_INPUT__JAVA_INPUT_ELEMENTS);
//		}
//	}
	
	@Check
	def checkRoutine(Routine routine) {
		if (!Character.isLowerCase(routine.name.charAt(0))) {
			warning("Routine names should start lower case",
				ReactionsLanguagePackage.Literals.ROUTINE__NAME);
		}
		if (routine.name.contains(IMPORTED_ROUTINE_PREFIX_SEPARATOR)) {
			warning("Routine names should not contain '" + IMPORTED_ROUTINE_PREFIX_SEPARATOR + "'",
				ReactionsLanguagePackage.Literals.ROUTINE__NAME);
		}
	}
	
	@Check
	def checkRoutine(Reaction reaction) {
		if (!Character.isUpperCase(reaction.name.charAt(0))) {
			warning("Reaction names should start upper case",
				ReactionsLanguagePackage.Literals.REACTION__NAME);
		}
	}
	
	@Check
	def checkMetaclassFeature(ModelElementChange elementChange) {
		val elementType = elementChange?.elementType?.metaclass;
		val elementChangeType = elementChange?.changeType;
		// Only continue if element type is specified and its a feature change
		var ElementChangeType atomicChangeType = null;
		if (elementChangeType instanceof ElementReferenceChangeType) {
			atomicChangeType = elementChangeType;
		} else if (elementChangeType instanceof ElementCreationAndInsertionChangeType) {
			atomicChangeType = elementChangeType.insertChange;
		} else if (elementChangeType instanceof ElementDeletionAndRemovalChangeType) {
			atomicChangeType = elementChangeType.removeChange;
		} else if (elementChangeType instanceof ElementDeletionAndCreationAndReplacementChangeType) {
			atomicChangeType = elementChangeType.replacedChange;
		}
		if (atomicChangeType instanceof ElementReferenceChangeType) {
			val featureType = atomicChangeType.feature?.feature?.EType as EClass;
			if (elementType !== null && featureType !== null) {
				if (!elementType.equals(featureType) && !elementType.EAllSuperTypes.contains(featureType) && !featureType.EAllSuperTypes.contains(elementType)) {
					warning("Element of specified type cannot be contained in the specified features",
						elementChange, ReactionsLanguagePackage.Literals.MODEL_ELEMENT_CHANGE__ELEMENT_TYPE
					)
				}
			}
		}
	}

}
