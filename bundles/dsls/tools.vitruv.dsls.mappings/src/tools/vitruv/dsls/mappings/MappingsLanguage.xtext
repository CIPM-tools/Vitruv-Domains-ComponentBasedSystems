grammar tools.vitruv.dsls.Mappings with tools.vitruv.dsls.mirbase.MirBase
hidden(WS, SL_COMMENT)

generate mappings "http://vitruv.tools/dsls/mappings/MappingsLanguage"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.kit.edu/ipd/sdq/vitruvius/dsls/mirbase/MirBase" as mirbase

MappingsFile:
	(namespaceImports=XImportSection)?
	MirBaseFile
	(mappingsSegments+=MappingsSegment)+
;

MappingsSegment:
	Documentable
	'mappings:' name=ValidID
	'for' leftDomain=DomainReference 
	'and' rightDomain=DomainReference
	(mappings+=Mapping |
		bootstrapMappings+=BootstrapMapping)*
;
		
Mapping:
	'mapping' name=ValidID
		('depends on' input=MappingInput)?
	'{'
		'map (' (leftParameters+=Parameter)+ ')'
			('with {' 
				(leftConditions+=SingleSidedCondition)+
			'}')?
		'and (' (rightParameters+=Parameter)+ ')'
			('with {' 
				(rightConditions+=SingleSidedCondition)+
			'}')?
		('such that {'
			(bidirectionalizableConditions+=BidirectionalizableCondition)+
		'}')?
		('forward execute {'
			forwardExecutionCode=CodeBlock
		'} backward execute {'
			backwardExecutionCode=CodeBlock
		'}')?
	'}'
;
	
Parameter:
	{ClassicallyNamedModelElement}
;
	
SingleSidedCondition returns ConditionExpression:
	FeatureCondition |
	ResourceCondition |
	CheckAndEnforceCode
;

FeatureCondition returns ConditionExpression:
	(SingleValueCondition |
	MultiValueCondition |
	ElementCondition |
	NotEmptyCondition)
	feature=MetaclassFeatureReference
;
ValueCondition returns ValueCondition:
	valueExpression=ValueExpression
;

SingleValueCondition returns ValueCondition:
	operator=SingleValueConditionOperator
;

SingleValueConditionOperator:
	IndexOperator |
	NumCompareOperator
;

IndexOperator:
	negated?='not'
	'at index'
	valueExpression=ValueExpression
	'in'
;

NumCompareOperator:
	NotGreaterOperator |
	LessOperator |
	NotLessOperator |
	GreaterOperator
;

NotGreaterOperator: '<=';

LessOperator: '<';

NotLessOperator: '>=';

GreaterOperator: '>';

MultiValueCondition returns ValueCondition:
	negated?='not'
	operator=MultiValueConditionOperator
;

ValueExpression:
	{CodeBlock}
;

MultiValueConditionOperator:
	'equals' | 'in'
;


BidirectionalizableCondition returns ConditionExpression:
	'TODO'
;

CodeBlock:
	code=XExpression;
	
BootstrapMapping: 
	'bootstrap mapping' name=ValidID
	'{'
		'create (' (parameters+=Parameter)+ ')' 
		('with {'
			bootstrapConditon=SingleSidedCondition
		'}')?
	'}'
;
	
MappingInput:
	{MappingInput}
	'(' ((modelInputElements+=ClassicallyNamedModelElement | "plain" javaInputElements+=NamedJavaElement)
		(',' (modelInputElements+=ClassicallyNamedModelElement | "plain" javaInputElements+=NamedJavaElement))*)? ')'
;
		
fragment Documentable:
	(documentation=ML_COMMENT)?
;
	

		